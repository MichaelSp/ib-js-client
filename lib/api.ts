// @ts-ignore
/* eslint-disable */
/**
 * Client Portal Web API
 * Client Poral Web API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration";
import globalAxios, { AxiosPromise, AxiosInstance } from "axios";
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from "./common";
// @ts-ignore
import {
  BASE_PATH,
  COLLECTION_FORMATS,
  RequestArgs,
  BaseAPI,
  RequiredError,
} from "./base";

/**
 * account information
 * @export
 * @interface Account
 */
export interface Account {
  /**
   * The account identification value
   * @type {string}
   * @memberof Account
   */
  id?: string;
  /**
   * The account number
   * @type {string}
   * @memberof Account
   */
  accountId?: string;
  /**
   * The accountAlias
   * @type {string}
   * @memberof Account
   */
  accountVan?: string;
  /**
   * Title of the account
   * @type {string}
   * @memberof Account
   */
  accountTitle?: string;
  /**
   * Whichever value is not null in this priority
   * @type {string}
   * @memberof Account
   */
  displayName?: AccountDisplayNameEnum;
  /**
   * User customizable account alias. Refer to [Configure Account Alias](https://guides.interactivebrokers.com/cp/cp.htm#am/settings/accountalias.htm) for details.
   * @type {string}
   * @memberof Account
   */
  accountAlias?: string;
  /**
   * When the account was opened in unix time.
   * @type {number}
   * @memberof Account
   */
  accountStatus?: number;
  /**
   * Base currency of the account.
   * @type {string}
   * @memberof Account
   */
  currency?: AccountCurrencyEnum;
  /**
   * Account Type
   * @type {string}
   * @memberof Account
   */
  type?: AccountTypeEnum;
  /**
   * UNI - Deprecated property
   * @type {string}
   * @memberof Account
   */
  tradingType?: string;
  /**
   * If an account is a sub-account to a Financial Advisor.
   * @type {boolean}
   * @memberof Account
   */
  faclient?: boolean;
  /**
   * Status of the Account   * O = Open   * P or N = Pending   * A = Abandoned   * R = Rejected   * C = Closed
   * @type {string}
   * @memberof Account
   */
  clearingStatus?: AccountClearingStatusEnum;
  /**
   * Is a Covestor Account
   * @type {boolean}
   * @memberof Account
   */
  covestor?: boolean;
  /**
   *
   * @type {AccountParent}
   * @memberof Account
   */
  parent?: AccountParent;
  /**
   * Formatted \"accountId - accountAlias\"
   * @type {string}
   * @memberof Account
   */
  desc?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum AccountDisplayNameEnum {
  AccountTitle = "accountTitle",
  AccountVan = "accountVan",
  AccountId = "accountId",
}
/**
 * @export
 * @enum {string}
 */
export enum AccountCurrencyEnum {
  Aud = "AUD",
  Gbp = "GBP",
  Cad = "CAD",
  Cnh = "CNH",
  Czk = "CZK",
  Dkk = "DKK",
  Eur = "EUR",
  Hkd = "HKD",
  Huf = "HUF",
  Inr = "INR",
  Ils = "ILS",
  Jpy = "JPY",
  Mxn = "MXN",
  Nok = "NOK",
  Nzd = "NZD",
  Pln = "PLN",
  Rub = "RUB",
  Sgd = "SGD",
  Sek = "SEK",
  Chf = "CHF",
  Usd = "USD",
}
/**
 * @export
 * @enum {string}
 */
export enum AccountTypeEnum {
  Individual = "INDIVIDUAL",
  Joint = "JOINT",
  Org = "ORG",
  Trust = "TRUST",
  Demo = "DEMO",
}
/**
 * @export
 * @enum {string}
 */
export enum AccountClearingStatusEnum {
  O = "O",
  P = "P",
  N = "N",
  A = "A",
  R = "R",
  C = "C",
}

/**
 *
 * @export
 * @interface AccountParent
 */
export interface AccountParent {
  /**
   *
   * @type {Array<string>}
   * @memberof AccountParent
   */
  mmc?: Array<string>;
  /**
   * Account Number for Money Manager Client
   * @type {string}
   * @memberof AccountParent
   */
  accountId?: string;
  /**
   * Is MM a Parent Account
   * @type {boolean}
   * @memberof AccountParent
   */
  isMParent?: boolean;
  /**
   * Is MM a Child Account
   * @type {boolean}
   * @memberof AccountParent
   */
  isMChild?: boolean;
  /**
   * Is a Multiplex Account. These are account models with individual account being parent and managed account being child.
   * @type {boolean}
   * @memberof AccountParent
   */
  isMultiplex?: boolean;
}
/**
 *
 * @export
 * @interface AlertRequest
 */
export interface AlertRequest {
  /**
   * orderId is required when modifying alert. You can get it from /iserver/account/:accountId/alerts
   * @type {number}
   * @memberof AlertRequest
   */
  orderId?: number;
  /**
   * name of alert
   * @type {string}
   * @memberof AlertRequest
   */
  alertName?: string;
  /**
   * The message you want to receive via email or text message
   * @type {string}
   * @memberof AlertRequest
   */
  alertMessage?: string;
  /**
   * whether alert is repeatable or not, so value can only be 0 or 1, this has to be 1 for MTA alert
   * @type {number}
   * @memberof AlertRequest
   */
  alertRepeatable?: number;
  /**
   * email address to receive alert
   * @type {string}
   * @memberof AlertRequest
   */
  email?: string;
  /**
   * whether allowing to send email or not, so value can only be 0 or 1,
   * @type {number}
   * @memberof AlertRequest
   */
  sendMessage?: number;
  /**
   * time in force, can only be GTC or GTD
   * @type {string}
   * @memberof AlertRequest
   */
  tif?: string;
  /**
   * format, YYYYMMDD-HH:mm:ss, please NOTE this will only work when tif is GTD
   * @type {string}
   * @memberof AlertRequest
   */
  expireTime?: string;
  /**
   * value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours.
   * @type {number}
   * @memberof AlertRequest
   */
  outsideRth?: number;
  /**
   * value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile
   * @type {number}
   * @memberof AlertRequest
   */
  iTWSOrdersOnly?: number;
  /**
   * value can only be 0 or 1, set to 1 to allow to show alert in pop-ups
   * @type {number}
   * @memberof AlertRequest
   */
  showPopup?: number;
  /**
   * for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert
   * @type {number}
   * @memberof AlertRequest
   */
  toolId?: number;
  /**
   * audio message to play when alert is triggered
   * @type {string}
   * @memberof AlertRequest
   */
  playAudio?: string;
  /**
   *
   * @type {Array<AlertRequestConditions>}
   * @memberof AlertRequest
   */
  conditions?: Array<AlertRequestConditions>;
}
/**
 *
 * @export
 * @interface AlertRequestConditions
 */
export interface AlertRequestConditions {
  /**
   * Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN&
   * @type {number}
   * @memberof AlertRequestConditions
   */
  type?: number;
  /**
   * conid and exchange. Format supports conid or conid@exchange
   * @type {string}
   * @memberof AlertRequestConditions
   */
  conidex?: string;
  /**
   * optional, operator for the current condition, can be >= or <=
   * @type {string}
   * @memberof AlertRequestConditions
   */
  operator?: string;
  /**
   * optional, only some type of conditions have triggerMethod
   * @type {string}
   * @memberof AlertRequestConditions
   */
  triggerMethod?: string;
  /**
   * can not be empty, can pass default value \"*\"
   * @type {string}
   * @memberof AlertRequestConditions
   */
  value?: string;
  /**
   * \"a\" means \"AND\", \"o\" means \"OR\", \"n\" means \"END\", the last one condition in the condition array should \"n\"
   * @type {string}
   * @memberof AlertRequestConditions
   */
  logicBind?: string;
  /**
   * only needed for some MTA alert condition
   * @type {string}
   * @memberof AlertRequestConditions
   */
  timeZone?: string;
}
/**
 *
 * @export
 * @interface AlertResponse
 */
export interface AlertResponse {
  /**
   * account id
   * @type {string}
   * @memberof AlertResponse
   */
  account?: string;
  /**
   *
   * @type {number}
   * @memberof AlertResponse
   */
  orderId?: number;
  /**
   * name of alert
   * @type {string}
   * @memberof AlertResponse
   */
  alertName?: string;
  /**
   * The message you want to receive via email or text message
   * @type {string}
   * @memberof AlertResponse
   */
  alertMessage?: string;
  /**
   * whether alert is active or not, so value can only be 0 or 1
   * @type {number}
   * @memberof AlertResponse
   */
  alertActive?: number;
  /**
   * whether alert is repeatable or not, so value can only be 0 or 1
   * @type {number}
   * @memberof AlertResponse
   */
  alertRepeatable?: number;
  /**
   * email address to receive alert
   * @type {string}
   * @memberof AlertResponse
   */
  alertEmail?: string;
  /**
   * whether allowing to send email or not, so value can only be 0 or 1,
   * @type {number}
   * @memberof AlertResponse
   */
  alertSendMessage?: number;
  /**
   * time in force, can only be GTC or GTD
   * @type {string}
   * @memberof AlertResponse
   */
  tif?: string;
  /**
   * format, YYYYMMDD-HH:mm:ss
   * @type {string}
   * @memberof AlertResponse
   */
  expireTime?: string;
  /**
   * status of alert
   * @type {string}
   * @memberof AlertResponse
   */
  orderStatus?: string;
  /**
   * value can only be 0 or 1, set to 1 if the alert can be triggered outside regular trading hours.
   * @type {number}
   * @memberof AlertResponse
   */
  outsideRth?: number;
  /**
   * value can only be 0 or 1, set to 1 to enable the alert only in IBKR mobile
   * @type {number}
   * @memberof AlertResponse
   */
  itwsOrdersOnly?: number;
  /**
   * value can only be 0 or 1, set to 1 to allow to show alert in pop-ups
   * @type {number}
   * @memberof AlertResponse
   */
  alertShowPopup?: number;
  /**
   * whether the alert has been triggered
   * @type {boolean}
   * @memberof AlertResponse
   */
  alertTriggered?: boolean;
  /**
   * whether the alert can be edited
   * @type {boolean}
   * @memberof AlertResponse
   */
  orderNotEditable?: boolean;
  /**
   * for MTA alert only, each user has a unique toolId and it will stay the same, do not send for normal alert
   * @type {number}
   * @memberof AlertResponse
   */
  toolId?: number;
  /**
   * audio message to play when alert is triggered
   * @type {string}
   * @memberof AlertResponse
   */
  alertPlayAudio?: string;
  /**
   * MTA alert only
   * @type {string}
   * @memberof AlertResponse
   */
  alertMtaCurrency?: string;
  /**
   * MTA alert only
   * @type {string}
   * @memberof AlertResponse
   */
  alertMtaDefaults?: string;
  /**
   * MTA alert only
   * @type {string}
   * @memberof AlertResponse
   */
  timeZone?: string;
  /**
   * MTA alert only
   * @type {string}
   * @memberof AlertResponse
   */
  alertDefaultType?: string;
  /**
   * size of conditions array
   * @type {number}
   * @memberof AlertResponse
   */
  conditionSize?: number;
  /**
   * whether allowing the condition can be triggered outside of regular trading hours, 1 means allow
   * @type {number}
   * @memberof AlertResponse
   */
  conditionOutsideRth?: number;
  /**
   *
   * @type {Array<AlertResponseConditions>}
   * @memberof AlertResponse
   */
  conditions?: Array<AlertResponseConditions>;
}
/**
 *
 * @export
 * @interface AlertResponseConditions
 */
export interface AlertResponseConditions {
  /**
   * Types: 1-Price, 3-Time, 4-Margin, 5-Trade, 6-Volume, 7: MTA market 8: MTA Position, 9: MTA Acc. Daily PN&
   * @type {number}
   * @memberof AlertResponseConditions
   */
  conditionType?: number;
  /**
   * conid and exchange. Format supports conid or conid@exchange
   * @type {string}
   * @memberof AlertResponseConditions
   */
  conidex?: string;
  /**
   * Format contract name
   * @type {string}
   * @memberof AlertResponseConditions
   */
  contractDescription1?: string;
  /**
   * optional, operator for the current condition   * >= Greater than or equal to   * <= Less than or equal to
   * @type {string}
   * @memberof AlertResponseConditions
   */
  conditionOperator?: string;
  /**
   * optional, only some type of conditions have triggerMethod
   * @type {string}
   * @memberof AlertResponseConditions
   */
  conditionTriggerMethod?: string;
  /**
   * can not be empty, can pass default value \"*\"
   * @type {string}
   * @memberof AlertResponseConditions
   */
  conditionValue?: string;
  /**
   * Condition array should end with \"n\"   * a - AND   * o - OR   * n - END
   * @type {string}
   * @memberof AlertResponseConditions
   */
  conditionLogicBind?: string;
  /**
   * only needed for some MTA alert condition
   * @type {string}
   * @memberof AlertResponseConditions
   */
  conditionTimeZone?: string;
}
/**
 *
 * @export
 * @interface AuthStatus
 */
export interface AuthStatus {
  /**
   * Brokerage session is authenticated
   * @type {boolean}
   * @memberof AuthStatus
   */
  authenticated?: boolean;
  /**
   * Connected to backend
   * @type {boolean}
   * @memberof AuthStatus
   */
  connected?: boolean;
  /**
   * Brokerage session is competing, e.g. user is logged in to IBKR Mobile, WebTrader, TWS or other trading platforms.
   * @type {boolean}
   * @memberof AuthStatus
   */
  competing?: boolean;
  /**
   * Authentication failed, why.
   * @type {string}
   * @memberof AuthStatus
   */
  fail?: string;
  /**
   * System messages that may affect trading
   * @type {string}
   * @memberof AuthStatus
   */
  message?: string;
  /**
   * Prompt messages that may affect trading or the account
   * @type {Array<string>}
   * @memberof AuthStatus
   */
  prompts?: Array<string>;
}
/**
 *
 * @export
 * @interface CalendarRequest
 */
export interface CalendarRequest {
  /**
   *
   * @type {CalendarRequestDate}
   * @memberof CalendarRequest
   */
  date?: CalendarRequestDate;
  /**
   *
   * @type {CalendarRequestFilters}
   * @memberof CalendarRequest
   */
  filters?: CalendarRequestFilters;
}
/**
 *
 * @export
 * @interface CalendarRequestDate
 */
export interface CalendarRequestDate {
  /**
   * start date of a period. for example 20180808-0400
   * @type {string}
   * @memberof CalendarRequestDate
   */
  start?: string;
  /**
   * end date of a period. for example 20180808-0400
   * @type {string}
   * @memberof CalendarRequestDate
   */
  end?: string;
}
/**
 *
 * @export
 * @interface CalendarRequestFilters
 */
export interface CalendarRequestFilters {
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  recentlyHeld?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  corporateEarnings?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  divExDates?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  ipo?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  splits?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  corporateEvents?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  economicEvents?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  optionShowMonthly?: string;
  /**
   * value can be \'true\' or \'false\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  optionShowWeekly?: string;
  /**
   * default is \'All\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  country?: string;
  /**
   * default is \'250\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  limit?: string;
  /**
   * default is \'50\'.
   * @type {string}
   * @memberof CalendarRequestFilters
   */
  limitRegion?: string;
}
/**
 * Contains all details of the contract, including rules you can use when placing orders
 * @export
 * @interface Contract
 */
export interface Contract {
  /**
   * true means you can trade outside RTH(regular trading hours)
   * @type {boolean}
   * @memberof Contract
   */
  rTH?: boolean;
  /**
   * same as that in request
   * @type {string}
   * @memberof Contract
   */
  conId?: string;
  /**
   * Contracts company name
   * @type {string}
   * @memberof Contract
   */
  companyName?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  exchange?: string;
  /**
   * for exmple FB
   * @type {string}
   * @memberof Contract
   */
  localSymbol?: string;
  /**
   * for example STK
   * @type {string}
   * @memberof Contract
   */
  instrumentType?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  companyName?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  category?: string;
  /**
   *
   * @type {string}
   * @memberof Contract
   */
  industry?: string;
  /**
   *
   * @type {ContractRules}
   * @memberof Contract
   */
  rules?: ContractRules;
}
/**
 *
 * @export
 * @interface ContractRules
 */
export interface ContractRules {
  /**
   *
   * @type {Array<string>}
   * @memberof ContractRules
   */
  orderTypes?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ContractRules
   */
  orderTypesOutside?: Array<string>;
  /**
   * default quantity you can use to place an order
   * @type {number}
   * @memberof ContractRules
   */
  defaultSize?: number;
  /**
   *
   * @type {number}
   * @memberof ContractRules
   */
  sizeIncrement?: number;
  /**
   *
   * @type {Array<string>}
   * @memberof ContractRules
   */
  tifTypes?: Array<string>;
  /**
   * default limit price you can use to prefill your order
   * @type {number}
   * @memberof ContractRules
   */
  limitPrice?: number;
  /**
   * default stop price you can use to prefill your order
   * @type {number}
   * @memberof ContractRules
   */
  stopprice?: number;
  /**
   * if you can preview the order or not with the whatif endpoint
   * @type {boolean}
   * @memberof ContractRules
   */
  preview?: boolean;
  /**
   *
   * @type {string}
   * @memberof ContractRules
   */
  displaySize?: string;
  /**
   *
   * @type {string}
   * @memberof ContractRules
   */
  increment?: string;
}
/**
 *
 * @export
 * @interface HistoryData
 */
export interface HistoryData {
  /**
   * Underlying symbol
   * @type {string}
   * @memberof HistoryData
   */
  symbol?: string;
  /**
   * companyName
   * @type {string}
   * @memberof HistoryData
   */
  text?: string;
  /**
   * priceFactor is price increment obtained from display rule
   * @type {number}
   * @memberof HistoryData
   */
  priceFactor?: number;
  /**
   * start date time in the format YYYYMMDD-HH:mm:ss
   * @type {string}
   * @memberof HistoryData
   */
  startTime?: string;
  /**
   * High value during this time series with format %h/%v/%t. %h is the high price (scaled by priceFactor), %v is volume (volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart
   * @type {string}
   * @memberof HistoryData
   */
  high?: string;
  /**
   * Low value during this time series with format %l/%v/%t. %l is the low price (scaled by priceFactor), %v is volume (volume factor will always be 100 (reported volume = actual volume/100)) and %t is minutes from start time of the chart
   * @type {string}
   * @memberof HistoryData
   */
  low?: string;
  /**
   * The duration for the historical data request
   * @type {string}
   * @memberof HistoryData
   */
  timePeriod?: string;
  /**
   * The number of seconds in a bar
   * @type {number}
   * @memberof HistoryData
   */
  barLength?: number;
  /**
   * Market Data Availability. The field may contain two chars. The first char is the primary code: S = Streaming, R = Realtime, D = Delayed, Z = Frozen, Y = Frozen Delayed. The second char is the secondary code: P = Snapshot Available, p = Consolidated.
   * @type {string}
   * @memberof HistoryData
   */
  mdAvailability?: string;
  /**
   * The time it takes, in milliseconds, to process the historical data request
   * @type {number}
   * @memberof HistoryData
   */
  mktDataDelay?: number;
  /**
   * The historical data returned includes outside of regular trading hours
   * @type {boolean}
   * @memberof HistoryData
   */
  outsideRth?: boolean;
  /**
   * The number of seconds in the trading day
   * @type {number}
   * @memberof HistoryData
   */
  tradingDayDuration?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryData
   */
  volumeFactor?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryData
   */
  priceDisplayRule?: number;
  /**
   *
   * @type {string}
   * @memberof HistoryData
   */
  priceDisplayValue?: string;
  /**
   *
   * @type {boolean}
   * @memberof HistoryData
   */
  negativeCapable?: boolean;
  /**
   *
   * @type {number}
   * @memberof HistoryData
   */
  messageVersion?: number;
  /**
   *
   * @type {Array<HistoryDataData>}
   * @memberof HistoryData
   */
  data?: Array<HistoryDataData>;
  /**
   * total number of points
   * @type {number}
   * @memberof HistoryData
   */
  points?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryData
   */
  travelTime?: number;
}
/**
 *
 * @export
 * @interface HistoryDataData
 */
export interface HistoryDataData {
  /**
   * open price
   * @type {number}
   * @memberof HistoryDataData
   */
  o?: number;
  /**
   * close price
   * @type {number}
   * @memberof HistoryDataData
   */
  c?: number;
  /**
   * high price
   * @type {number}
   * @memberof HistoryDataData
   */
  h?: number;
  /**
   * low price
   * @type {number}
   * @memberof HistoryDataData
   */
  l?: number;
  /**
   * volume
   * @type {number}
   * @memberof HistoryDataData
   */
  v?: number;
  /**
   * unix time stamp
   * @type {number}
   * @memberof HistoryDataData
   */
  t?: number;
}
/**
 *
 * @export
 * @interface HistoryResult
 */
export interface HistoryResult {
  /**
   *
   * @type {HistoryResultBars}
   * @memberof HistoryResult
   */
  bars?: HistoryResultBars;
}
/**
 *
 * @export
 * @interface HistoryResultBars
 */
export interface HistoryResultBars {
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  open?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  high?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  low?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  close?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  volume?: number;
  /**
   *
   * @type {string}
   * @memberof HistoryResultBars
   */
  time?: string;
  /**
   *
   * @type {string}
   * @memberof HistoryResultBars
   */
  endTime?: string;
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  weightedAvg?: number;
  /**
   *
   * @type {number}
   * @memberof HistoryResultBars
   */
  count?: number;
}
/**
 *
 * @export
 * @interface IbcustEntityInfoAddress
 */
export interface IbcustEntityInfoAddress {
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  street?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  street2?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  city?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  postalCode?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  country?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  countryCode?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoAddress
   */
  compact?: string;
}
/**
 *
 * @export
 * @interface IbcustEntityInfoEntities
 */
export interface IbcustEntityInfoEntities {
  /**
   *
   * @type {boolean}
   * @memberof IbcustEntityInfoEntities
   */
  canTrade?: boolean;
  /**
   *
   * @type {boolean}
   * @memberof IbcustEntityInfoEntities
   */
  canSign?: boolean;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoEntities
   */
  type?: string;
  /**
   *
   * @type {IbcustEntityInfoName}
   * @memberof IbcustEntityInfoEntities
   */
  name?: IbcustEntityInfoName;
  /**
   *
   * @type {IbcustEntityInfoAddress}
   * @memberof IbcustEntityInfoEntities
   */
  address?: IbcustEntityInfoAddress;
  /**
   *
   * @type {Array<object>}
   * @memberof IbcustEntityInfoEntities
   */
  identDocs?: Array<object>;
}
/**
 *
 * @export
 * @interface IbcustEntityInfoName
 */
export interface IbcustEntityInfoName {
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoName
   */
  salutation?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoName
   */
  firstName?: string;
  /**
   *
   * @type {string}
   * @memberof IbcustEntityInfoName
   */
  lastName?: string;
}
/**
 *
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
  /**
   *
   * @type {boolean}
   * @memberof InlineObject
   */
  enabled?: boolean;
}
/**
 *
 * @export
 * @interface InlineObject1
 */
export interface InlineObject1 {
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  devicename?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  deviceId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineObject1
   */
  uiName?: string;
  /**
   *
   * @type {boolean}
   * @memberof InlineObject1
   */
  enabled?: boolean;
}
/**
 *
 * @export
 * @interface InlineObject10
 */
export interface InlineObject10 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject10
   */
  acctIds?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject11
 */
export interface InlineObject11 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject11
   */
  acctIds?: Array<string>;
  /**
   * Frequency of cumulative performance data points: \'D\'aily, \'M\'onthly,\'Q\'uarterly.
   * @type {string}
   * @memberof InlineObject11
   */
  freq?: InlineObject11FreqEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineObject11FreqEnum {
  D = "D",
  M = "M",
  Q = "Q",
}

/**
 *
 * @export
 * @interface InlineObject12
 */
export interface InlineObject12 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject12
   */
  acctIds?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineObject13
 */
export interface InlineObject13 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject13
   */
  acctIds?: Array<string>;
  /**
   *
   * @type {Array<number>}
   * @memberof InlineObject13
   */
  conids?: Array<number>;
  /**
   * optional defaults to USD.
   * @type {string}
   * @memberof InlineObject13
   */
  currency?: string;
  /**
   * optional, default value is 90
   * @type {number}
   * @memberof InlineObject13
   */
  days?: number;
}
/**
 *
 * @export
 * @interface InlineObject2
 */
export interface InlineObject2 {
  /**
   *
   * @type {string}
   * @memberof InlineObject2
   */
  response?: string;
}
/**
 *
 * @export
 * @interface InlineObject3
 */
export interface InlineObject3 {
  /**
   * alert id(order id)
   * @type {number}
   * @memberof InlineObject3
   */
  alertId?: number;
  /**
   * 1 to activate, 0 to deactivate
   * @type {number}
   * @memberof InlineObject3
   */
  alertActive?: number;
}
/**
 *
 * @export
 * @interface InlineObject4
 */
export interface InlineObject4 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineObject4
   */
  filters?: Array<InlineObject4FiltersEnum>;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineObject4FiltersEnum {
  Inactive = "inactive",
  PendingSubmit = "pending_submit",
  PreSubmitted = "pre_submitted",
  Submitted = "submitted",
  Filled = "filled",
  PendingCancel = "pending_cancel",
  Cancelled = "cancelled",
  WarnState = "warn_state",
  SortByTime = "sort_by_time",
}

/**
 *
 * @export
 * @interface InlineObject5
 */
export interface InlineObject5 {
  /**
   * Notes for bracket orders: 1. Children orders will not have its own \"cOID\", so please donot pass \"cOID\" parameter in child order.Instead, they will have a \"parentId\" which must be equal to \"cOID\" of parent. 2. When you cancel a parent order, it will cancel all bracket orders, when you cancel one child order, it will also cancel its sibling order.
   * @type {Array<OrderRequest>}
   * @memberof InlineObject5
   */
  orders?: Array<OrderRequest>;
}
/**
 *
 * @export
 * @interface InlineObject6
 */
export interface InlineObject6 {
  /**
   * answer to question, true means yes, false means no
   * @type {boolean}
   * @memberof InlineObject6
   */
  confirmed?: boolean;
}
/**
 *
 * @export
 * @interface InlineObject7
 */
export interface InlineObject7 {
  /**
   * Notes for bracket orders: 1. Children orders will not have its own \"cOID\", so please donot pass \"cOID\" parameter in child order.Instead, they will have a \"parentId\" which must be equal to \"cOID\" of parent. 2. When you cancel a parent order, it will cancel all bracket orders, when you cancel one child order, it will also cancel its sibling order.
   * @type {Array<OrderRequest>}
   * @memberof InlineObject7
   */
  orders?: Array<OrderRequest>;
}
/**
 *
 * @export
 * @interface InlineObject8
 */
export interface InlineObject8 {
  /**
   * symbol or name to be searched
   * @type {string}
   * @memberof InlineObject8
   */
  symbol: string;
  /**
   * should be true if the search is to be performed by name. false by default.
   * @type {boolean}
   * @memberof InlineObject8
   */
  name?: boolean;
  /**
   * If search is done by name, only the assets provided in this field will be returned. Currently, only STK is supported.
   * @type {string}
   * @memberof InlineObject8
   */
  secType?: string;
}
/**
 *
 * @export
 * @interface InlineObject9
 */
export interface InlineObject9 {
  /**
   *
   * @type {Array<number>}
   * @memberof InlineObject9
   */
  conids?: Array<number>;
}
/**
 *
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
  /**
   * true means username is still logged in, false means it is not
   * @type {boolean}
   * @memberof InlineResponse200
   */
  confirmed?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
  /**
   * Challenge in hex format
   * @type {object}
   * @memberof InlineResponse2001
   */
  challenge?: object;
}
/**
 *
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
  /**
   *
   * @type {Array<OrderData>}
   * @memberof InlineResponse20010
   */
  orders?: Array<OrderData>;
}
/**
 *
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
  /**
   * Unique account id
   * @type {Array<string>}
   * @memberof InlineResponse20011
   */
  accounts?: Array<string>;
  /**
   * Account Id and its alias
   * @type {object}
   * @memberof InlineResponse20011
   */
  aliases?: object;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20011
   */
  selectedAccount?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20012
   */
  set?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20012
   */
  acctId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013
   */
  requestId?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20013
   */
  orderId?: number;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20013
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  text?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  orderStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20013
   */
  warningMessage?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20014
   */
  orderId?: number;
  /**
   * account id
   * @type {string}
   * @memberof InlineResponse20014
   */
  account?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20014
   */
  alertName?: string;
  /**
   * Value can only be 0 or 1, 1 means active
   * @type {number}
   * @memberof InlineResponse20014
   */
  alertActive?: number;
  /**
   * format, YYYYMMDD-HH:mm:ss, the time when you created the alert
   * @type {string}
   * @memberof InlineResponse20014
   */
  orderTime?: string;
  /**
   * whether the alert has been triggered or not
   * @type {boolean}
   * @memberof InlineResponse20014
   */
  alertTriggered?: boolean;
  /**
   * whether the alert can be repeatable or not, value can be 1 or 0. 1 means true
   * @type {number}
   * @memberof InlineResponse20014
   */
  alertRepeatable?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20015
   */
  requestId?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20015
   */
  orderId?: number;
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20015
   */
  success?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20015
   */
  text?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20015
   */
  orderStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20015
   */
  failureList?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
  /**
   *
   * @type {Array<InlineResponse20016Orders>}
   * @memberof InlineResponse20016
   */
  orders?: Array<InlineResponse20016Orders>;
  /**
   * If live order update is a snapshot
   * @type {boolean}
   * @memberof InlineResponse20016
   */
  snapshot?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20016Orders
 */
export interface InlineResponse20016Orders {
  /**
   * Account number
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  acct?: string;
  /**
   * conid and exchange. Format supports conid or conid@exchange
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  conidex?: string;
  /**
   * Contract identifier
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  conid?: number;
  /**
   * Order identifier
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  orderId?: string;
  /**
   * Cash currency
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  cashCcy?: string;
  /**
   * Quantity outstanding and total quantity concatenated with forward slash separator
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  sizeAndFills?: number;
  /**
   * Order description
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  orderDesc?: string;
  /**
   * Formatted ticker description
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  description1?: string;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  ticker?: string;
  /**
   * Asset class
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  secType?: string;
  /**
   * Listing Exchange
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  listingExchange?: string;
  /**
   * Quantity remaining
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  remainingQuantity?: number;
  /**
   * Quantity filled
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  filledQuantity?: number;
  /**
   * Company Name
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  companyName?: string;
  /**
   * Status of the order
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  status?: string;
  /**
   * Original order type
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  origOrderType?: string;
  /**
   * Supports Tax Optimization with 0 for no and 1 for yes
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  supportsTaxOpt?: number;
  /**
   * Last status update in format YYMMDDhhmms based in GMT
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  lastExecutionTime?: number;
  /**
   * Last status update unix time in ms
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  lastExecutionTimeR?: number;
  /**
   * Order type
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  orderType?: string;
  /**
   * Order reference
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  orderRef?: string;
  /**
   * The side of the market of the order.  * BUY: Buy contract near posted ask price  * SELL: Sell contract near posted bid price  * ASSN: Option Assignment, if BUYSELL=BUY and OptionType=PUT or BUYSELL=SELL and OptionType=CALL  * EXER: Option Exercise, if BUYSELL=SELL and OptionType=PUT or BUYSELL=BUY and OptionType=CALL
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  side?: InlineResponse20016OrdersSideEnum;
  /**
   * Time in force
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  timeInForce?: string;
  /**
   * Price of order
   * @type {number}
   * @memberof InlineResponse20016Orders
   */
  price?: number;
  /**
   * Background color in hex format
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  bgColor?: string;
  /**
   * Foreground color in hex format
   * @type {string}
   * @memberof InlineResponse20016Orders
   */
  fgColor?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum InlineResponse20016OrdersSideEnum {
  Buy = "BUY",
  Sell = "SELL",
  Assn = "ASSN",
  Exer = "EXER",
}

/**
 *
 * @export
 * @interface InlineResponse20017
 */
export interface InlineResponse20017 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20017
   */
  id?: string;
  /**
   * Please note here, if the message is a question, you have to reply to question in order to submit the order successfully. See more in the \"/iserver/reply/{replyid}\" endpoint.
   * @type {Array<string>}
   * @memberof InlineResponse20017
   */
  message?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20018
 */
export interface InlineResponse20018 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20018
   */
  orderId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20018
   */
  orderStatus?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20018
   */
  localOrderId?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20019
 */
export interface InlineResponse20019 {
  /**
   *
   * @type {InlineResponse20019Amount}
   * @memberof InlineResponse20019
   */
  amount?: InlineResponse20019Amount;
  /**
   *
   * @type {InlineResponse20019Equity}
   * @memberof InlineResponse20019
   */
  equity?: InlineResponse20019Equity;
  /**
   *
   * @type {InlineResponse20019Equity}
   * @memberof InlineResponse20019
   */
  initial?: InlineResponse20019Equity;
  /**
   *
   * @type {InlineResponse20019Equity}
   * @memberof InlineResponse20019
   */
  maintenance?: InlineResponse20019Equity;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019
   */
  warn?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019
   */
  error?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20019Amount
 */
export interface InlineResponse20019Amount {
  /**
   * for example 23,000 USD
   * @type {string}
   * @memberof InlineResponse20019Amount
   */
  amount?: string;
  /**
   * for example 1.1 ... 1.2 USD
   * @type {string}
   * @memberof InlineResponse20019Amount
   */
  commission?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Amount
   */
  total?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20019Equity
 */
export interface InlineResponse20019Equity {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Equity
   */
  current?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Equity
   */
  change?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20019Equity
   */
  after?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
  /**
   * unread number
   * @type {number}
   * @memberof InlineResponse2002
   */
  bN?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20020
 */
export interface InlineResponse20020 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20020
   */
  orderId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20020
   */
  localOrderId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20020
   */
  orderStatus?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20021
 */
export interface InlineResponse20021 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021
   */
  orderId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021
   */
  msg?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20021
   */
  conid?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20021
   */
  account?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20022
 */
export interface InlineResponse20022 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20022
   */
  serverId?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20022
   */
  conid?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20022
   */
  updated?: number;
  /**
   * Last Price - The last price at which the contract traded. \"C\" identifies this price as the previous day\'s closing price. \"H\" means that the trading is halted.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _31?: string;
  /**
   * Symbol
   * @type {string}
   * @memberof InlineResponse20022
   */
  _55?: string;
  /**
   * Text
   * @type {string}
   * @memberof InlineResponse20022
   */
  _58?: string;
  /**
   * High - Current day high price
   * @type {string}
   * @memberof InlineResponse20022
   */
  _70?: string;
  /**
   * Low - Current day low price
   * @type {string}
   * @memberof InlineResponse20022
   */
  _71?: string;
  /**
   * Position - The current aggregate position for the specified account or group.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _72?: string;
  /**
   * Market Value - The current market value of  your position in the security. Market Value is calculated with realtime market data (even when not subscribed to market data).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _73?: string;
  /**
   * Avg Price - The average price of the position.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _74?: string;
  /**
   * Unrealized PnL - Unrealized profit or loss. Unrealized PnL is calculated with realtime market data (even when not subscribed to market data).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _75?: string;
  /**
   * Formatted position
   * @type {string}
   * @memberof InlineResponse20022
   */
  _76?: string;
  /**
   * Formatted Unrealized PnL
   * @type {string}
   * @memberof InlineResponse20022
   */
  _77?: string;
  /**
   * Daily PnL - Your profit or loss of the day since prior close. Daily PnL is calculated with realtime market data (even when not subscribed to market data).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _78?: string;
  /**
   * Change - The difference between the last price and the close on the previous trading day
   * @type {string}
   * @memberof InlineResponse20022
   */
  _82?: string;
  /**
   * Change % - The difference between the last price and the close on the previous trading day in percentage.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _83?: string;
  /**
   * Bid Price - The highest-priced bid on the contract.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _84?: string;
  /**
   * Ask Size - The number of contracts or shares offered at the ask price. For US stocks, the number displayed is divided by 100.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _85?: string;
  /**
   * Ask Price - The lowest-priced offer on the contract.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _86?: string;
  /**
   * Volume - Volume for the day, formatted with \'K\' for thousands or \'M\' for millions. For higher precision volume refer to field 7762.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _87?: string;
  /**
   * Raw Volume - Volume for the day, provided in long form without formatted with K/M. This field value is deprecated, for high precision volume refer to field 7762.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _87rawDeprecated?: string;
  /**
   * Bid Size - The number of contracts or shares bid for at the bid price. For US stocks, the number displayed is divided by 100.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _88?: string;
  /**
   * Exchange
   * @type {string}
   * @memberof InlineResponse20022
   */
  _6004?: string;
  /**
   * Conid - Contract identifier from IBKR\'s database.
   * @type {number}
   * @memberof InlineResponse20022
   */
  _6008?: number;
  /**
   * SecType - The asset class of the instrument.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _6070?: string;
  /**
   * Months
   * @type {string}
   * @memberof InlineResponse20022
   */
  _6072?: string;
  /**
   * Regular Expiry
   * @type {string}
   * @memberof InlineResponse20022
   */
  _6073?: string;
  /**
   * Marker for market data delivery method (similar to request id)
   * @type {string}
   * @memberof InlineResponse20022
   */
  _6119?: string;
  /**
   * Underlying Conid. Use /trsrv/secdef to get more information about the security
   * @type {number}
   * @memberof InlineResponse20022
   */
  _6457?: number;
  /**
   * Market Data Availability. The field may contain two chars. The first char is the primary code: R = Realtime, D = Delayed, Z = Frozen, Y = Frozen Delayed. The second char is the secondary code: P = Snapshot Available, p = Consolidated. The third char defines: B = Book
   * @type {string}
   * @memberof InlineResponse20022
   */
  _6509?: string;
  /**
   * Company name
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7051?: string;
  /**
   * Ask Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7057?: string;
  /**
   * Last Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7058?: string;
  /**
   * Last Size - The number of unites traded at the last price
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7059?: string;
  /**
   * Bid Exch - Displays the exchange(s) offering the SMART price. A=AMEX, C=CBOE, I=ISE, X=PHLX, N=PSE, B=BOX, Q=NASDAQOM, Z=BATS, W=CBOE2, T=NASDAQBX, M=MIAX, H=GEMINI, E=EDGX, J=MERCURY
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7068?: string;
  /**
   * Implied Vol./Hist. Vol % - The ratio of the implied volatility over the historical volatility, expressed as a percentage.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7084?: string;
  /**
   * Put/Call Interest - Put option open interest/call option open interest for the trading day.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7085?: string;
  /**
   * Put/Call Volume - Put option volume/call option volume for the trading day.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7086?: string;
  /**
   * Hist. Vol. % - 30-day real-time historical volatility.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7087?: string;
  /**
   * Hist. Vol. Close % - Shows the historical volatility based on previous close price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7088?: string;
  /**
   * Opt. Volume - Option Volume
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7089?: string;
  /**
   * Conid + Exchange
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7094?: string;
  /**
   * canBeTraded - If contract is a trade-able instrument. Returns 1(true) or 0(false).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7184?: string;
  /**
   * Contract Description
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7219?: string;
  /**
   * Contract Description
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7220?: string;
  /**
   * Listing Exchange
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7221?: string;
  /**
   * Industry - Displays the type of industry under which the underlying company can be categorized.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7280?: string;
  /**
   * Category - Displays a more detailed level of description within the industry under which the underlying company can be categorized.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7281?: string;
  /**
   * Average Volume - The average daily trading volume over 90 days.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7282?: string;
  /**
   * Option Implied Vol. % - A prediction of how volatile an underlying will be in the future. At the market volatility estimated for a maturity thirty calendar days forward of the current trading day, and based on option prices from two consecutive expiration months. To query the Implied Vol. % of a specific strike refer to field 7633.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7283?: string;
  /**
   * Historic Volume (30d)
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7284?: string;
  /**
   * Put/Call Ratio
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7285?: string;
  /**
   * Dividend Amount - Displays the amount of the next dividend.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7286?: string;
  /**
   * Dividend Yield % - This value is the toal of the expected dividend payments over the next twelve months per share divided by the Current Price and is expressed as a percentage. For derivatives, this displays the total of the expected dividend payments over the expiry date.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7287?: string;
  /**
   * Ex-date of the dividend
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7288?: string;
  /**
   * Market Cap
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7289?: string;
  /**
   * P/E
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7290?: string;
  /**
   * EPS
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7291?: string;
  /**
   * Cost Basis - Your current position in this security multiplied by the average price and multiplier.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7292?: string;
  /**
   * 52 Week High - The highest price for the past 52 weeks.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7293?: string;
  /**
   * 52 Week Low - The lowest price for the past 52 weeks.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7294?: string;
  /**
   * Open - Today\'s opening price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7295?: string;
  /**
   * Close - Today\'s closing price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7296?: string;
  /**
   * Delta - The ratio of the change in the price of the option to the corresponding change in the price of the underlying.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7308?: string;
  /**
   * Gamma - The rate of change for the delta with respect to the underlying asset\'s price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7309?: string;
  /**
   * Theta - A measure of the rate of decline the value of an option due to the passage of time.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7310?: string;
  /**
   * Vega - The amount that the price of an option changes compared to a 1% change in the volatility.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7311?: string;
  /**
   * Opt. Volume Change % - Today\'s option volume as a percentage of the average option volume.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7607?: string;
  /**
   * Implied Vol. % - The implied volatility for the specific strike of the option in percentage. To query the Option Implied Vol. % from the underlying refer to field 7283.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7633?: string;
  /**
   * Mark - The mark price is, the ask price if ask is less than last price, the bid price if bid is more than the last price, otherwise it\'s equal to last price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7635?: string;
  /**
   * Shortable Shares - Number of shares available for shorting.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7636?: string;
  /**
   * Fee Rate - Interest rate charged on borrowed shares.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7637?: string;
  /**
   * Option Open Interest
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7638?: string;
  /**
   * % of Mark Value - Displays the market value of the contract as a percentage of the total market value of the account. Daily PnL is calculated with realtime market data (even when not subscribed to market data).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7639?: string;
  /**
   * Shortable - Describes the level of difficulty with which the security can be sold short.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7644?: string;
  /**
   * Morningstar Rating - Displays Morningstar Rating provided value. Requires [Morningstar](https://www.interactivebrokers.com/en/index.php?f=14262) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7655?: string;
  /**
   * Dividends - This value is the total of the expected dividend payments over the next twelve months per share.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7671?: string;
  /**
   * Dividends TTM - This value is the total of the expected dividend payments over the last twelve months per share.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7672?: string;
  /**
   * EMA(200) - Exponential moving average (N=200).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7674?: string;
  /**
   * EMA(100) - Exponential moving average (N=100).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7675?: string;
  /**
   * EMA(50) - Exponential moving average (N=50).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7676?: string;
  /**
   * EMA(20) - Exponential moving average (N=20).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7677?: string;
  /**
   * Price/EMA(200) - Price to Exponential moving average (N=200) ratio -1, displayed in percents.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7678?: string;
  /**
   * Price/EMA(100) - Price to Exponential moving average (N=100) ratio -1, displayed in percents.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7679?: string;
  /**
   * Price/EMA(50) - Price to Exponential moving average (N=50) ratio -1, displayed in percents.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7680?: string;
  /**
   * Price/EMA(20) - Price to Exponential moving average (N=20) ratio -1, displayed in percents.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7681?: string;
  /**
   * Change Since Open - The difference between the last price and the open price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7682?: string;
  /**
   * Upcoming Event - Shows the next major company event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7683?: string;
  /**
   * Upcoming Event Date - The date of the next major company event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7684?: string;
  /**
   * Upcoming Analyst Meeting - The date and time of the next scheduled analyst meeting. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7685?: string;
  /**
   * Upcoming Earnings - The date and time of the next scheduled earnings/earnings call event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7686?: string;
  /**
   * Upcoming Misc Event - The date and time of the next shareholder meeting, presentation or other event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7687?: string;
  /**
   * Recent Analyst Meeting - The date and time of the most recent analyst meeting. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7688?: string;
  /**
   * Recent Earnings - The date and time of the most recent earnings/earning call event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7689?: string;
  /**
   * Recent Misc Event - The date and time of the most recent shareholder meeting, presentation or other event. Requires [Wall Street Horizon](https://www.interactivebrokers.com/en/index.php?f=24674) subscription.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7690?: string;
  /**
   * Probability of Max Return - Customer implied probability of maximum potential gain.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7694?: string;
  /**
   * Break Even - Break even points
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7695?: string;
  /**
   * SPX Delta - Beta Weighted Delta is calculated using the formula; Delta x dollar adjusted beta, where adjusted beta is adjusted by the ratio of the close price.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7696?: string;
  /**
   * Futures Open Interest - Total number of outstanding futures contracts
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7697?: string;
  /**
   * Last Yield - Implied yield of the bond if it is purchased at the current last price. Last yield is calculated using the Last price on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7698?: string;
  /**
   * Bid Yield - Implied yield of the bond if it is purchased at the current bid price. Bid yield is calculated using the Ask on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7699?: string;
  /**
   * Probability of Max Return - Customer implied probability of maximum potential gain.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7700?: string;
  /**
   * Probability of Max Loss - Customer implied probability of maximum potential loss.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7702?: string;
  /**
   * Profit Probability - Customer implied probability of any gain.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7703?: string;
  /**
   * Organization Type
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7704?: string;
  /**
   * Debt Class
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7705?: string;
  /**
   * Ratings - Ratings issued for bond contract.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7706?: string;
  /**
   * Bond State Code
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7707?: string;
  /**
   * Bond Type
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7708?: string;
  /**
   * Last Trading Date
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7714?: string;
  /**
   * Issue Date
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7715?: string;
  /**
   * Beta - Beta is against standard index.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7718?: string;
  /**
   * Ask Yield - Implied yield of the bond if it is purchased at the current offer. Ask yield is calculated using the Bid on all possible call dates. It is assumed that prepayment occurs if the bond has call or put provisions and the issuer can offer a lower coupon rate based on current market rates. The yield to worst will be the lowest of the yield to maturity or yield to call (if the bond has prepayment provisions). Yield to worse may be the same as yield to maturity but never higher.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7720?: string;
  /**
   * Prior Close - Yesterday\'s closing price
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7741?: string;
  /**
   * Volume Long - High precision volume for the day. For formatted volume refer to field 87.
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7762?: string;
  /**
   * hasTradingPermissions - if user has trading permissions for specified contract. Returns 1(true) or 0(false).
   * @type {string}
   * @memberof InlineResponse20022
   */
  _7768?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20023
 */
export interface InlineResponse20023 {
  /**
   * success means market data was cancelled.
   * @type {string}
   * @memberof InlineResponse20023
   */
  confirmed?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20024
 */
export interface InlineResponse20024 {
  /**
   * true means market data is cancelled, false means it is not.
   * @type {boolean}
   * @memberof InlineResponse20024
   */
  confirmed?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20025
 */
export interface InlineResponse20025 {
  /**
   * Contract Identifier
   * @type {number}
   * @memberof InlineResponse20025
   */
  conid?: number;
  /**
   * Company Name - Exchange
   * @type {string}
   * @memberof InlineResponse20025
   */
  companyHeader?: string;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof InlineResponse20025
   */
  symbol?: string;
  /**
   * Exchange
   * @type {string}
   * @memberof InlineResponse20025
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20025
   */
  restricted?: string;
  /**
   * List of Future Option expirations in YYYMMDD format separated by semicolon
   * @type {string}
   * @memberof InlineResponse20025
   */
  fop?: string;
  /**
   * List of Option expirations in YYYYMMDD format separated by semicolon
   * @type {string}
   * @memberof InlineResponse20025
   */
  opt?: string;
  /**
   * List of Warrant expirations in YYYYMMDD format separated by semicolon
   * @type {string}
   * @memberof InlineResponse20025
   */
  war?: string;
  /**
   *
   * @type {Array<IserverSecdefSearchSections>}
   * @memberof InlineResponse20025
   */
  sections?: Array<IserverSecdefSearchSections>;
}
/**
 *
 * @export
 * @interface InlineResponse20026
 */
export interface InlineResponse20026 {
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20026
   */
  call?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20026
   */
  put?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20027
 */
export interface InlineResponse20027 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20027
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20027
   */
  description?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20027
   */
  id?: string;
  /**
   *
   * @type {Array<IserverContractConidAlgosParameters>}
   * @memberof InlineResponse20027
   */
  parameters?: Array<IserverContractConidAlgosParameters>;
}
/**
 *
 * @export
 * @interface InlineResponse20028
 */
export interface InlineResponse20028 {
  /**
   * Classification of Financial Instrument codes
   * @type {string}
   * @memberof InlineResponse20028
   */
  cfiCode?: string;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof InlineResponse20028
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20028
   */
  cusip?: string;
  /**
   * Expiration Date in the format YYYYMMDD
   * @type {number}
   * @memberof InlineResponse20028
   */
  expiryFull?: number;
  /**
   * IBKRs contract identifier
   * @type {number}
   * @memberof InlineResponse20028
   */
  conId?: number;
  /**
   * Date on which the underlying transaction settles if the option is exercised
   * @type {number}
   * @memberof InlineResponse20028
   */
  maturityDate?: number;
  /**
   * Specific group of companies or businesses.
   * @type {string}
   * @memberof InlineResponse20028
   */
  industry?: string;
  /**
   * Asset Class of the contract
   * @type {string}
   * @memberof InlineResponse20028
   */
  instrumentType?: string;
  /**
   * Designation of the contract
   * @type {string}
   * @memberof InlineResponse20028
   */
  tradingClass?: string;
  /**
   * Comma separated list of exchanges or trading venues
   * @type {string}
   * @memberof InlineResponse20028
   */
  validExchanges?: string;
  /**
   * Allowed to sell shares that you own
   * @type {boolean}
   * @memberof InlineResponse20028
   */
  allowSellLong?: boolean;
  /**
   * Supports zero commission trades
   * @type {boolean}
   * @memberof InlineResponse20028
   */
  isZeroCommissionSecurity?: boolean;
  /**
   * Contracts symbol from primary exchange. For options it is the OCC symbol.
   * @type {string}
   * @memberof InlineResponse20028
   */
  localSymbol?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20028
   */
  classifier?: string;
  /**
   * Currency contract trades in
   * @type {string}
   * @memberof InlineResponse20028
   */
  currency?: string;
  /**
   * Formatted contract parameters
   * @type {string}
   * @memberof InlineResponse20028
   */
  text?: string;
  /**
   * IBKRs contract identifier for the underlying instrument
   * @type {number}
   * @memberof InlineResponse20028
   */
  underlyingConId?: number;
  /**
   * Provides trading outside of Regular Trading Hours
   * @type {boolean}
   * @memberof InlineResponse20028
   */
  rTH?: boolean;
  /**
   * numerical value of each point of price movement
   * @type {string}
   * @memberof InlineResponse20028
   */
  multiplier?: string;
  /**
   * fixed price at which the owner of the option buys or sells the underlying
   * @type {string}
   * @memberof InlineResponse20028
   */
  strike?: string;
  /**
   * Put or Call of the option
   * @type {string}
   * @memberof InlineResponse20028
   */
  right?: string;
  /**
   * Legal entity for underlying contract
   * @type {string}
   * @memberof InlineResponse20028
   */
  underlyingIssuer?: string;
  /**
   * Month the contract must be satisfied by making or accepting delivery
   * @type {string}
   * @memberof InlineResponse20028
   */
  contractMonth?: string;
  /**
   * Contracts company name
   * @type {string}
   * @memberof InlineResponse20028
   */
  companyName?: string;
  /**
   * Support IBKRs SMART routing
   * @type {boolean}
   * @memberof InlineResponse20028
   */
  smartAvailable?: boolean;
  /**
   * Primary Exchange, Routing or Trading Venue
   * @type {string}
   * @memberof InlineResponse20028
   */
  exchange?: string;
  /**
   *
   * @type {Array<InlineResponse20028Rules>}
   * @memberof InlineResponse20028
   */
  rules?: Array<InlineResponse20028Rules>;
}
/**
 *
 * @export
 * @interface InlineResponse20028CqtTypes
 */
export interface InlineResponse20028CqtTypes {
  /**
   * order types that support cqt trades
   * @type {string}
   * @memberof InlineResponse20028CqtTypes
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20028FraqTypes
 */
export interface InlineResponse20028FraqTypes {
  /**
   * order types that support fractional trades
   * @type {string}
   * @memberof InlineResponse20028FraqTypes
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20028IbalgoTypes
 */
export interface InlineResponse20028IbalgoTypes {
  /**
   * order types that support IB Algos
   * @type {string}
   * @memberof InlineResponse20028IbalgoTypes
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20028OrderDefaults
 */
export interface InlineResponse20028OrderDefaults {
  /**
   * orderType
   * @type {Array<InlineResponse20028String>}
   * @memberof InlineResponse20028OrderDefaults
   */
  string?: Array<InlineResponse20028String>;
}
/**
 *
 * @export
 * @interface InlineResponse20028OrderTypes
 */
export interface InlineResponse20028OrderTypes {
  /**
   * list of available order types
   * @type {string}
   * @memberof InlineResponse20028OrderTypes
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20028OrderTypesOutside
 */
export interface InlineResponse20028OrderTypesOutside {
  /**
   * order types that support outside of regular trading hours
   * @type {string}
   * @memberof InlineResponse20028OrderTypesOutside
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20028Rules
 */
export interface InlineResponse20028Rules {
  /**
   *
   * @type {boolean}
   * @memberof InlineResponse20028Rules
   */
  algoEligible?: boolean;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20028Rules
   */
  error?: string;
  /**
   *
   * @type {Array<InlineResponse20028OrderTypes>}
   * @memberof InlineResponse20028Rules
   */
  orderTypes?: Array<InlineResponse20028OrderTypes>;
  /**
   *
   * @type {Array<InlineResponse20028IbalgoTypes>}
   * @memberof InlineResponse20028Rules
   */
  ibalgoTypes?: Array<InlineResponse20028IbalgoTypes>;
  /**
   *
   * @type {Array<InlineResponse20028FraqTypes>}
   * @memberof InlineResponse20028Rules
   */
  fraqTypes?: Array<InlineResponse20028FraqTypes>;
  /**
   *
   * @type {Array<InlineResponse20028CqtTypes>}
   * @memberof InlineResponse20028Rules
   */
  cqtTypes?: Array<InlineResponse20028CqtTypes>;
  /**
   * If object returned will provide the defaults based on user settings
   * @type {Array<InlineResponse20028OrderDefaults>}
   * @memberof InlineResponse20028Rules
   */
  orderDefaults?: Array<InlineResponse20028OrderDefaults>;
  /**
   *
   * @type {Array<InlineResponse20028OrderTypesOutside>}
   * @memberof InlineResponse20028Rules
   */
  orderTypesOutside?: Array<InlineResponse20028OrderTypesOutside>;
  /**
   * Default quantity
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  defaultSize?: number;
  /**
   * cash value
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  cashSize?: number;
  /**
   * increment quantity value
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  sizeIncrement?: number;
  /**
   *
   * @type {Array<InlineResponse20028TifTypes>}
   * @memberof InlineResponse20028Rules
   */
  tifTypes?: Array<InlineResponse20028TifTypes>;
  /**
   * Default time in force value
   * @type {string}
   * @memberof InlineResponse20028Rules
   */
  defaultTIF?: string;
  /**
   * Limit price
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  limitPrice?: number;
  /**
   * Stop price
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  stopprice?: number;
  /**
   * Order origin designation for US securities options and Options Clearing Corporation
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  orderOrigination?: number;
  /**
   * order preview required
   * @type {boolean}
   * @memberof InlineResponse20028Rules
   */
  preview?: boolean;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  displaySize?: number;
  /**
   * decimal places for fractional order size
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  fraqInt?: number;
  /**
   * Cash currency for the contract
   * @type {string}
   * @memberof InlineResponse20028Rules
   */
  cashCcy?: string;
  /**
   * Increment value for cash quantity
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  cashQtyIncr?: number;
  /**
   * Price Magnifier
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  priceMagnifier?: number;
  /**
   * trading negative price support
   * @type {boolean}
   * @memberof InlineResponse20028Rules
   */
  negativeCapable?: boolean;
  /**
   * Price increment value
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  increment?: number;
  /**
   * Number of digits for price increment
   * @type {number}
   * @memberof InlineResponse20028Rules
   */
  incrementDigits?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20028String
 */
export interface InlineResponse20028String {
  /**
   * Outside of Regular Trading Hours
   * @type {boolean}
   * @memberof InlineResponse20028String
   */
  oRTH?: boolean;
  /**
   * Stop Price value
   * @type {string}
   * @memberof InlineResponse20028String
   */
  sP?: string;
  /**
   * Limit Price value
   * @type {string}
   * @memberof InlineResponse20028String
   */
  lP?: string;
  /**
   * Price Cap value
   * @type {string}
   * @memberof InlineResponse20028String
   */
  pC?: string;
  /**
   * Trailing amount value
   * @type {string}
   * @memberof InlineResponse20028String
   */
  tA?: string;
  /**
   * Trailing unit
   * @type {string}
   * @memberof InlineResponse20028String
   */
  tU?: string;
  /**
   * Releative offset amount
   * @type {string}
   * @memberof InlineResponse20028String
   */
  rOA?: string;
  /**
   * Relative offset percent
   * @type {string}
   * @memberof InlineResponse20028String
   */
  rOP?: string;
  /**
   * Touch trigger price
   * @type {string}
   * @memberof InlineResponse20028String
   */
  tT?: string;
  /**
   * Use Net Price for Bonds
   * @type {boolean}
   * @memberof InlineResponse20028String
   */
  uNP?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse20028TifTypes
 */
export interface InlineResponse20028TifTypes {
  /**
   * Time in Force values, formatted with o for supporting Outside regular trading hours and a for Algo trading
   * @type {string}
   * @memberof InlineResponse20028TifTypes
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029
 */
export interface InlineResponse20029 {
  /**
   *
   * @type {Array<InlineResponse20029ScanTypeList>}
   * @memberof InlineResponse20029
   */
  scanTypeList?: Array<InlineResponse20029ScanTypeList>;
  /**
   *
   * @type {Array<InlineResponse20029InstrumentList>}
   * @memberof InlineResponse20029
   */
  instrumentList?: Array<InlineResponse20029InstrumentList>;
  /**
   *
   * @type {Array<InlineResponse20029FilterList>}
   * @memberof InlineResponse20029
   */
  filterList?: Array<InlineResponse20029FilterList>;
  /**
   *
   * @type {Array<InlineResponse20029LocationTree>}
   * @memberof InlineResponse20029
   */
  locationTree?: Array<InlineResponse20029LocationTree>;
}
/**
 *
 * @export
 * @interface InlineResponse20029FilterList
 */
export interface InlineResponse20029FilterList {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029FilterList
   */
  group?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029FilterList
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029FilterList
   */
  code?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029FilterList
   */
  type?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029InstrumentList
 */
export interface InlineResponse20029InstrumentList {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029InstrumentList
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029InstrumentList
   */
  type?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20029InstrumentList
   */
  filters?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse20029LocationTree
 */
export interface InlineResponse20029LocationTree {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029LocationTree
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029LocationTree
   */
  type?: string;
  /**
   *
   * @type {Array<InlineResponse20029Locations>}
   * @memberof InlineResponse20029LocationTree
   */
  locations?: Array<InlineResponse20029Locations>;
}
/**
 *
 * @export
 * @interface InlineResponse20029Locations
 */
export interface InlineResponse20029Locations {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029Locations
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029Locations
   */
  type?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20029ScanTypeList
 */
export interface InlineResponse20029ScanTypeList {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029ScanTypeList
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20029ScanTypeList
   */
  code?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof InlineResponse20029ScanTypeList
   */
  instruments?: Array<string>;
}
/**
 *
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
  /**
   * optional, if A doesn\'t exist, it means user can\'t toggle this option. 0-off, 1-on.
   * @type {number}
   * @memberof InlineResponse2003
   */
  a?: number;
  /**
   * fyi code
   * @type {string}
   * @memberof InlineResponse2003
   */
  fC?: string;
  /**
   * disclaimer read, 1 = yes, = 0 no.
   * @type {number}
   * @memberof InlineResponse2003
   */
  h?: number;
  /**
   * detailed description
   * @type {string}
   * @memberof InlineResponse2003
   */
  fD?: string;
  /**
   * title
   * @type {string}
   * @memberof InlineResponse2003
   */
  fN?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20030
 */
export interface InlineResponse20030 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse20030
   */
  serverId?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20030
   */
  columnName?: string;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof InlineResponse20030
   */
  symbol?: string;
  /**
   * conid and exchange. Format supports conid or conid@exchange
   * @type {string}
   * @memberof InlineResponse20030
   */
  conidex?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20030
   */
  conId?: number;
  /**
   * List of available chart periods
   * @type {string}
   * @memberof InlineResponse20030
   */
  availableChartPeriods?: string;
  /**
   * Contracts company name
   * @type {string}
   * @memberof InlineResponse20030
   */
  companyName?: string;
  /**
   * Format contract name
   * @type {string}
   * @memberof InlineResponse20030
   */
  contractDescription1?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20030
   */
  listingExchange?: string;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20030
   */
  secType?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20031
 */
export interface InlineResponse20031 {
  /**
   *
   * @type {object}
   * @memberof InlineResponse20031
   */
  acctId?: object;
}
/**
 *
 * @export
 * @interface InlineResponse20032
 */
export interface InlineResponse20032 {
  /**
   * Exchange parameter id
   * @type {string}
   * @memberof InlineResponse20032
   */
  id?: string;
  /**
   * Reference on a trade venue of given exchange parameter
   * @type {string}
   * @memberof InlineResponse20032
   */
  tradeVenueId?: string;
  /**
   * Always contains at least one \'tradingTime\'  and zero or more \'sessionTime\' tags
   * @type {Array<InlineResponse20032Schedules>}
   * @memberof InlineResponse20032
   */
  schedules?: Array<InlineResponse20032Schedules>;
}
/**
 *
 * @export
 * @interface InlineResponse20032Schedules
 */
export interface InlineResponse20032Schedules {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20032Schedules
   */
  clearingCycleEndTime?: number;
  /**
   * 20000101 stands for any Sat, 20000102 stands for any Sun, ... 20000107 stands for any Fri. Any other date stands for itself.
   * @type {number}
   * @memberof InlineResponse20032Schedules
   */
  tradingScheduleDate?: number;
  /**
   *
   * @type {InlineResponse20032Sessions}
   * @memberof InlineResponse20032Schedules
   */
  sessions?: InlineResponse20032Sessions;
  /**
   *
   * @type {InlineResponse20032TradingTimes}
   * @memberof InlineResponse20032Schedules
   */
  tradingTimes?: InlineResponse20032TradingTimes;
}
/**
 * If the LIQUID hours differs from the total trading day then a separate \'session\' tag is returned.
 * @export
 * @interface InlineResponse20032Sessions
 */
export interface InlineResponse20032Sessions {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20032Sessions
   */
  openingTime?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20032Sessions
   */
  closingTime?: number;
  /**
   * If the whole trading day is considered LIQUID then the value \'LIQUID\' is returned.
   * @type {string}
   * @memberof InlineResponse20032Sessions
   */
  prop?: string;
}
/**
 * Returns tradingTime in exchange time zone.
 * @export
 * @interface InlineResponse20032TradingTimes
 */
export interface InlineResponse20032TradingTimes {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20032TradingTimes
   */
  openingTime?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse20032TradingTimes
   */
  closingTime?: number;
  /**
   *
   * @type {string}
   * @memberof InlineResponse20032TradingTimes
   */
  cancelDayOrders?: string;
}
/**
 *
 * @export
 * @interface InlineResponse20033
 */
export interface InlineResponse20033 {
  /**
   *
   * @type {Array<object>}
   * @memberof InlineResponse20033
   */
  symbol?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse20034
 */
export interface InlineResponse20034 {
  /**
   * This is an array of object(s), there could be multiple results under same symbol
   * @type {Array<object>}
   * @memberof InlineResponse20034
   */
  symbol?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse20035
 */
export interface InlineResponse20035 {
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accountready?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accounttype?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accruedcash?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accruedcashC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accruedcashF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accruedcashS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accrueddividend?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accrueddividendC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accrueddividendF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  accrueddividendS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  availablefunds?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  availablefundsC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  availablefundsF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  availablefundsS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  billable?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  billableC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  billableF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  billableS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  buyingpower?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  cushion?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  daytradesremaining?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  daytradesremainingt1?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  daytradesremainingt2?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  daytradesremainingt3?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  daytradesremainingt4?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  equitywithloanvalue?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  equitywithloanvalueC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  equitywithloanvalueF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  equitywithloanvalueS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  excessliquidity?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  excessliquidityC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  excessliquidityF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  excessliquidityS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullavailablefunds?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullavailablefundsC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullavailablefundsF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullavailablefundsS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullexcessliquidity?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullexcessliquidityC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullexcessliquidityF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullexcessliquidityS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullinitmarginreq?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullinitmarginreqC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullinitmarginreqF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullinitmarginreqS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullmaintmarginreq?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullmaintmarginreqC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullmaintmarginreqF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  fullmaintmarginreqS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  grosspositionvalue?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  grosspositionvalueC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  grosspositionvalueF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  grosspositionvalueS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  guarantee?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  guaranteeC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  guaranteeF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  guaranteeS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  highestseverity?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  highestseverityC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  highestseverityF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  highestseverityS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  indianstockhaircut?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  indianstockhaircutC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  indianstockhaircutF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  indianstockhaircutS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  initmarginreq?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  initmarginreqC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  initmarginreqF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  initmarginreqS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  leverage?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  leverageC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  leverageF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  leverageS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadavailablefunds?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadavailablefundsC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadavailablefundsF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadavailablefundsS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadexcessliquidity?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadexcessliquidityC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadexcessliquidityF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadexcessliquidityS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadinitmarginreq?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadinitmarginreqC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadinitmarginreqF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadinitmarginreqS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadmaintmarginreq?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadmaintmarginreqC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadmaintmarginreqF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadmaintmarginreqS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  lookaheadnextchange?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  maintmarginreq?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  maintmarginreqC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  maintmarginreqF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  maintmarginreqS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  netliquidation?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  netliquidationC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  netliquidationF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  netliquidationS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  netliquidationuncertainty?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  nlvandmargininreview?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  pasharesvalue?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  pasharesvalueC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  pasharesvalueF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  pasharesvalueS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationexcess?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationexcessC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationexcessF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationexcessS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationmargin?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationmarginC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationmarginF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  postexpirationmarginS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  previousdayequitywithloanvalue?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  previousdayequitywithloanvalueC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  previousdayequitywithloanvalueF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  previousdayequitywithloanvalueS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  segmenttitleC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  segmenttitleF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  segmenttitleS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totalcashvalue?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totalcashvalueC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totalcashvalueF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totalcashvalueS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totaldebitcardpendingcharges?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totaldebitcardpendingchargesC?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totaldebitcardpendingchargesF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  totaldebitcardpendingchargesS?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  tradingtypeF?: Summary;
  /**
   *
   * @type {Summary}
   * @memberof InlineResponse20035
   */
  tradingtypeS?: Summary;
}
/**
 *
 * @export
 * @interface InlineResponse20036
 */
export interface InlineResponse20036 {
  /**
   *
   * @type {Ledger}
   * @memberof InlineResponse20036
   */
  bASE?: Ledger;
}
/**
 *
 * @export
 * @interface InlineResponse20037
 */
export interface InlineResponse20037 {
  /**
   *
   * @type {Array<object>}
   * @memberof InlineResponse20037
   */
  aCCTID?: Array<object>;
}
/**
 *
 * @export
 * @interface InlineResponse20038
 */
export interface InlineResponse20038 {
  /**
   * 1 for Live, 2 for Paper
   * @type {number}
   * @memberof InlineResponse20038
   */
  lOGINTYPE?: number;
  /**
   * Username
   * @type {string}
   * @memberof InlineResponse20038
   */
  uSERNAME?: string;
  /**
   * User ID
   * @type {number}
   * @memberof InlineResponse20038
   */
  uSERID?: number;
  /**
   * Time in milliseconds until session expires. Caller needs to call the again to re-validate session
   * @type {number}
   * @memberof InlineResponse20038
   */
  expire?: number;
  /**
   * true if session was validated; false if not.
   * @type {boolean}
   * @memberof InlineResponse20038
   */
  rESULT?: boolean;
  /**
   * Time of session validation
   * @type {number}
   * @memberof InlineResponse20038
   */
  aUTHTIME?: number;
}
/**
 *
 * @export
 * @interface InlineResponse20039
 */
export interface InlineResponse20039 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse20039
   */
  applicantId?: number;
  /**
   *
   * @type {Array<IbcustEntityInfoEntities>}
   * @memberof InlineResponse20039
   */
  entities?: Array<IbcustEntityInfoEntities>;
}
/**
 *
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
  /**
   * disclaimer message
   * @type {string}
   * @memberof InlineResponse2004
   */
  dT?: string;
  /**
   * fyi code
   * @type {string}
   * @memberof InlineResponse2004
   */
  fC?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
  /**
   *
   * @type {number}
   * @memberof InlineResponse2005
   */
  t?: number;
  /**
   *
   * @type {number}
   * @memberof InlineResponse2005
   */
  v?: number;
}
/**
 *
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
  /**
   * Email option is enabled or not 0-off, 1-on.
   * @type {number}
   * @memberof InlineResponse2006
   */
  m?: number;
  /**
   *
   * @type {Array<InlineResponse2006E>}
   * @memberof InlineResponse2006
   */
  e?: Array<InlineResponse2006E>;
}
/**
 * device
 * @export
 * @interface InlineResponse2006E
 */
export interface InlineResponse2006E {
  /**
   * device name
   * @type {string}
   * @memberof InlineResponse2006E
   */
  nM?: string;
  /**
   * device id
   * @type {string}
   * @memberof InlineResponse2006E
   */
  i?: string;
  /**
   * unique device id
   * @type {string}
   * @memberof InlineResponse2006E
   */
  uI?: string;
  /**
   * device is enabled or not 0-true, 1-false.
   * @type {string}
   * @memberof InlineResponse2006E
   */
  a?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
  /**
   * If sso authentication completed
   * @type {boolean}
   * @memberof InlineResponse2007
   */
  passed?: boolean;
  /**
   * If connection is authenticated
   * @type {boolean}
   * @memberof InlineResponse2007
   */
  authenticated?: boolean;
  /**
   * Connected to CCP session
   * @type {boolean}
   * @memberof InlineResponse2007
   */
  connected?: boolean;
  /**
   * If user already has an existing brokerage session running.
   * @type {boolean}
   * @memberof InlineResponse2007
   */
  competing?: boolean;
}
/**
 *
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
  /**
   * Login session is authenticated to the CCP.
   * @type {boolean}
   * @memberof InlineResponse2008
   */
  authenticated?: boolean;
  /**
   * Login session is connected
   * @type {boolean}
   * @memberof InlineResponse2008
   */
  connected?: boolean;
  /**
   * server name
   * @type {string}
   * @memberof InlineResponse2008
   */
  name?: string;
}
/**
 *
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
  /**
   * The primary or parent account.
   * @type {string}
   * @memberof InlineResponse2009
   */
  mainAcct?: string;
  /**
   * List of tradeable or Sub Accounts
   * @type {Array<InlineResponse2009AcctList>}
   * @memberof InlineResponse2009
   */
  acctList?: Array<InlineResponse2009AcctList>;
}
/**
 *
 * @export
 * @interface InlineResponse2009AcctList
 */
export interface InlineResponse2009AcctList {
  /**
   * For multi-account structures each trading account will numbered from 0 to ...
   * @type {string}
   * @memberof InlineResponse2009AcctList
   */
  _0?: string;
}
/**
 *
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
  /**
   * for example-order not confirmed
   * @type {string}
   * @memberof InlineResponse400
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse400
   */
  statusCode?: number;
}
/**
 *
 * @export
 * @interface InlineResponse4001
 */
export interface InlineResponse4001 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse4001
   */
  error?: string;
  /**
   *
   * @type {number}
   * @memberof InlineResponse4001
   */
  statusCode?: number;
}
/**
 *
 * @export
 * @interface InlineResponse429
 */
export interface InlineResponse429 {
  /**
   *
   * @type {string}
   * @memberof InlineResponse429
   */
  error?: string;
}
/**
 *
 * @export
 * @interface IserverContractConidAlgosParameters
 */
export interface IserverContractConidAlgosParameters {
  /**
   * The algo parameter
   * @type {string}
   * @memberof IserverContractConidAlgosParameters
   */
  id: string;
  /**
   * If true a value must be entered.
   * @type {boolean}
   * @memberof IserverContractConidAlgosParameters
   */
  required?: boolean;
  /**
   * Descriptive name of the parameter.
   * @type {string}
   * @memberof IserverContractConidAlgosParameters
   */
  name?: string;
  /**
   * Format of the parameter.
   * @type {string}
   * @memberof IserverContractConidAlgosParameters
   */
  valueClassName: IserverContractConidAlgosParametersValueClassNameEnum;
  /**
   * Smallest value, only applies to parameters with valueClassName=Double.
   * @type {number}
   * @memberof IserverContractConidAlgosParameters
   */
  minValue?: number;
  /**
   * Largest value, only applies to parameters with valueClassName=Double.
   * @type {number}
   * @memberof IserverContractConidAlgosParameters
   */
  maxValue?: number;
  /**
   * User configured preset for this parameter.
   * @type {boolean}
   * @memberof IserverContractConidAlgosParameters
   */
  defaultValue?: boolean;
  /**
   * The list of choices
   * @type {string}
   * @memberof IserverContractConidAlgosParameters
   */
  legalStrings?: string;
  /**
   * Detailed description of the parameter.
   * @type {string}
   * @memberof IserverContractConidAlgosParameters
   */
  description?: string;
  /**
   * The order in UI, used when building dynamic UI so that more important parameters are presented first.
   * @type {number}
   * @memberof IserverContractConidAlgosParameters
   */
  guiRank?: number;
  /**
   * If true, must specify parameter using market rule format. Only applies to parameters with valueClassName=Double.
   * @type {boolean}
   * @memberof IserverContractConidAlgosParameters
   */
  priceMarketRule?: boolean;
  /**
   * The rules that UI should apply to algo parameters depending on chosen order type:  * MKT:speedUp:=:no - hide SpeedUp param when MKT is chosen for order type.  * LMT:strategyType:<>:empty - strategyType param cannot be empty when LMT is chosen for order type.  * MKT:strategyType:=:Marketable - set strategyType param to Marketable and disable (no other choice) when MKT is chosen for order type.
   * @type {string}
   * @memberof IserverContractConidAlgosParameters
   */
  enabledConditions?: IserverContractConidAlgosParametersEnabledConditionsEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum IserverContractConidAlgosParametersValueClassNameEnum {
  Double = "double",
  String = "string",
  Time = "time",
  Boolean = "boolean",
}
/**
 * @export
 * @enum {string}
 */
export enum IserverContractConidAlgosParametersEnabledConditionsEnum {
  MkTspeedUpno = "MKT:speedUp:=:no",
  LmTstrategyTypeempty = "LMT:strategyType:<>:empty",
  MkTstrategyTypeMarketable = "MKT:strategyType:=:Marketable",
}

/**
 *
 * @export
 * @interface IserverSecdefSearchSections
 */
export interface IserverSecdefSearchSections {
  /**
   * Asset Class
   * @type {string}
   * @memberof IserverSecdefSearchSections
   */
  secType?: string;
  /**
   * List of expiration month(s) and year(s) in MMMYY format separated by semicolon
   * @type {string}
   * @memberof IserverSecdefSearchSections
   */
  months?: string;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof IserverSecdefSearchSections
   */
  symbol?: string;
  /**
   * Listing Exchange
   * @type {string}
   * @memberof IserverSecdefSearchSections
   */
  exchange?: string;
  /**
   * For combo\'s defines the asset class for each leg
   * @type {string}
   * @memberof IserverSecdefSearchSections
   */
  legSecType?: string;
}
/**
 *
 * @export
 * @interface Ledger
 */
export interface Ledger {
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  commoditymarketvalue?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  futuremarketvalue?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  settledcash?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  exchangerate?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  sessionid?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  cashbalance?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  corporatebondsmarketvalue?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  warrantsmarketvalue?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  netliquidationvalue?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  interest?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  unrealizedpnl?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  stockmarketvalue?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  moneyfunds?: number;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  currency?: string;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  realizedpnl?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  funds?: number;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  acctcode?: string;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  issueroptionsmarketvalue?: number;
  /**
   *
   * @type {string}
   * @memberof Ledger
   */
  key?: string;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  timestamp?: number;
  /**
   *
   * @type {number}
   * @memberof Ledger
   */
  severity?: number;
}
/**
 *
 * @export
 * @interface MarketData
 */
export interface MarketData {
  /**
   * IBKR Contract ID
   * @type {number}
   * @memberof MarketData
   */
  conid?: number;
  /**
   * Exchange
   * @type {string}
   * @memberof MarketData
   */
  exchange?: string;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  minTick?: number;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  last?: number;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  lastSize?: number;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  bid?: number;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  bidSize?: number;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  ask?: number;
  /**
   *
   * @type {number}
   * @memberof MarketData
   */
  askSize?: number;
}
/**
 *
 * @export
 * @interface ModifyOrder
 */
export interface ModifyOrder {
  /**
   *
   * @type {string}
   * @memberof ModifyOrder
   */
  acctId?: string;
  /**
   *
   * @type {number}
   * @memberof ModifyOrder
   */
  conid?: number;
  /**
   * for example LMT
   * @type {string}
   * @memberof ModifyOrder
   */
  orderType?: string;
  /**
   *
   * @type {boolean}
   * @memberof ModifyOrder
   */
  outsideRTH?: boolean;
  /**
   *
   * @type {number}
   * @memberof ModifyOrder
   */
  price?: number;
  /**
   *
   * @type {number}
   * @memberof ModifyOrder
   */
  auxPrice?: number;
  /**
   * SELL or BUY
   * @type {string}
   * @memberof ModifyOrder
   */
  side?: string;
  /**
   * optional, not required
   * @type {string}
   * @memberof ModifyOrder
   */
  listingExchange?: string;
  /**
   * The ticker symbol of the original place order
   * @type {string}
   * @memberof ModifyOrder
   */
  ticker?: string;
  /**
   * Specify a time in force to change how long your order will continue to work in the market
   * @type {string}
   * @memberof ModifyOrder
   */
  tif?: string;
  /**
   * usually integer, for some special cases can be float numbers
   * @type {number}
   * @memberof ModifyOrder
   */
  quantity?: number;
  /**
   * Set to true if you want to pause a working order. For details refer to the [TWS Users\' Guide:](https://guides.interactivebrokers.com/tws/twsguide.html#usersguidebook/getstarted/pause_execution.htm)
   * @type {boolean}
   * @memberof ModifyOrder
   */
  deactivated?: boolean;
}
/**
 * contains all the order related info
 * @export
 * @interface Order
 */
export interface Order {
  /**
   * account id
   * @type {string}
   * @memberof Order
   */
  acct?: string;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  conid?: number;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  orderDesc?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  description1?: string;
  /**
   * for example FB
   * @type {string}
   * @memberof Order
   */
  ticker?: string;
  /**
   * for example STK
   * @type {string}
   * @memberof Order
   */
  secType?: string;
  /**
   * for example NASDAQ.NMS
   * @type {string}
   * @memberof Order
   */
  listingExchange?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  remainingQuantity?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  filledQuantity?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  companyName?: string;
  /**
   * * PendingSubmit - Indicates the order was sent, but confirmation has not been received that it has been received by the destination.                   Occurs most commonly if an exchange is closed. * PendingCancel - Indicates that a request has been sent to cancel an order but confirmation has not been received of its cancellation. * PreSubmitted - Indicates that a simulated order type has been accepted by the IBKR system and that this order has yet to be elected.                  The order is held in the IBKR system until the election criteria are met. At that time the order is transmitted to the order destination as specified. * Submitted - Indicates that the order has been accepted at the order destination and is working. * Cancelled - Indicates that the balance of the order has been confirmed cancelled by the IB system.               This could occur unexpectedly when IB or the destination has rejected the order. * Filled - Indicates that the order has been completely filled. * Inactive - Indicates the order is not working, for instance if the order was invalid and triggered an error message,              or if the order was to short a security and shares have not yet been located.
   * @type {string}
   * @memberof Order
   */
  status?: string;
  /**
   * for example Limit
   * @type {string}
   * @memberof Order
   */
  origOrderType?: string;
  /**
   * BUY or SELL
   * @type {string}
   * @memberof Order
   */
  side?: string;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  price?: number;
  /**
   * back-ground color
   * @type {string}
   * @memberof Order
   */
  bgColor?: string;
  /**
   *
   * @type {string}
   * @memberof Order
   */
  fgColor?: string;
  /**
   *
   * @type {number}
   * @memberof Order
   */
  orderId?: number;
  /**
   * Only exists in child order of bracket
   * @type {number}
   * @memberof Order
   */
  parentId?: number;
  /**
   * User defined string used to identify the order. Value is set using \"cOID\" field while placing an order.
   * @type {string}
   * @memberof Order
   */
  orderRef?: string;
}
/**
 *
 * @export
 * @interface OrderData
 */
export interface OrderData {
  /**
   *
   * @type {string}
   * @memberof OrderData
   */
  clientOrderId?: string;
  /**
   *
   * @type {string}
   * @memberof OrderData
   */
  execId?: string;
  /**
   *
   * @type {string}
   * @memberof OrderData
   */
  execType?: OrderDataExecTypeEnum;
  /**
   *
   * @type {string}
   * @memberof OrderData
   */
  orderType?: OrderDataOrderTypeEnum;
  /**
   *
   * @type {string}
   * @memberof OrderData
   */
  orderStatus?: OrderDataOrderStatusEnum;
  /**
   * Underlying symbol for contract
   * @type {string}
   * @memberof OrderData
   */
  symbol?: string;
  /**
   * Quantity of active order
   * @type {string}
   * @memberof OrderData
   */
  orderQty?: string;
  /**
   * Price of active order
   * @type {string}
   * @memberof OrderData
   */
  price?: string;
  /**
   * Quantity of the last partial fill
   * @type {string}
   * @memberof OrderData
   */
  lastShares?: string;
  /**
   * Price of the last partial fill
   * @type {string}
   * @memberof OrderData
   */
  lastPrice?: string;
  /**
   * Cumulative fill quantity
   * @type {string}
   * @memberof OrderData
   */
  cumQty?: string;
  /**
   * Remaining quantity to be filled
   * @type {string}
   * @memberof OrderData
   */
  leavesQty?: string;
  /**
   * Average fill price
   * @type {string}
   * @memberof OrderData
   */
  avgPrice?: string;
  /**
   *
   * @type {string}
   * @memberof OrderData
   */
  side?: OrderDataSideEnum;
  /**
   * Order identifier
   * @type {string}
   * @memberof OrderData
   */
  orderId?: string;
  /**
   * Account number
   * @type {string}
   * @memberof OrderData
   */
  account?: string;
  /**
   * Contracts asset class
   * @type {string}
   * @memberof OrderData
   */
  secType?: OrderDataSecTypeEnum;
  /**
   * Time of transaction in GMT, format YYYYMMDD-hh:m:ss
   * @type {string}
   * @memberof OrderData
   */
  txTime?: string;
  /**
   * Time of receipt in GMT, format YYYYMMDD-hh:mm:ss
   * @type {string}
   * @memberof OrderData
   */
  rcptTime?: string;
  /**
   * Time in Force
   * @type {string}
   * @memberof OrderData
   */
  tif?: OrderDataTifEnum;
  /**
   * Contract identifier from IBKR\'s database.
   * @type {string}
   * @memberof OrderData
   */
  conid?: string;
  /**
   * Trading currency
   * @type {string}
   * @memberof OrderData
   */
  currency?: string;
  /**
   * Exchange or venue
   * @type {string}
   * @memberof OrderData
   */
  exchange?: string;
  /**
   * Listing Exchange
   * @type {string}
   * @memberof OrderData
   */
  listingExchange?: string;
  /**
   * error message
   * @type {number}
   * @memberof OrderData
   */
  text?: number;
  /**
   *
   * @type {OrderDataWarnings}
   * @memberof OrderData
   */
  warnings?: OrderDataWarnings;
  /**
   * Commission currency
   * @type {string}
   * @memberof OrderData
   */
  commCurr?: string;
  /**
   * Commissions
   * @type {string}
   * @memberof OrderData
   */
  comms?: string;
  /**
   * Realized PnL
   * @type {string}
   * @memberof OrderData
   */
  realizedPnl?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum OrderDataExecTypeEnum {
  _1Invalid = '-1 "Invalid"',
  _0New = '0 "New"',
  _1PartiallyFilled = '1 "Partially Filled"',
  _2Filled = '2 "Filled"',
  _3DoneForTheDay = '3 "Done for the Day"',
  _4Canceled = '4 "Canceled"',
  _5Replaced = '5 "Replaced"',
  _6PendingCancel = '6 "Pending Cancel"',
  _7Stopped = '7 "Stopped"',
  _8Rejected = '8 "Rejected"',
  _9Suspended = '9 "Suspended"',
  APendingNew = 'A "Pending New"',
  BCalculated = 'B "Calculated"',
  CExpired = 'C "Expired"',
  DRestated = 'D "Restated"',
  EPendingReplace = 'E "Pending Replace"',
  FTrade = 'F "Trade"',
  GTradeCorrect = 'G "Trade Correct"',
  HTradeCancel = 'H "Trade Cancel"',
  IOrderStatus = 'I "Order Status"',
}
/**
 * @export
 * @enum {string}
 */
export enum OrderDataOrderTypeEnum {
  _1Market = '1 "Market"',
  _2Limit = '2 "Limit"',
  _3Stop = '3 "Stop"',
  _4StopLimit = '4 "Stop Limit"',
  _5MarketOnClose = '5 "Market on Close"',
  _6WithOrWithout = '6 "With or Without"',
  _7LimitOrBetter = '7 "Limit or Better"',
  _8LimitWithOrWithout = '8 "Limit With or Without"',
  _9OnBasis = '9 "On Basis"',
  AOnClose = 'A "On Close"',
  BLimitOnClose = 'B "Limit On Close"',
  CForexMarket = 'C "Forex Market"',
  DPreviouslyQuoted = 'D "Previously Quoted"',
  EPreviouslyIndicated = 'E "Previously Indicated"',
  FForexLimit = 'F "Forex Limit"',
  GForexSwap = 'G "Forex Swap"',
  HForexPreviouslyQuoted = 'H "Forex Previously Quoted"',
  IFunari = 'I "Funari"',
  KMarketToLimit = 'K "Market To Limit"',
  PPegged = 'P "Pegged"',
}
/**
 * @export
 * @enum {string}
 */
export enum OrderDataOrderStatusEnum {
  _1InvalidOrderStatus = '-1 "Invalid Order Status"',
  _0New = '0 "New"',
  _1PartiallyFilled = '1 "Partially Filled"',
  _2Filled = '2 "Filled"',
  _3DoneForTheDay = '3 "Done for the Day"',
  _4Canceled = '4 "Canceled"',
  _5Replaced = '5 "Replaced"',
  _6PendingCancel = '6 "Pending Cancel"',
  _7Stopped = '7 "Stopped"',
  _8Rejected = '8 "Rejected"',
  _9Suspended = '9 "Suspended"',
  APendingNew = 'A "Pending New"',
  BCalculated = 'B "Calculated"',
  CExpired = 'C "Expired"',
  DRestated = 'D "Restated"',
  EPendingReplace = 'E "Pending Replace"',
}
/**
 * @export
 * @enum {string}
 */
export enum OrderDataSideEnum {
  _1Buy = '1 "Buy"',
  _2Sell = '2 "Sell"',
  _3BuyMinus = '3 "Buy Minus"',
  _4SellPlus = '4 "Sell Plus"',
  _5SellShort = '5 "Sell Short"',
  _6SellShortExempt = '6 "Sell Short Exempt"',
}
/**
 * @export
 * @enum {string}
 */
export enum OrderDataSecTypeEnum {
  CsStock = 'CS "Stock"',
  CashForex = 'CASH "Forex"',
  CfdContractForDifference = 'CFD "Contract for Difference"',
  FutFuture = 'FUT "Future"',
  OptOption = 'OPT "Option"',
}
/**
 * @export
 * @enum {string}
 */
export enum OrderDataTifEnum {
  _0Day = '0 "Day"',
  _1Gtc = '1 "GTC"',
  _2AtTheOpening = '2 "At the Opening"',
}

/**
 *
 * @export
 * @interface OrderDataWarnings
 */
export interface OrderDataWarnings {
  /**
   *
   * @type {string}
   * @memberof OrderDataWarnings
   */
  pRICECAP?: string;
  /**
   *
   * @type {string}
   * @memberof OrderDataWarnings
   */
  tIME?: string;
}
/**
 *
 * @export
 * @interface OrderRequest
 */
export interface OrderRequest {
  /**
   * acctId is optional. It should be one of the accounts returned by /iserver/accounts. If not passed, the first one in the list is selected.
   * @type {string}
   * @memberof OrderRequest
   */
  acctId?: string;
  /**
   * conid is the identifier of the security you want to trade, you can find the conid with /iserver/secdef/search.
   * @type {number}
   * @memberof OrderRequest
   */
  conid?: number;
  /**
   * The contract-identifier (conid) and security type (type) specified as a concatenated value, conid:type
   * @type {string}
   * @memberof OrderRequest
   */
  secType?: string;
  /**
   * Customer Order ID. An arbitrary string that can be used to identify the order, e.g \"my-fb-order\". The value must be unique for a 24h span. Please do not set this value for child orders when placing a bracket order.
   * @type {string}
   * @memberof OrderRequest
   */
  cOID?: string;
  /**
   * Only specify for child orders when placing bracket orders. The parentId for the child order(s) must be equal to the cOId (customer order id) of the parent.
   * @type {string}
   * @memberof OrderRequest
   */
  parentId?: string;
  /**
   * The order-type determines what type of order you want to send. LMT - A limit order is an order to buy or sell at the specified price or better. MKT - A market order is an order to buy or sell at the markets current NBBO. STP - A stop order becomes a market order once the specified stop price is attained or penetrated. STOP_LIMIT - A stop limit order becomes a limit order once the specified stop price is attained or penetrated. MIDPRICE - A MidPrice order attempts to fill at the current midpoint of the NBBO or better.
   * @type {string}
   * @memberof OrderRequest
   */
  orderType?: string;
  /**
   * listingExchange is optional. By default we use \"SMART\" routing. Possible values are available via this end point: /v1/portal/iserver/contract/{conid}/info, see valid_exchange: e.g: SMART,AMEX,NYSE, CBOE,ISE,CHX,ARCA,ISLAND,DRCTEDGE,BEX,BATS,EDGEA,CSFBALGO,JE FFALGO,BYX,IEX,FOXRIVER,TPLUS1,NYSENAT,PSX
   * @type {string}
   * @memberof OrderRequest
   */
  listingExchange?: string;
  /**
   * set to true if you want to place a single group orders(OCA)
   * @type {boolean}
   * @memberof OrderRequest
   */
  isSingleGroup?: boolean;
  /**
   * set to true if the order can be executed outside regular trading hours.
   * @type {boolean}
   * @memberof OrderRequest
   */
  outsideRTH?: boolean;
  /**
   * optional if order is LMT, or STOP_LIMIT, this is the limit price. For STP this is the stop price. For MIDPRICE this is the option price cap.
   * @type {number}
   * @memberof OrderRequest
   */
  price?: number;
  /**
   * optional if order is STOP_LIMIT, this is the stop price. You must specify both price and auxPrice for STOP_LIMIT orders.
   * @type {object}
   * @memberof OrderRequest
   */
  auxPrice?: object;
  /**
   * SELL or BUY
   * @type {string}
   * @memberof OrderRequest
   */
  side?: string;
  /**
   * This is the  underlying symbol for the contract.
   * @type {string}
   * @memberof OrderRequest
   */
  ticker?: string;
  /**
   * The Time-In-Force determines how long the order remains active on the market.   * GTC - use Good-Till-Cancel for orders to remain active until it executes or cancelled.   * OPG - use Open-Price-Guarantee for Limit-On-Open (LOO) or Market-On-Open (MOO) orders.   * DAY - if not executed a Day order will automatically cancel at the end of the markets regular trading hours.   * IOC - any portion of an Immediate-or-Cancel order that is not filled as soon as it becomes available in the market is cancelled.
   * @type {string}
   * @memberof OrderRequest
   */
  tif?: string;
  /**
   * Custom order reference
   * @type {string}
   * @memberof OrderRequest
   */
  referrer?: string;
  /**
   * usually integer, for some special cases can be float numbers
   * @type {number}
   * @memberof OrderRequest
   */
  quantity?: number;
  /**
   * double number, this is the cash quantity field which can only be used for FX conversion order. When using \'fxQty\' you don\'t need to specify \'quantity\'.
   * @type {number}
   * @memberof OrderRequest
   */
  fxQty?: number;
  /**
   * If true, the system will use the Price Management Algo to submit the order. https://www.interactivebrokers.com/en/index.php?f=43423
   * @type {boolean}
   * @memberof OrderRequest
   */
  useAdaptive?: boolean;
  /**
   * set to true if the order is a FX conversion order
   * @type {boolean}
   * @memberof OrderRequest
   */
  isCcyConv?: boolean;
  /**
   * Set the allocation method when placing an order using an FA account for a group Possible allocation methods are \"NetLiquidity\", \"AvailableEquity\", \"EqualQuantity\" and \"PctChange\".
   * @type {string}
   * @memberof OrderRequest
   */
  allocationMethod?: string;
  /**
   * Specify which IB Algo algorithm to use for this order.
   * @type {string}
   * @memberof OrderRequest
   */
  strategy?: string;
  /**
   * The IB Algo parameters for the specified algorithm.
   * @type {object}
   * @memberof OrderRequest
   */
  strategyParameters?: object;
}
/**
 * contains all the details of an order
 * @export
 * @interface OrderStatus
 */
export interface OrderStatus {
  /**
   * order sub-type
   * @type {string}
   * @memberof OrderStatus
   */
  subType?: string;
  /**
   * order request id
   * @type {string}
   * @memberof OrderStatus
   */
  requestId?: string;
  /**
   * system generated order id, unique per account
   * @type {number}
   * @memberof OrderStatus
   */
  orderId?: number;
  /**
   * conid and exchange. Format supports conid or conid@exchange
   * @type {string}
   * @memberof OrderStatus
   */
  conidex?: string;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof OrderStatus
   */
  symbol?: string;
  /**
   * The side of the market of the order.   * B - Buy contract near posted ask price   * S - Sell contract near posted bid price   * X - Option expired
   * @type {string}
   * @memberof OrderStatus
   */
  side?: OrderStatusSideEnum;
  /**
   * Format contract name
   * @type {string}
   * @memberof OrderStatus
   */
  contractDescription1?: string;
  /**
   * Trading Exchange or Venue
   * @type {string}
   * @memberof OrderStatus
   */
  listingExchange?: string;
  /**
   *
   * @type {string}
   * @memberof OrderStatus
   */
  optionAcct?: string;
  /**
   * Contracts company name
   * @type {string}
   * @memberof OrderStatus
   */
  companyName?: string;
  /**
   * Quantity updated
   * @type {string}
   * @memberof OrderStatus
   */
  size?: string;
  /**
   * Total quantity
   * @type {string}
   * @memberof OrderStatus
   */
  totalSize?: string;
  /**
   * Contract traded currency
   * @type {string}
   * @memberof OrderStatus
   */
  currency?: string;
  /**
   * account id
   * @type {string}
   * @memberof OrderStatus
   */
  account?: string;
  /**
   * Types of orders
   * @type {string}
   * @memberof OrderStatus
   */
  orderType?: string;
  /**
   * Limit price
   * @type {string}
   * @memberof OrderStatus
   */
  limitPrice?: string;
  /**
   * Stop price
   * @type {string}
   * @memberof OrderStatus
   */
  stopPrice?: string;
  /**
   * Cumulative fill
   * @type {string}
   * @memberof OrderStatus
   */
  cumFill?: string;
  /**
   * *  PendingSubmit - Indicates the order was sent, but confirmation has not been received that it has been received by the destination.                    Occurs most commonly if an exchange is closed. *  PendingCancel - Indicates that a request has been sent to cancel an order but confirmation has not been received of its cancellation. *  PreSubmitted - Indicates that a simulated order type has been accepted by the IBKR system and that this order has yet to be elected.                   The order is held in the IBKR system until the election criteria are met. At that time the order is transmitted to the order destination as specified. *  Submitted - Indicates that the order has been accepted at the order destination and is working. *  Cancelled - Indicates that the balance of the order has been confirmed cancelled by the IB system.                This could occur unexpectedly when IB or the destination has rejected the order. *  Filled - Indicates that the order has been completely filled. *  Inactive - Indicates the order is not working, for instance if the order was invalid and triggered an error message,               or if the order was to short a security and shares have not yet been located.
   * @type {string}
   * @memberof OrderStatus
   */
  orderStatus?: string;
  /**
   * Description of the order status
   * @type {string}
   * @memberof OrderStatus
   */
  orderStatusDescription?: string;
  /**
   * Time-in-Force - length of time order will continue working before it is canceled.
   * @type {string}
   * @memberof OrderStatus
   */
  tif?: string;
  /**
   * Foreground color in hex format
   * @type {string}
   * @memberof OrderStatus
   */
  fgColor?: string;
  /**
   * Background color in hex format
   * @type {string}
   * @memberof OrderStatus
   */
  bgColor?: string;
  /**
   * If true not allowed to modify order
   * @type {boolean}
   * @memberof OrderStatus
   */
  orderNotEditable?: boolean;
  /**
   * Fields that can be edited in escaped unicode characters
   * @type {string}
   * @memberof OrderStatus
   */
  editableFields?: string;
  /**
   * If true not allowed to cancel order
   * @type {boolean}
   * @memberof OrderStatus
   */
  cannotCancelOrder?: boolean;
  /**
   * If true order trades outside regular trading hours
   * @type {boolean}
   * @memberof OrderStatus
   */
  outsideRth?: boolean;
  /**
   * If true order is de-activated
   * @type {boolean}
   * @memberof OrderStatus
   */
  deactivateOrder?: boolean;
  /**
   * If true price management algo is enabled, refer to https://www.interactivebrokers.com/en/index.php?f=43423
   * @type {boolean}
   * @memberof OrderStatus
   */
  usePriceMgmtAlgo?: boolean;
  /**
   * Asset class
   * @type {string}
   * @memberof OrderStatus
   */
  secType?: string;
  /**
   * List of available chart periods
   * @type {string}
   * @memberof OrderStatus
   */
  availableChartPeriods?: string;
  /**
   * Format description of order
   * @type {string}
   * @memberof OrderStatus
   */
  orderDescription?: string;
  /**
   * order_description with the symbol
   * @type {string}
   * @memberof OrderStatus
   */
  orderDescriptionWithContract?: string;
  /**
   *
   * @type {number}
   * @memberof OrderStatus
   */
  alertActive?: number;
  /**
   * type of the child order
   * @type {string}
   * @memberof OrderStatus
   */
  childOrderType?: string;
  /**
   * Format fillQuantity\\totalQuantity
   * @type {string}
   * @memberof OrderStatus
   */
  sizeAndFills?: string;
  /**
   * Position display price
   * @type {string}
   * @memberof OrderStatus
   */
  exitStrategyDisplayPrice?: string;
  /**
   * Position description to display on chart
   * @type {string}
   * @memberof OrderStatus
   */
  exitStrategyChartDescription?: string;
  /**
   * * 1: If your account has position or order for contract * 0: If your account has no position or order for contract
   * @type {string}
   * @memberof OrderStatus
   */
  exitStrategyToolAvailability?: OrderStatusExitStrategyToolAvailabilityEnum;
  /**
   * Returns true if contract supports duplicate/opposite side order.
   * @type {boolean}
   * @memberof OrderStatus
   */
  allowedDuplicateOpposite?: boolean;
  /**
   * Time of status update in unix time
   * @type {string}
   * @memberof OrderStatus
   */
  orderTime?: string;
  /**
   * only exists for oca orders, oca orders in same group will have same id
   * @type {string}
   * @memberof OrderStatus
   */
  ocaGroupId?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum OrderStatusSideEnum {
  B = "B",
  S = "S",
  X = "X",
}
/**
 * @export
 * @enum {string}
 */
export enum OrderStatusExitStrategyToolAvailabilityEnum {
  _1 = "1",
  _0 = "0",
}

/**
 *
 * @export
 * @interface Performance
 */
export interface Performance {
  /**
   *
   * @type {string}
   * @memberof Performance
   */
  id?: string;
  /**
   *
   * @type {PerformanceCps}
   * @memberof Performance
   */
  cps?: PerformanceCps;
  /**
   *
   * @type {PerformanceTpps}
   * @memberof Performance
   */
  tpps?: PerformanceTpps;
  /**
   *
   * @type {PerformanceNav}
   * @memberof Performance
   */
  nav?: PerformanceNav;
  /**
   *
   * @type {string}
   * @memberof Performance
   */
  pm?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof Performance
   */
  included?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof Performance
   */
  currencyType?: string;
  /**
   *
   * @type {number}
   * @memberof Performance
   */
  rc?: number;
}
/**
 * Cumulative performance data
 * @export
 * @interface PerformanceCps
 */
export interface PerformanceCps {
  /**
   * array of dates, the length should be same as the length of returns inside data.
   * @type {Array<string>}
   * @memberof PerformanceCps
   */
  dates?: Array<string>;
  /**
   * D means Day
   * @type {string}
   * @memberof PerformanceCps
   */
  freq?: string;
  /**
   *
   * @type {Array<PerformanceCpsData>}
   * @memberof PerformanceCps
   */
  data?: Array<PerformanceCpsData>;
}
/**
 *
 * @export
 * @interface PerformanceCpsData
 */
export interface PerformanceCpsData {
  /**
   *
   * @type {string}
   * @memberof PerformanceCpsData
   */
  id?: string;
  /**
   * for example-- acctid
   * @type {string}
   * @memberof PerformanceCpsData
   */
  idType?: string;
  /**
   * start date-- yyyyMMdd
   * @type {string}
   * @memberof PerformanceCpsData
   */
  start?: string;
  /**
   *
   * @type {string}
   * @memberof PerformanceCpsData
   */
  baseCurrency?: string;
  /**
   * each value stands for price change percent of corresponding date in dates array
   * @type {Array<number>}
   * @memberof PerformanceCpsData
   */
  returns?: Array<number>;
  /**
   * end date-- yyyyMMdd
   * @type {string}
   * @memberof PerformanceCpsData
   */
  end?: string;
}
/**
 * Net asset value data for the account or consolidated accounts. NAV data is not applicable to benchmarks.
 * @export
 * @interface PerformanceNav
 */
export interface PerformanceNav {
  /**
   * array of dates, the length should be same as the length of returns inside data.
   * @type {Array<string>}
   * @memberof PerformanceNav
   */
  dates?: Array<string>;
  /**
   * D means Day
   * @type {string}
   * @memberof PerformanceNav
   */
  freq?: string;
  /**
   *
   * @type {Array<PerformanceCpsData>}
   * @memberof PerformanceNav
   */
  data?: Array<PerformanceCpsData>;
}
/**
 * Time period performance data
 * @export
 * @interface PerformanceTpps
 */
export interface PerformanceTpps {
  /**
   * array of dates, the length should be same as the length of returns inside data.
   * @type {Array<string>}
   * @memberof PerformanceTpps
   */
  dates?: Array<string>;
  /**
   * M means Month
   * @type {string}
   * @memberof PerformanceTpps
   */
  freq?: string;
  /**
   *
   * @type {Array<PerformanceCpsData>}
   * @memberof PerformanceTpps
   */
  data?: Array<PerformanceCpsData>;
}
/**
 *
 * @export
 * @interface PositionData
 */
export interface PositionData {
  /**
   * Contract identifier from IBKR\'s database.
   * @type {number}
   * @memberof PositionData
   */
  conid?: number;
  /**
   * Number of shares or quantity of the position.
   * @type {number}
   * @memberof PositionData
   */
  position?: number;
  /**
   * Average cost of the position.
   * @type {number}
   * @memberof PositionData
   */
  avgCost?: number;
}
/**
 *
 * @export
 * @interface ScannerParams
 */
export interface ScannerParams {
  /**
   *
   * @type {ScannerParamsInstrumentList}
   * @memberof ScannerParams
   */
  instrumentList?: ScannerParamsInstrumentList;
  /**
   *
   * @type {ScannerParamsLocationTree}
   * @memberof ScannerParams
   */
  locationTree?: ScannerParamsLocationTree;
  /**
   * Contains list of filters supported for the scanner
   * @type {Array<object>}
   * @memberof ScannerParams
   */
  filterList?: Array<object>;
  /**
   *
   * @type {ScannerParamsScanTypeList}
   * @memberof ScannerParams
   */
  scanTypeList?: ScannerParamsScanTypeList;
}
/**
 * Contains list of instruments for which scanner can be ran
 * @export
 * @interface ScannerParamsInstrumentList
 */
export interface ScannerParamsInstrumentList {
  /**
   * Contains information like name, supported filters, etc. for an instrument
   * @type {Array<ScannerParamsInstrumentListInstrument>}
   * @memberof ScannerParamsInstrumentList
   */
  instrument?: Array<ScannerParamsInstrumentListInstrument>;
}
/**
 *
 * @export
 * @interface ScannerParamsInstrumentListInstrument
 */
export interface ScannerParamsInstrumentListInstrument {
  /**
   * Type of the asset
   * @type {string}
   * @memberof ScannerParamsInstrumentListInstrument
   */
  type?: string;
  /**
   * Display name for the instrument
   * @type {string}
   * @memberof ScannerParamsInstrumentListInstrument
   */
  name?: string;
  /**
   *
   * @type {string}
   * @memberof ScannerParamsInstrumentListInstrument
   */
  shortName?: string;
  /**
   * Sec Type of the instrument. This field is not provided if its value is same as \'type\'
   * @type {string}
   * @memberof ScannerParamsInstrumentListInstrument
   */
  secType?: string;
  /**
   * Supported filters for the instrument separated by a comma
   * @type {string}
   * @memberof ScannerParamsInstrumentListInstrument
   */
  filters?: string;
}
/**
 * Contains list of instruments for which scanner can be ran
 * @export
 * @interface ScannerParamsLocationTree
 */
export interface ScannerParamsLocationTree {
  /**
   * Contains information like name, supported filters, etc. for an instrument. A location can contain more locations forming a tree-like structure which allows user to control the lcoation at more granular level. locationCode has to be used to specify lcoations while querying a scanner.
   * @type {Array<ScannerParamsLocationTreeLocation>}
   * @memberof ScannerParamsLocationTree
   */
  location?: Array<ScannerParamsLocationTreeLocation>;
}
/**
 *
 * @export
 * @interface ScannerParamsLocationTreeLocation
 */
export interface ScannerParamsLocationTreeLocation {
  /**
   *
   * @type {string}
   * @memberof ScannerParamsLocationTreeLocation
   */
  instruments?: string;
  /**
   *
   * @type {string}
   * @memberof ScannerParamsLocationTreeLocation
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof ScannerParamsLocationTreeLocation
   */
  locationCode?: string;
  /**
   *
   * @type {string}
   * @memberof ScannerParamsLocationTreeLocation
   */
  routeExchange?: string;
}
/**
 * Contains list of scan types for which scanner can be ran
 * @export
 * @interface ScannerParamsScanTypeList
 */
export interface ScannerParamsScanTypeList {
  /**
   *
   * @type {Array<ScannerParamsScanTypeListScanType>}
   * @memberof ScannerParamsScanTypeList
   */
  scanType?: Array<ScannerParamsScanTypeListScanType>;
}
/**
 *
 * @export
 * @interface ScannerParamsScanTypeListScanType
 */
export interface ScannerParamsScanTypeListScanType {
  /**
   * Instrument types separated by a comma which are supported for this scan type
   * @type {string}
   * @memberof ScannerParamsScanTypeListScanType
   */
  instruments?: string;
  /**
   *
   * @type {string}
   * @memberof ScannerParamsScanTypeListScanType
   */
  displayName?: string;
  /**
   * scan code which ahs to be provided while querying scanner with this scan type
   * @type {string}
   * @memberof ScannerParamsScanTypeListScanType
   */
  scanCode?: string;
}
/**
 *
 * @export
 * @interface ScannerResult
 */
export interface ScannerResult {
  /**
   *
   * @type {number}
   * @memberof ScannerResult
   */
  total?: number;
  /**
   *
   * @type {number}
   * @memberof ScannerResult
   */
  size?: number;
  /**
   *
   * @type {number}
   * @memberof ScannerResult
   */
  offset?: number;
  /**
   *
   * @type {string}
   * @memberof ScannerResult
   */
  scanTime?: string;
  /**
   *
   * @type {number}
   * @memberof ScannerResult
   */
  id?: number;
  /**
   *
   * @type {string}
   * @memberof ScannerResult
   */
  position?: string;
  /**
   *
   * @type {ScannerResultContracts}
   * @memberof ScannerResult
   */
  contracts?: ScannerResultContracts;
}
/**
 * Contains list of contracts matching the scanner query
 * @export
 * @interface ScannerResultContracts
 */
export interface ScannerResultContracts {
  /**
   *
   * @type {Array<ScannerResultContractsContract>}
   * @memberof ScannerResultContracts
   */
  contract?: Array<ScannerResultContractsContract>;
}
/**
 *
 * @export
 * @interface ScannerResultContractsContract
 */
export interface ScannerResultContractsContract {
  /**
   *
   * @type {string}
   * @memberof ScannerResultContractsContract
   */
  inScanTime?: string;
  /**
   *
   * @type {number}
   * @memberof ScannerResultContractsContract
   */
  distance?: number;
  /**
   *
   * @type {number}
   * @memberof ScannerResultContractsContract
   */
  contractID?: number;
}
/**
 * Contains some basic info of contract
 * @export
 * @interface SecdefInfo
 */
export interface SecdefInfo {
  /**
   *
   * @type {number}
   * @memberof SecdefInfo
   */
  conid?: number;
  /**
   * Underlying symbol
   * @type {string}
   * @memberof SecdefInfo
   */
  symbol?: string;
  /**
   *
   * @type {string}
   * @memberof SecdefInfo
   */
  secType?: string;
  /**
   *
   * @type {string}
   * @memberof SecdefInfo
   */
  exchange?: string;
  /**
   *
   * @type {string}
   * @memberof SecdefInfo
   */
  listingExchange?: string;
  /**
   * C = Call Option, P = Put Option
   * @type {string}
   * @memberof SecdefInfo
   */
  right?: string;
  /**
   * The strike price also known as exercise price
   * @type {string}
   * @memberof SecdefInfo
   */
  strike?: string;
  /**
   * Currency the contract trades in
   * @type {string}
   * @memberof SecdefInfo
   */
  currency?: string;
  /**
   * Committee on Uniform Securities Identification Procedures number
   * @type {string}
   * @memberof SecdefInfo
   */
  cusip?: string;
  /**
   * Annual interest rate paid on a bond
   * @type {string}
   * @memberof SecdefInfo
   */
  coupon?: string;
  /**
   * Formatted symbol
   * @type {string}
   * @memberof SecdefInfo
   */
  desc1?: string;
  /**
   * Formatted expiration, strike and right
   * @type {string}
   * @memberof SecdefInfo
   */
  desc2?: string;
  /**
   * Format YYYYMMDD, the date on which the underlying transaction settles if the option is exercised
   * @type {string}
   * @memberof SecdefInfo
   */
  maturityDate?: string;
  /**
   * total premium paid or received for an option contract
   * @type {string}
   * @memberof SecdefInfo
   */
  multiplier?: string;
  /**
   *
   * @type {string}
   * @memberof SecdefInfo
   */
  tradingClass?: string;
  /**
   *
   * @type {string}
   * @memberof SecdefInfo
   */
  validExchanges?: string;
}
/**
 *
 * @export
 * @interface SetAccount
 */
export interface SetAccount {
  /**
   * Account ID
   * @type {string}
   * @memberof SetAccount
   */
  acctId?: string;
}
/**
 *
 * @export
 * @interface StatsData
 */
export interface StatsData {
  /**
   *
   * @type {number}
   * @memberof StatsData
   */
  conid?: number;
  /**
   *
   * @type {string}
   * @memberof StatsData
   */
  exchange?: string;
  /**
   *
   * @type {number}
   * @memberof StatsData
   */
  v?: number;
  /**
   *
   * @type {number}
   * @memberof StatsData
   */
  t?: number;
  /**
   *
   * @type {number}
   * @memberof StatsData
   */
  tT?: number;
  /**
   * Object, payload depends on event type. See confluence page for IGEvntUpd.
   * @type {string}
   * @memberof StatsData
   */
  p?: string;
}
/**
 * account information
 * @export
 * @interface Summary
 */
export interface Summary {
  /**
   *
   * @type {SummaryTotal}
   * @memberof Summary
   */
  total?: SummaryTotal;
  /**
   * date format-- yyyy-MM-dd
   * @type {string}
   * @memberof Summary
   */
  startDate?: string;
  /**
   *
   * @type {Array<SummaryExcludedAccounts>}
   * @memberof Summary
   */
  excludedAccounts?: Array<SummaryExcludedAccounts>;
  /**
   *
   * @type {string}
   * @memberof Summary
   */
  lastSuccessfulUpdate?: string;
  /**
   *
   * @type {Array<SummaryAccountSummaries>}
   * @memberof Summary
   */
  accountSummaries?: Array<SummaryAccountSummaries>;
  /**
   *
   * @type {string}
   * @memberof Summary
   */
  endDate?: string;
  /**
   * indicator of user having configured any external accounts
   * @type {boolean}
   * @memberof Summary
   */
  hasExternalAccounts?: boolean;
  /**
   *
   * @type {number}
   * @memberof Summary
   */
  rc?: number;
  /**
   *
   * @type {string}
   * @memberof Summary
   */
  currency?: string;
  /**
   *
   * @type {string}
   * @memberof Summary
   */
  userId?: string;
  /**
   *
   * @type {string}
   * @memberof Summary
   */
  pm?: string;
  /**
   *
   * @type {string}
   * @memberof Summary
   */
  view?: string;
  /**
   *
   * @type {SummaryBalanceByDate}
   * @memberof Summary
   */
  balanceByDate?: SummaryBalanceByDate;
}
/**
 *
 * @export
 * @interface SummaryAccountSummaries
 */
export interface SummaryAccountSummaries {
  /**
   *
   * @type {string}
   * @memberof SummaryAccountSummaries
   */
  chg?: string;
  /**
   *
   * @type {boolean}
   * @memberof SummaryAccountSummaries
   */
  hasAccounts?: boolean;
  /**
   *
   * @type {string}
   * @memberof SummaryAccountSummaries
   */
  accountTypeName?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryAccountSummaries
   */
  rtn?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryAccountSummaries
   */
  endVal?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryAccountSummaries
   */
  accountTypeCode?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryAccountSummaries
   */
  startVal?: string;
}
/**
 *
 * @export
 * @interface SummaryBalanceByDate
 */
export interface SummaryBalanceByDate {
  /**
   *
   * @type {Array<SummaryBalanceByDateSeries>}
   * @memberof SummaryBalanceByDate
   */
  series?: Array<SummaryBalanceByDateSeries>;
}
/**
 *
 * @export
 * @interface SummaryBalanceByDateSeries
 */
export interface SummaryBalanceByDateSeries {
  /**
   *
   * @type {string}
   * @memberof SummaryBalanceByDateSeries
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryBalanceByDateSeries
   */
  groupId?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryBalanceByDateSeries
   */
  name?: string;
  /**
   *
   * @type {Array<Array<number>>}
   * @memberof SummaryBalanceByDateSeries
   */
  date?: Array<Array<number>>;
}
/**
 *
 * @export
 * @interface SummaryExcludedAccounts
 */
export interface SummaryExcludedAccounts {
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  lastUpdateAttempt?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  fiName?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  acctTitle?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  acctNumAtFI?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  acctId?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  lastUpdate?: string;
  /**
   *
   * @type {number}
   * @memberof SummaryExcludedAccounts
   */
  harvestCode?: number;
  /**
   *
   * @type {string}
   * @memberof SummaryExcludedAccounts
   */
  lastUpdateStatusCode?: string;
  /**
   *
   * @type {number}
   * @memberof SummaryExcludedAccounts
   */
  rc?: number;
}
/**
 *
 * @export
 * @interface SummaryTotal
 */
export interface SummaryTotal {
  /**
   * total change amount
   * @type {string}
   * @memberof SummaryTotal
   */
  chg?: string;
  /**
   * change percent
   * @type {string}
   * @memberof SummaryTotal
   */
  rtn?: string;
  /**
   * set to true if any external account data is not available for starting or ending date, resulting in potentially unusual total values.
   * @type {boolean}
   * @memberof SummaryTotal
   */
  incompleteData?: boolean;
  /**
   *
   * @type {string}
   * @memberof SummaryTotal
   */
  endVal?: string;
  /**
   *
   * @type {string}
   * @memberof SummaryTotal
   */
  startVal?: string;
}
/**
 *
 * @export
 * @interface SystemError
 */
export interface SystemError {
  /**
   *
   * @type {string}
   * @memberof SystemError
   */
  error?: string;
}
/**
 *
 * @export
 * @interface Trade
 */
export interface Trade {
  /**
   * execution identifier for the order
   * @type {string}
   * @memberof Trade
   */
  executionId?: string;
  /**
   * Underlying Symbol
   * @type {string}
   * @memberof Trade
   */
  symbol?: string;
  /**
   * The side of the market of the order.   * B - Buy contract near posted ask price   * S - Sell contract near posted bid price   * X - Option expired
   * @type {string}
   * @memberof Trade
   */
  side?: TradeSideEnum;
  /**
   * Formatted description of the order \"%side% %size% @ %price% on %exchange%\".
   * @type {string}
   * @memberof Trade
   */
  orderDescription?: string;
  /**
   * Time of Status update in format \"YYYYMMDD-hh:mm:ss\".
   * @type {string}
   * @memberof Trade
   */
  tradeTime?: string;
  /**
   * Time of status update in format unix time.
   * @type {number}
   * @memberof Trade
   */
  tradeTimeR?: number;
  /**
   * Quantity of the order
   * @type {string}
   * @memberof Trade
   */
  size?: string;
  /**
   * Average Price
   * @type {string}
   * @memberof Trade
   */
  price?: string;
  /**
   * User defined string used to identify the order. Value is set using \"cOID\" field while placing an order.
   * @type {string}
   * @memberof Trade
   */
  orderRef?: string;
  /**
   * User that submitted order
   * @type {string}
   * @memberof Trade
   */
  submitter?: string;
  /**
   * Exchange or venue of order
   * @type {string}
   * @memberof Trade
   */
  exchange?: string;
  /**
   * Commission of the order
   * @type {number}
   * @memberof Trade
   */
  commission?: number;
  /**
   * Net cost of the order, including contract multiplier and quantity.
   * @type {number}
   * @memberof Trade
   */
  netAmount?: number;
  /**
   * accountCode
   * @type {string}
   * @memberof Trade
   */
  account?: string;
  /**
   * Account Number
   * @type {string}
   * @memberof Trade
   */
  acountCode?: string;
  /**
   * Contracts company name
   * @type {string}
   * @memberof Trade
   */
  companyName?: string;
  /**
   * Format contract name
   * @type {string}
   * @memberof Trade
   */
  contractDescription1?: string;
  /**
   * Asset class
   * @type {string}
   * @memberof Trade
   */
  secType?: string;
  /**
   * IBKR\'s contract identifier
   * @type {string}
   * @memberof Trade
   */
  conid?: string;
  /**
   * conid and exchange. Format supports conid or conid@exchange
   * @type {string}
   * @memberof Trade
   */
  conidex?: string;
  /**
   * Total quantity owned for this contract
   * @type {string}
   * @memberof Trade
   */
  position?: string;
  /**
   * Firm which will settle the trade. For IBExecution customers only.
   * @type {string}
   * @memberof Trade
   */
  clearingId?: string;
  /**
   * Specifies the true beneficiary of the order. For IBExecution customers only.
   * @type {string}
   * @memberof Trade
   */
  clearingName?: string;
  /**
   * If order adds liquidity to the market.
   * @type {number}
   * @memberof Trade
   */
  liquidationTrade?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum TradeSideEnum {
  B = "B",
  S = "S",
  X = "X",
}

/**
 * account transactions
 * @export
 * @interface Transactions
 */
export interface Transactions {
  /**
   * will always be getTransactions
   * @type {string}
   * @memberof Transactions
   */
  id?: string;
  /**
   * same as request
   * @type {string}
   * @memberof Transactions
   */
  currency?: string;
  /**
   * Indicates whether current day and realtime data is included in the result
   * @type {boolean}
   * @memberof Transactions
   */
  includesRealTime?: boolean;
  /**
   * Period start date. Epoch time, GMT
   * @type {number}
   * @memberof Transactions
   */
  from?: number;
  /**
   * Period end date. Epoch time, GMT
   * @type {number}
   * @memberof Transactions
   */
  to?: number;
  /**
   * Sorted by date descending
   * @type {Array<TransactionsTransactions>}
   * @memberof Transactions
   */
  transactions?: Array<TransactionsTransactions>;
}
/**
 *
 * @export
 * @interface TransactionsTransactions
 */
export interface TransactionsTransactions {
  /**
   *
   * @type {string}
   * @memberof TransactionsTransactions
   */
  acctid?: string;
  /**
   *
   * @type {number}
   * @memberof TransactionsTransactions
   */
  conid?: number;
  /**
   * currency code
   * @type {string}
   * @memberof TransactionsTransactions
   */
  cur?: string;
  /**
   * Conversion rate from asset currency to response currency
   * @type {number}
   * @memberof TransactionsTransactions
   */
  fxRate?: number;
  /**
   * Transaction description
   * @type {string}
   * @memberof TransactionsTransactions
   */
  desc?: string;
  /**
   * Date of transaction.  Epoch time, GMT
   * @type {string}
   * @memberof TransactionsTransactions
   */
  date?: string;
  /**
   * Transaction Type Name: Examples: \"Sell\", \"Buy\", \"Corporate Action\", \"Dividend Payment\", \"Transfer\", \"Payment in Lieu\" Dividends and Transfers do not have price and quantity in response
   * @type {string}
   * @memberof TransactionsTransactions
   */
  type?: string;
  /**
   * Not applicable for all transaction types
   * @type {number}
   * @memberof TransactionsTransactions
   */
  qty?: number;
  /**
   * In asset currency. Not be applicable for all transaction types.
   * @type {number}
   * @memberof TransactionsTransactions
   */
  pr?: number;
  /**
   * Raw value, no formatting. Transaction amount. For trades does not include commission. In asset currency
   * @type {number}
   * @memberof TransactionsTransactions
   */
  amt?: number;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountPnlPartitionedGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/account/pnl/partitioned`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
     * @summary Switch Account
     * @param {SetAccount} body account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountPost: async (
      body: SetAccount,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverAccountPost", "body", body);
      const localVarPath = `/iserver/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/iserver/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdLedgerGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("portfolioAccountIdLedgerGet", "accountId", accountId);
      const localVarPath = `/portfolio/{accountId}/ledger`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdMetaGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("portfolioAccountIdMetaGet", "accountId", accountId);
      const localVarPath = `/portfolio/{accountId}/meta`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdSummaryGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("portfolioAccountIdSummaryGet", "accountId", accountId);
      const localVarPath = `/portfolio/{accountId}/summary`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/portfolio/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioSubaccountsGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/portfolio/subaccounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountPnlPartitionedGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20031>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountPnlPartitionedGet(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
     * @summary Switch Account
     * @param {SetAccount} body account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountPost(
      body: SetAccount,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20012>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountPost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20011>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdLedgerGet(
      accountId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20036>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdLedgerGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdMetaGet(
      accountId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdMetaGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdSummaryGet(
      accountId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20035>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdSummaryGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountsGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioSubaccountsGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioSubaccountsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AccountApiFp(configuration);
  return {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountPnlPartitionedGet(
      options?: any
    ): AxiosPromise<InlineResponse20031> {
      return localVarFp
        .iserverAccountPnlPartitionedGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
     * @summary Switch Account
     * @param {SetAccount} body account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountPost(
      body: SetAccount,
      options?: any
    ): AxiosPromise<InlineResponse20012> {
      return localVarFp
        .iserverAccountPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountsGet(options?: any): AxiosPromise<InlineResponse20011> {
      return localVarFp
        .iserverAccountsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdLedgerGet(
      accountId: string,
      options?: any
    ): AxiosPromise<InlineResponse20036> {
      return localVarFp
        .portfolioAccountIdLedgerGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdMetaGet(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<Account>> {
      return localVarFp
        .portfolioAccountIdMetaGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdSummaryGet(
      accountId: string,
      options?: any
    ): AxiosPromise<InlineResponse20035> {
      return localVarFp
        .portfolioAccountIdSummaryGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountsGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .portfolioAccountsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioSubaccountsGet(options?: any): AxiosPromise<Account> {
      return localVarFp
        .portfolioSubaccountsGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
  /**
   * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
   * @summary PnL for the selected account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public iserverAccountPnlPartitionedGet(options?: any) {
    return AccountApiFp(this.configuration)
      .iserverAccountPnlPartitionedGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
   * @summary Switch Account
   * @param {SetAccount} body account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public iserverAccountPost(body: SetAccount, options?: any) {
    return AccountApiFp(this.configuration)
      .iserverAccountPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
   * @summary Brokerage Accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public iserverAccountsGet(options?: any) {
    return AccountApiFp(this.configuration)
      .iserverAccountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
   * @summary Account Ledger
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public portfolioAccountIdLedgerGet(accountId: string, options?: any) {
    return AccountApiFp(this.configuration)
      .portfolioAccountIdLedgerGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Account Information
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public portfolioAccountIdMetaGet(accountId: string, options?: any) {
    return AccountApiFp(this.configuration)
      .portfolioAccountIdMetaGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Account Summary
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public portfolioAccountIdSummaryGet(accountId: string, options?: any) {
    return AccountApiFp(this.configuration)
      .portfolioAccountIdSummaryGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
   * @summary Portfolio Accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public portfolioAccountsGet(options?: any) {
    return AccountApiFp(this.configuration)
      .portfolioAccountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
   * @summary List of Sub-Accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AccountApi
   */
  public portfolioSubaccountsGet(options?: any) {
    return AccountApiFp(this.configuration)
      .portfolioSubaccountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * AlertApi - axios parameter creator
 * @export
 */
export const AlertApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Please note, if alertId is 0, it will activate/deactivate all alerts
     * @summary Activate or deactivate an alert
     * @param {string} accountId account id
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertActivatePost: async (
      accountId: string,
      body: InlineObject3,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdAlertActivatePost",
        "accountId",
        accountId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdAlertActivatePost",
        "body",
        body
      );
      const localVarPath = `/iserver/account/:accountId/alert/activate`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Please be careful, if alertId is 0, it will delete all alerts
     * @summary Delete an alert
     * @param {string} accountId account id
     * @param {string} alertId alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertAlertIdDelete: async (
      accountId: string,
      alertId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdAlertAlertIdDelete",
        "accountId",
        accountId
      );
      // verify required parameter 'alertId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdAlertAlertIdDelete",
        "alertId",
        alertId
      );
      const localVarPath = `/iserver/account/:accountId/alert/:alertId`
        .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
        .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
     * @summary Create or modify alert
     * @param {string} accountId account id
     * @param {AlertRequest} body alert info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertPost: async (
      accountId: string,
      body: AlertRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdAlertPost",
        "accountId",
        accountId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverAccountAccountIdAlertPost", "body", body);
      const localVarPath = `/iserver/account/{accountId}/alert`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The response will contain both active and inactive alerts, but it won\'t have MTA alert
     * @summary Get a list of available alerts
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertsGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdAlertsGet",
        "accountId",
        accountId
      );
      const localVarPath = `/iserver/account/:accountId/alerts`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
     * @summary Get details of an alert
     * @param {string} id alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAlertIdGet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("iserverAccountAlertIdGet", "id", id);
      const localVarPath = `/iserver/account/alert/:id`.replace(
        `{${"id"}}`,
        encodeURIComponent(String(id))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
     * @summary Get MTA alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountMtaGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/iserver/account/mta`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * AlertApi - functional programming interface
 * @export
 */
export const AlertApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = AlertApiAxiosParamCreator(configuration);
  return {
    /**
     * Please note, if alertId is 0, it will activate/deactivate all alerts
     * @summary Activate or deactivate an alert
     * @param {string} accountId account id
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdAlertActivatePost(
      accountId: string,
      body: InlineObject3,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20015>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdAlertActivatePost(
          accountId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Please be careful, if alertId is 0, it will delete all alerts
     * @summary Delete an alert
     * @param {string} accountId account id
     * @param {string} alertId alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdAlertAlertIdDelete(
      accountId: string,
      alertId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20015>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdAlertAlertIdDelete(
          accountId,
          alertId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
     * @summary Create or modify alert
     * @param {string} accountId account id
     * @param {AlertRequest} body alert info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdAlertPost(
      accountId: string,
      body: AlertRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20013>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdAlertPost(
          accountId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The response will contain both active and inactive alerts, but it won\'t have MTA alert
     * @summary Get a list of available alerts
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdAlertsGet(
      accountId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20014>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdAlertsGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
     * @summary Get details of an alert
     * @param {string} id alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAlertIdGet(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAlertIdGet(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
     * @summary Get MTA alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountMtaGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AlertResponse>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountMtaGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * AlertApi - factory interface
 * @export
 */
export const AlertApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = AlertApiFp(configuration);
  return {
    /**
     * Please note, if alertId is 0, it will activate/deactivate all alerts
     * @summary Activate or deactivate an alert
     * @param {string} accountId account id
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertActivatePost(
      accountId: string,
      body: InlineObject3,
      options?: any
    ): AxiosPromise<InlineResponse20015> {
      return localVarFp
        .iserverAccountAccountIdAlertActivatePost(accountId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Please be careful, if alertId is 0, it will delete all alerts
     * @summary Delete an alert
     * @param {string} accountId account id
     * @param {string} alertId alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertAlertIdDelete(
      accountId: string,
      alertId: string,
      options?: any
    ): AxiosPromise<InlineResponse20015> {
      return localVarFp
        .iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
     * @summary Create or modify alert
     * @param {string} accountId account id
     * @param {AlertRequest} body alert info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertPost(
      accountId: string,
      body: AlertRequest,
      options?: any
    ): AxiosPromise<InlineResponse20013> {
      return localVarFp
        .iserverAccountAccountIdAlertPost(accountId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The response will contain both active and inactive alerts, but it won\'t have MTA alert
     * @summary Get a list of available alerts
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdAlertsGet(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<InlineResponse20014>> {
      return localVarFp
        .iserverAccountAccountIdAlertsGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
     * @summary Get details of an alert
     * @param {string} id alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAlertIdGet(
      id: string,
      options?: any
    ): AxiosPromise<AlertResponse> {
      return localVarFp
        .iserverAccountAlertIdGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
     * @summary Get MTA alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountMtaGet(options?: any): AxiosPromise<AlertResponse> {
      return localVarFp
        .iserverAccountMtaGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
export class AlertApi extends BaseAPI {
  /**
   * Please note, if alertId is 0, it will activate/deactivate all alerts
   * @summary Activate or deactivate an alert
   * @param {string} accountId account id
   * @param {InlineObject3} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertApi
   */
  public iserverAccountAccountIdAlertActivatePost(
    accountId: string,
    body: InlineObject3,
    options?: any
  ) {
    return AlertApiFp(this.configuration)
      .iserverAccountAccountIdAlertActivatePost(accountId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Please be careful, if alertId is 0, it will delete all alerts
   * @summary Delete an alert
   * @param {string} accountId account id
   * @param {string} alertId alert id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertApi
   */
  public iserverAccountAccountIdAlertAlertIdDelete(
    accountId: string,
    alertId: string,
    options?: any
  ) {
    return AlertApiFp(this.configuration)
      .iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
   * @summary Create or modify alert
   * @param {string} accountId account id
   * @param {AlertRequest} body alert info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertApi
   */
  public iserverAccountAccountIdAlertPost(
    accountId: string,
    body: AlertRequest,
    options?: any
  ) {
    return AlertApiFp(this.configuration)
      .iserverAccountAccountIdAlertPost(accountId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The response will contain both active and inactive alerts, but it won\'t have MTA alert
   * @summary Get a list of available alerts
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertApi
   */
  public iserverAccountAccountIdAlertsGet(accountId: string, options?: any) {
    return AlertApiFp(this.configuration)
      .iserverAccountAccountIdAlertsGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
   * @summary Get details of an alert
   * @param {string} id alert id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertApi
   */
  public iserverAccountAlertIdGet(id: string, options?: any) {
    return AlertApiFp(this.configuration)
      .iserverAccountAlertIdGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
   * @summary Get MTA alert
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof AlertApi
   */
  public iserverAccountMtaGet(options?: any) {
    return AlertApiFp(this.configuration)
      .iserverAccountMtaGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CCPBetaApi - axios parameter creator
 * @export
 */
export const CCPBetaApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Provides the list of tradeable accounts
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpAccountGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/ccp/account`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
     * @summary Start CCP Session
     * @param {boolean} [compete] Allow competing CCP session to run
     * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
     * @param {string} [mac] Local MAC Address
     * @param {string} [machineId] Local machine ID
     * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpAuthInitPost: async (
      compete?: boolean,
      locale?: string,
      mac?: string,
      machineId?: string,
      username?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ccp/auth/init`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new URLSearchParams();

      if (compete !== undefined) {
        localVarFormParams.set("compete", compete as any);
      }

      if (locale !== undefined) {
        localVarFormParams.set("locale", locale as any);
      }

      if (mac !== undefined) {
        localVarFormParams.set("mac", mac as any);
      }

      if (machineId !== undefined) {
        localVarFormParams.set("machineId", machineId as any);
      }

      if (username !== undefined) {
        localVarFormParams.set("username", username as any);
      }

      localVarHeaderParameter["Content-Type"] =
        "application/x-www-form-urlencoded";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams.toString();

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Session Token Authentication
     * @summary Complete CCP Session
     * @param {InlineObject2} [auth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpAuthResponsePost: async (
      auth?: InlineObject2,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ccp/auth/response`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        auth,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
     * @summary Delete Order
     * @param {string} acct Account Number
     * @param {number} id Order Identifier of original submit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrderDelete: async (
      acct: string,
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'acct' is not null or undefined
      assertParamExists("ccpOrderDelete", "acct", acct);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("ccpOrderDelete", "id", id);
      const localVarPath = `/ccp/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acct !== undefined) {
        localVarQueryParameter["acct"] = acct;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Submits an Order.
     * @summary Submit Order
     * @param {string} acct User Account
     * @param {number} conid Contract identifier from IBKR\&#39;s database.
     * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
     * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
     * @param {number} qty Order Quantity
     * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
     * @param {'sell' | 'buy'} [side] Side
     * @param {number} [price] Order Price; required if order type is limit
     * @param {'IOC' | 'GTC'} [tif] Time in Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrderPost: async (
      acct: string,
      conid: number,
      ccy: "USD" | "GBP" | "EUR",
      exchange: "NYSE" | "CBOE" | "NYMEX",
      qty: number,
      type?: "limit" | "market",
      side?: "sell" | "buy",
      price?: number,
      tif?: "IOC" | "GTC",
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'acct' is not null or undefined
      assertParamExists("ccpOrderPost", "acct", acct);
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("ccpOrderPost", "conid", conid);
      // verify required parameter 'ccy' is not null or undefined
      assertParamExists("ccpOrderPost", "ccy", ccy);
      // verify required parameter 'exchange' is not null or undefined
      assertParamExists("ccpOrderPost", "exchange", exchange);
      // verify required parameter 'qty' is not null or undefined
      assertParamExists("ccpOrderPost", "qty", qty);
      const localVarPath = `/ccp/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acct !== undefined) {
        localVarQueryParameter["acct"] = acct;
      }

      if (conid !== undefined) {
        localVarQueryParameter["conid"] = conid;
      }

      if (ccy !== undefined) {
        localVarQueryParameter["ccy"] = ccy;
      }

      if (exchange !== undefined) {
        localVarQueryParameter["exchange"] = exchange;
      }

      if (qty !== undefined) {
        localVarQueryParameter["qty"] = qty;
      }

      if (type !== undefined) {
        localVarQueryParameter["type"] = type;
      }

      if (side !== undefined) {
        localVarQueryParameter["side"] = side;
      }

      if (price !== undefined) {
        localVarQueryParameter["price"] = price;
      }

      if (tif !== undefined) {
        localVarQueryParameter["tif"] = tif;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
     * @summary Update Order
     * @param {string} acct User Account
     * @param {number} id Order ID to be modified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrderPut: async (
      acct: string,
      id: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'acct' is not null or undefined
      assertParamExists("ccpOrderPut", "acct", acct);
      // verify required parameter 'id' is not null or undefined
      assertParamExists("ccpOrderPut", "id", id);
      const localVarPath = `/ccp/order`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acct !== undefined) {
        localVarQueryParameter["acct"] = acct;
      }

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get status for all orders
     * @summary Order Status
     * @param {string} acct User Account
     * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrdersGet: async (
      acct: string,
      cancelled?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'acct' is not null or undefined
      assertParamExists("ccpOrdersGet", "acct", acct);
      const localVarPath = `/ccp/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (acct !== undefined) {
        localVarQueryParameter["acct"] = acct;
      }

      if (cancelled !== undefined) {
        localVarQueryParameter["cancelled"] = cancelled;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * List of positions
     * @summary Positions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpPositionsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/ccp/positions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
     * @summary CCP Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpStatusGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/ccp/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of Trades, by default, the list is from today midnight to Date.now().
     * @summary Trades
     * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
     * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpTradesGet: async (
      from?: string,
      to?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/ccp/trades`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (from !== undefined) {
        localVarQueryParameter["from"] = from;
      }

      if (to !== undefined) {
        localVarQueryParameter["to"] = to;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CCPBetaApi - functional programming interface
 * @export
 */
export const CCPBetaApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CCPBetaApiAxiosParamCreator(configuration);
  return {
    /**
     * Provides the list of tradeable accounts
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpAccountGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2009>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpAccountGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
     * @summary Start CCP Session
     * @param {boolean} [compete] Allow competing CCP session to run
     * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
     * @param {string} [mac] Local MAC Address
     * @param {string} [machineId] Local machine ID
     * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpAuthInitPost(
      compete?: boolean,
      locale?: string,
      mac?: string,
      machineId?: string,
      username?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2001>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpAuthInitPost(
        compete,
        locale,
        mac,
        machineId,
        username,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Session Token Authentication
     * @summary Complete CCP Session
     * @param {InlineObject2} [auth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpAuthResponsePost(
      auth?: InlineObject2,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2007>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ccpAuthResponsePost(auth, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
     * @summary Delete Order
     * @param {string} acct Account Number
     * @param {number} id Order Identifier of original submit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpOrderDelete(
      acct: string,
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrderDelete(
        acct,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Submits an Order.
     * @summary Submit Order
     * @param {string} acct User Account
     * @param {number} conid Contract identifier from IBKR\&#39;s database.
     * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
     * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
     * @param {number} qty Order Quantity
     * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
     * @param {'sell' | 'buy'} [side] Side
     * @param {number} [price] Order Price; required if order type is limit
     * @param {'IOC' | 'GTC'} [tif] Time in Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpOrderPost(
      acct: string,
      conid: number,
      ccy: "USD" | "GBP" | "EUR",
      exchange: "NYSE" | "CBOE" | "NYMEX",
      qty: number,
      type?: "limit" | "market",
      side?: "sell" | "buy",
      price?: number,
      tif?: "IOC" | "GTC",
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrderPost(
        acct,
        conid,
        ccy,
        exchange,
        qty,
        type,
        side,
        price,
        tif,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
     * @summary Update Order
     * @param {string} acct User Account
     * @param {number} id Order ID to be modified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpOrderPut(
      acct: string,
      id: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrderPut(
        acct,
        id,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get status for all orders
     * @summary Order Status
     * @param {string} acct User Account
     * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpOrdersGet(
      acct: string,
      cancelled?: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20010>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpOrdersGet(
        acct,
        cancelled,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * List of positions
     * @summary Positions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpPositionsGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<PositionData>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpPositionsGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
     * @summary CCP Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpStatusGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2008>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpStatusGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get a list of Trades, by default, the list is from today midnight to Date.now().
     * @summary Trades
     * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
     * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ccpTradesGet(
      from?: string,
      to?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20010>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ccpTradesGet(
        from,
        to,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * CCPBetaApi - factory interface
 * @export
 */
export const CCPBetaApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = CCPBetaApiFp(configuration);
  return {
    /**
     * Provides the list of tradeable accounts
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpAccountGet(options?: any): AxiosPromise<InlineResponse2009> {
      return localVarFp
        .ccpAccountGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
     * @summary Start CCP Session
     * @param {boolean} [compete] Allow competing CCP session to run
     * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
     * @param {string} [mac] Local MAC Address
     * @param {string} [machineId] Local machine ID
     * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpAuthInitPost(
      compete?: boolean,
      locale?: string,
      mac?: string,
      machineId?: string,
      username?: string,
      options?: any
    ): AxiosPromise<InlineResponse2001> {
      return localVarFp
        .ccpAuthInitPost(compete, locale, mac, machineId, username, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Session Token Authentication
     * @summary Complete CCP Session
     * @param {InlineObject2} [auth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpAuthResponsePost(
      auth?: InlineObject2,
      options?: any
    ): AxiosPromise<InlineResponse2007> {
      return localVarFp
        .ccpAuthResponsePost(auth, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
     * @summary Delete Order
     * @param {string} acct Account Number
     * @param {number} id Order Identifier of original submit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrderDelete(
      acct: string,
      id: number,
      options?: any
    ): AxiosPromise<OrderData> {
      return localVarFp
        .ccpOrderDelete(acct, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Submits an Order.
     * @summary Submit Order
     * @param {string} acct User Account
     * @param {number} conid Contract identifier from IBKR\&#39;s database.
     * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
     * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
     * @param {number} qty Order Quantity
     * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
     * @param {'sell' | 'buy'} [side] Side
     * @param {number} [price] Order Price; required if order type is limit
     * @param {'IOC' | 'GTC'} [tif] Time in Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrderPost(
      acct: string,
      conid: number,
      ccy: "USD" | "GBP" | "EUR",
      exchange: "NYSE" | "CBOE" | "NYMEX",
      qty: number,
      type?: "limit" | "market",
      side?: "sell" | "buy",
      price?: number,
      tif?: "IOC" | "GTC",
      options?: any
    ): AxiosPromise<OrderData> {
      return localVarFp
        .ccpOrderPost(
          acct,
          conid,
          ccy,
          exchange,
          qty,
          type,
          side,
          price,
          tif,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
     * @summary Update Order
     * @param {string} acct User Account
     * @param {number} id Order ID to be modified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrderPut(
      acct: string,
      id: number,
      options?: any
    ): AxiosPromise<OrderData> {
      return localVarFp
        .ccpOrderPut(acct, id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get status for all orders
     * @summary Order Status
     * @param {string} acct User Account
     * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpOrdersGet(
      acct: string,
      cancelled?: boolean,
      options?: any
    ): AxiosPromise<InlineResponse20010> {
      return localVarFp
        .ccpOrdersGet(acct, cancelled, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * List of positions
     * @summary Positions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpPositionsGet(options?: any): AxiosPromise<PositionData> {
      return localVarFp
        .ccpPositionsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
     * @summary CCP Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpStatusGet(options?: any): AxiosPromise<InlineResponse2008> {
      return localVarFp
        .ccpStatusGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of Trades, by default, the list is from today midnight to Date.now().
     * @summary Trades
     * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
     * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ccpTradesGet(
      from?: string,
      to?: string,
      options?: any
    ): AxiosPromise<InlineResponse20010> {
      return localVarFp
        .ccpTradesGet(from, to, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CCPBetaApi - object-oriented interface
 * @export
 * @class CCPBetaApi
 * @extends {BaseAPI}
 */
export class CCPBetaApi extends BaseAPI {
  /**
   * Provides the list of tradeable accounts
   * @summary Brokerage Accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpAccountGet(options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpAccountGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
   * @summary Start CCP Session
   * @param {boolean} [compete] Allow competing CCP session to run
   * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
   * @param {string} [mac] Local MAC Address
   * @param {string} [machineId] Local machine ID
   * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpAuthInitPost(
    compete?: boolean,
    locale?: string,
    mac?: string,
    machineId?: string,
    username?: string,
    options?: any
  ) {
    return CCPBetaApiFp(this.configuration)
      .ccpAuthInitPost(compete, locale, mac, machineId, username, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Session Token Authentication
   * @summary Complete CCP Session
   * @param {InlineObject2} [auth]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpAuthResponsePost(auth?: InlineObject2, options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpAuthResponsePost(auth, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
   * @summary Delete Order
   * @param {string} acct Account Number
   * @param {number} id Order Identifier of original submit order
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpOrderDelete(acct: string, id: number, options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpOrderDelete(acct, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Submits an Order.
   * @summary Submit Order
   * @param {string} acct User Account
   * @param {number} conid Contract identifier from IBKR\&#39;s database.
   * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
   * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
   * @param {number} qty Order Quantity
   * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
   * @param {'sell' | 'buy'} [side] Side
   * @param {number} [price] Order Price; required if order type is limit
   * @param {'IOC' | 'GTC'} [tif] Time in Force
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpOrderPost(
    acct: string,
    conid: number,
    ccy: "USD" | "GBP" | "EUR",
    exchange: "NYSE" | "CBOE" | "NYMEX",
    qty: number,
    type?: "limit" | "market",
    side?: "sell" | "buy",
    price?: number,
    tif?: "IOC" | "GTC",
    options?: any
  ) {
    return CCPBetaApiFp(this.configuration)
      .ccpOrderPost(
        acct,
        conid,
        ccy,
        exchange,
        qty,
        type,
        side,
        price,
        tif,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
   * @summary Update Order
   * @param {string} acct User Account
   * @param {number} id Order ID to be modified
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpOrderPut(acct: string, id: number, options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpOrderPut(acct, id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get status for all orders
   * @summary Order Status
   * @param {string} acct User Account
   * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpOrdersGet(acct: string, cancelled?: boolean, options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpOrdersGet(acct, cancelled, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * List of positions
   * @summary Positions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpPositionsGet(options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpPositionsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
   * @summary CCP Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpStatusGet(options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpStatusGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get a list of Trades, by default, the list is from today midnight to Date.now().
   * @summary Trades
   * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
   * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CCPBetaApi
   */
  public ccpTradesGet(from?: string, to?: string, options?: any) {
    return CCPBetaApiFp(this.configuration)
      .ccpTradesGet(from, to, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ContractApi - axios parameter creator
 * @export
 */
export const ContractApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
     * @summary IB Algo Params
     * @param {string} conid IBKR contract identifier
     * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
     * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
     * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverContractConidAlgosGet: async (
      conid: string,
      algos?: string,
      addDescription?: string,
      addParams?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverContractConidAlgosGet", "conid", conid);
      const localVarPath = `/iserver/contract/{conid}/algos`.replace(
        `{${"conid"}}`,
        encodeURIComponent(String(conid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (algos !== undefined) {
        localVarQueryParameter["algos"] = algos;
      }

      if (addDescription !== undefined) {
        localVarQueryParameter["addDescription"] = addDescription;
      }

      if (addParams !== undefined) {
        localVarQueryParameter["addParams"] = addParams;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns trading related rules and info for contract
     * @summary Info and Rules
     * @param {string} conid IBKR contract identifier
     * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverContractConidInfoAndRulesGet: async (
      conid: string,
      isBuy: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverContractConidInfoAndRulesGet", "conid", conid);
      // verify required parameter 'isBuy' is not null or undefined
      assertParamExists("iserverContractConidInfoAndRulesGet", "isBuy", isBuy);
      const localVarPath = `/iserver/contract/{conid}/info-and-rules`.replace(
        `{${"conid"}}`,
        encodeURIComponent(String(conid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (isBuy !== undefined) {
        localVarQueryParameter["isBuy"] = isBuy;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
     * @summary Contract Details
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverContractConidInfoGet: async (
      conid: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverContractConidInfoGet", "conid", conid);
      const localVarPath = `/iserver/contract/{conid}/info`.replace(
        `{${"conid"}}`,
        encodeURIComponent(String(conid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
     * @summary Secdef Info
     * @param {string} conid underlying contract id
     * @param {string} sectype FUT/OPT/WAR/CASH/CFD
     * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
     * @param {string} [exchange] optional, default is SMART
     * @param {string} [strike] optional, only required for OPT/WAR
     * @param {string} [right] C for call, P for put
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverSecdefInfoGet: async (
      conid: string,
      sectype: string,
      month?: string,
      exchange?: string,
      strike?: string,
      right?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverSecdefInfoGet", "conid", conid);
      // verify required parameter 'sectype' is not null or undefined
      assertParamExists("iserverSecdefInfoGet", "sectype", sectype);
      const localVarPath = `/iserver/secdef/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (conid !== undefined) {
        localVarQueryParameter["conid"] = conid;
      }

      if (sectype !== undefined) {
        localVarQueryParameter["sectype"] = sectype;
      }

      if (month !== undefined) {
        localVarQueryParameter["month"] = month;
      }

      if (exchange !== undefined) {
        localVarQueryParameter["exchange"] = exchange;
      }

      if (strike !== undefined) {
        localVarQueryParameter["strike"] = strike;
      }

      if (right !== undefined) {
        localVarQueryParameter["right"] = right;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
     * @summary Search by Symbol or Name
     * @param {InlineObject8} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverSecdefSearchPost: async (
      symbol: InlineObject8,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'symbol' is not null or undefined
      assertParamExists("iserverSecdefSearchPost", "symbol", symbol);
      const localVarPath = `/iserver/secdef/search`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        symbol,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
     * @summary Search Strikes
     * @param {string} conid contract id of the underlying contract
     * @param {string} sectype OPT/WAR
     * @param {string} month contract month
     * @param {string} [exchange] optional, default is SMART
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverSecdefStrikesGet: async (
      conid: string,
      sectype: string,
      month: string,
      exchange?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverSecdefStrikesGet", "conid", conid);
      // verify required parameter 'sectype' is not null or undefined
      assertParamExists("iserverSecdefStrikesGet", "sectype", sectype);
      // verify required parameter 'month' is not null or undefined
      assertParamExists("iserverSecdefStrikesGet", "month", month);
      const localVarPath = `/iserver/secdef/strikes`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (conid !== undefined) {
        localVarQueryParameter["conid"] = conid;
      }

      if (sectype !== undefined) {
        localVarQueryParameter["sectype"] = sectype;
      }

      if (month !== undefined) {
        localVarQueryParameter["month"] = month;
      }

      if (exchange !== undefined) {
        localVarQueryParameter["exchange"] = exchange;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of non-expired future contracts for given symbol(s)
     * @summary Security Futures by Symbol
     * @param {string} symbols list of case-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvFuturesGet: async (
      symbols: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'symbols' is not null or undefined
      assertParamExists("trsrvFuturesGet", "symbols", symbols);
      const localVarPath = `/trsrv/futures`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (symbols !== undefined) {
        localVarQueryParameter["symbols"] = symbols;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of security definitions for the given conids
     * @summary Secdef by Conid
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvSecdefPost: async (
      body: InlineObject9,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("trsrvSecdefPost", "body", body);
      const localVarPath = `/trsrv/secdef`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the trading schedule up to a month for the requested contract
     * @summary Get trading schedule for symbol
     * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
     * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
     * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
     * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvSecdefScheduleGet: async (
      assetClass: string,
      symbol: string,
      exchange?: string,
      exchangeFilter?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'assetClass' is not null or undefined
      assertParamExists("trsrvSecdefScheduleGet", "assetClass", assetClass);
      // verify required parameter 'symbol' is not null or undefined
      assertParamExists("trsrvSecdefScheduleGet", "symbol", symbol);
      const localVarPath = `/trsrv/secdef/schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (assetClass !== undefined) {
        localVarQueryParameter["assetClass"] = assetClass;
      }

      if (symbol !== undefined) {
        localVarQueryParameter["symbol"] = symbol;
      }

      if (exchange !== undefined) {
        localVarQueryParameter["exchange"] = exchange;
      }

      if (exchangeFilter !== undefined) {
        localVarQueryParameter["exchangeFilter"] = exchangeFilter;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns an object contains all stock contracts for given symbol(s)
     * @summary Security Stocks by Symbol
     * @param {string} symbols list of upper-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvStocksGet: async (
      symbols: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'symbols' is not null or undefined
      assertParamExists("trsrvStocksGet", "symbols", symbols);
      const localVarPath = `/trsrv/stocks`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (symbols !== undefined) {
        localVarQueryParameter["symbols"] = symbols;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ContractApi - functional programming interface
 * @export
 */
export const ContractApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ContractApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
     * @summary IB Algo Params
     * @param {string} conid IBKR contract identifier
     * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
     * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
     * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverContractConidAlgosGet(
      conid: string,
      algos?: string,
      addDescription?: string,
      addParams?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20027>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverContractConidAlgosGet(
          conid,
          algos,
          addDescription,
          addParams,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns trading related rules and info for contract
     * @summary Info and Rules
     * @param {string} conid IBKR contract identifier
     * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverContractConidInfoAndRulesGet(
      conid: string,
      isBuy: boolean,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20028>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverContractConidInfoAndRulesGet(
          conid,
          isBuy,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
     * @summary Contract Details
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverContractConidInfoGet(
      conid: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverContractConidInfoGet(
          conid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
     * @summary Secdef Info
     * @param {string} conid underlying contract id
     * @param {string} sectype FUT/OPT/WAR/CASH/CFD
     * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
     * @param {string} [exchange] optional, default is SMART
     * @param {string} [strike] optional, only required for OPT/WAR
     * @param {string} [right] C for call, P for put
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverSecdefInfoGet(
      conid: string,
      sectype: string,
      month?: string,
      exchange?: string,
      strike?: string,
      right?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverSecdefInfoGet(
          conid,
          sectype,
          month,
          exchange,
          strike,
          right,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
     * @summary Search by Symbol or Name
     * @param {InlineObject8} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverSecdefSearchPost(
      symbol: InlineObject8,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20025>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverSecdefSearchPost(
          symbol,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
     * @summary Search Strikes
     * @param {string} conid contract id of the underlying contract
     * @param {string} sectype OPT/WAR
     * @param {string} month contract month
     * @param {string} [exchange] optional, default is SMART
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverSecdefStrikesGet(
      conid: string,
      sectype: string,
      month: string,
      exchange?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20026>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverSecdefStrikesGet(
          conid,
          sectype,
          month,
          exchange,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of non-expired future contracts for given symbol(s)
     * @summary Security Futures by Symbol
     * @param {string} symbols list of case-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trsrvFuturesGet(
      symbols: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20033>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvFuturesGet(
        symbols,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of security definitions for the given conids
     * @summary Secdef by Conid
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trsrvSecdefPost(
      body: InlineObject9,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvSecdefPost(
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns the trading schedule up to a month for the requested contract
     * @summary Get trading schedule for symbol
     * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
     * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
     * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
     * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trsrvSecdefScheduleGet(
      assetClass: string,
      symbol: string,
      exchange?: string,
      exchangeFilter?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20032>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.trsrvSecdefScheduleGet(
          assetClass,
          symbol,
          exchange,
          exchangeFilter,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns an object contains all stock contracts for given symbol(s)
     * @summary Security Stocks by Symbol
     * @param {string} symbols list of upper-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async trsrvStocksGet(
      symbols: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20034>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.trsrvStocksGet(
        symbols,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ContractApi - factory interface
 * @export
 */
export const ContractApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ContractApiFp(configuration);
  return {
    /**
     * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
     * @summary IB Algo Params
     * @param {string} conid IBKR contract identifier
     * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
     * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
     * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverContractConidAlgosGet(
      conid: string,
      algos?: string,
      addDescription?: string,
      addParams?: string,
      options?: any
    ): AxiosPromise<Array<InlineResponse20027>> {
      return localVarFp
        .iserverContractConidAlgosGet(
          conid,
          algos,
          addDescription,
          addParams,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns trading related rules and info for contract
     * @summary Info and Rules
     * @param {string} conid IBKR contract identifier
     * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverContractConidInfoAndRulesGet(
      conid: string,
      isBuy: boolean,
      options?: any
    ): AxiosPromise<InlineResponse20028> {
      return localVarFp
        .iserverContractConidInfoAndRulesGet(conid, isBuy, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
     * @summary Contract Details
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverContractConidInfoGet(
      conid: string,
      options?: any
    ): AxiosPromise<Contract> {
      return localVarFp
        .iserverContractConidInfoGet(conid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
     * @summary Secdef Info
     * @param {string} conid underlying contract id
     * @param {string} sectype FUT/OPT/WAR/CASH/CFD
     * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
     * @param {string} [exchange] optional, default is SMART
     * @param {string} [strike] optional, only required for OPT/WAR
     * @param {string} [right] C for call, P for put
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverSecdefInfoGet(
      conid: string,
      sectype: string,
      month?: string,
      exchange?: string,
      strike?: string,
      right?: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .iserverSecdefInfoGet(
          conid,
          sectype,
          month,
          exchange,
          strike,
          right,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
     * @summary Search by Symbol or Name
     * @param {InlineObject8} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverSecdefSearchPost(
      symbol: InlineObject8,
      options?: any
    ): AxiosPromise<Array<InlineResponse20025>> {
      return localVarFp
        .iserverSecdefSearchPost(symbol, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
     * @summary Search Strikes
     * @param {string} conid contract id of the underlying contract
     * @param {string} sectype OPT/WAR
     * @param {string} month contract month
     * @param {string} [exchange] optional, default is SMART
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverSecdefStrikesGet(
      conid: string,
      sectype: string,
      month: string,
      exchange?: string,
      options?: any
    ): AxiosPromise<InlineResponse20026> {
      return localVarFp
        .iserverSecdefStrikesGet(conid, sectype, month, exchange, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of non-expired future contracts for given symbol(s)
     * @summary Security Futures by Symbol
     * @param {string} symbols list of case-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvFuturesGet(
      symbols: string,
      options?: any
    ): AxiosPromise<InlineResponse20033> {
      return localVarFp
        .trsrvFuturesGet(symbols, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of security definitions for the given conids
     * @summary Secdef by Conid
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvSecdefPost(
      body: InlineObject9,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .trsrvSecdefPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the trading schedule up to a month for the requested contract
     * @summary Get trading schedule for symbol
     * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
     * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
     * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
     * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvSecdefScheduleGet(
      assetClass: string,
      symbol: string,
      exchange?: string,
      exchangeFilter?: string,
      options?: any
    ): AxiosPromise<InlineResponse20032> {
      return localVarFp
        .trsrvSecdefScheduleGet(
          assetClass,
          symbol,
          exchange,
          exchangeFilter,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns an object contains all stock contracts for given symbol(s)
     * @summary Security Stocks by Symbol
     * @param {string} symbols list of upper-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    trsrvStocksGet(
      symbols: string,
      options?: any
    ): AxiosPromise<InlineResponse20034> {
      return localVarFp
        .trsrvStocksGet(symbols, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
export class ContractApi extends BaseAPI {
  /**
   * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
   * @summary IB Algo Params
   * @param {string} conid IBKR contract identifier
   * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
   * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
   * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public iserverContractConidAlgosGet(
    conid: string,
    algos?: string,
    addDescription?: string,
    addParams?: string,
    options?: any
  ) {
    return ContractApiFp(this.configuration)
      .iserverContractConidAlgosGet(
        conid,
        algos,
        addDescription,
        addParams,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns trading related rules and info for contract
   * @summary Info and Rules
   * @param {string} conid IBKR contract identifier
   * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public iserverContractConidInfoAndRulesGet(
    conid: string,
    isBuy: boolean,
    options?: any
  ) {
    return ContractApiFp(this.configuration)
      .iserverContractConidInfoAndRulesGet(conid, isBuy, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
   * @summary Contract Details
   * @param {string} conid contract id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public iserverContractConidInfoGet(conid: string, options?: any) {
    return ContractApiFp(this.configuration)
      .iserverContractConidInfoGet(conid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
   * @summary Secdef Info
   * @param {string} conid underlying contract id
   * @param {string} sectype FUT/OPT/WAR/CASH/CFD
   * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
   * @param {string} [exchange] optional, default is SMART
   * @param {string} [strike] optional, only required for OPT/WAR
   * @param {string} [right] C for call, P for put
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public iserverSecdefInfoGet(
    conid: string,
    sectype: string,
    month?: string,
    exchange?: string,
    strike?: string,
    right?: string,
    options?: any
  ) {
    return ContractApiFp(this.configuration)
      .iserverSecdefInfoGet(
        conid,
        sectype,
        month,
        exchange,
        strike,
        right,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
   * @summary Search by Symbol or Name
   * @param {InlineObject8} symbol
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public iserverSecdefSearchPost(symbol: InlineObject8, options?: any) {
    return ContractApiFp(this.configuration)
      .iserverSecdefSearchPost(symbol, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
   * @summary Search Strikes
   * @param {string} conid contract id of the underlying contract
   * @param {string} sectype OPT/WAR
   * @param {string} month contract month
   * @param {string} [exchange] optional, default is SMART
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public iserverSecdefStrikesGet(
    conid: string,
    sectype: string,
    month: string,
    exchange?: string,
    options?: any
  ) {
    return ContractApiFp(this.configuration)
      .iserverSecdefStrikesGet(conid, sectype, month, exchange, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of non-expired future contracts for given symbol(s)
   * @summary Security Futures by Symbol
   * @param {string} symbols list of case-sensitive symbols separated by comma
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public trsrvFuturesGet(symbols: string, options?: any) {
    return ContractApiFp(this.configuration)
      .trsrvFuturesGet(symbols, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of security definitions for the given conids
   * @summary Secdef by Conid
   * @param {InlineObject9} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public trsrvSecdefPost(body: InlineObject9, options?: any) {
    return ContractApiFp(this.configuration)
      .trsrvSecdefPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the trading schedule up to a month for the requested contract
   * @summary Get trading schedule for symbol
   * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
   * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
   * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
   * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public trsrvSecdefScheduleGet(
    assetClass: string,
    symbol: string,
    exchange?: string,
    exchangeFilter?: string,
    options?: any
  ) {
    return ContractApiFp(this.configuration)
      .trsrvSecdefScheduleGet(
        assetClass,
        symbol,
        exchange,
        exchangeFilter,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns an object contains all stock contracts for given symbol(s)
   * @summary Security Stocks by Symbol
   * @param {string} symbols list of upper-sensitive symbols separated by comma
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ContractApi
   */
  public trsrvStocksGet(symbols: string, options?: any) {
    return ContractApiFp(this.configuration)
      .trsrvStocksGet(symbols, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * FYIApi - axios parameter creator
 * @export
 */
export const FYIApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     *
     * @summary Delete a device
     * @param {string} deviceId device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsDeviceIdDelete: async (
      deviceId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'deviceId' is not null or undefined
      assertParamExists(
        "fyiDeliveryoptionsDeviceIdDelete",
        "deviceId",
        deviceId
      );
      const localVarPath = `/fyi/deliveryoptions/{deviceId}`.replace(
        `{${"deviceId"}}`,
        encodeURIComponent(String(deviceId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Enable/Disable device option
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsDevicePost: async (
      body: InlineObject1,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("fyiDeliveryoptionsDevicePost", "body", body);
      const localVarPath = `/fyi/deliveryoptions/device`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Enable/Disable email option
     * @param {string} enabled true/false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsEmailPut: async (
      enabled: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'enabled' is not null or undefined
      assertParamExists("fyiDeliveryoptionsEmailPut", "enabled", enabled);
      const localVarPath = `/fyi/deliveryoptions/email`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (enabled !== undefined) {
        localVarQueryParameter["enabled"] = enabled;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * options for sending fyis to email and other devices
     * @summary Get delivery options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/fyi/deliveryoptions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get disclaimer for a certain kind of fyi
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDisclaimerTypecodeGet: async (
      typecode: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'typecode' is not null or undefined
      assertParamExists("fyiDisclaimerTypecodeGet", "typecode", typecode);
      const localVarPath = `/fyi/disclaimer/{typecode}`.replace(
        `{${"typecode"}}`,
        encodeURIComponent(String(typecode))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Mark disclaimer read
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDisclaimerTypecodePut: async (
      typecode: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'typecode' is not null or undefined
      assertParamExists("fyiDisclaimerTypecodePut", "typecode", typecode);
      const localVarPath = `/fyi/disclaimer/{typecode}`.replace(
        `{${"typecode"}}`,
        encodeURIComponent(String(typecode))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of notifications
     * @param {string} max max number of fyis in response
     * @param {string} [exclude] if set, don\&#39;t set include
     * @param {string} [include] if set, don\&#39;t set exclude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiNotificationsGet: async (
      max: string,
      exclude?: string,
      include?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'max' is not null or undefined
      assertParamExists("fyiNotificationsGet", "max", max);
      const localVarPath = `/fyi/notifications`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (exclude !== undefined) {
        localVarQueryParameter["exclude"] = exclude;
      }

      if (include !== undefined) {
        localVarQueryParameter["include"] = include;
      }

      if (max !== undefined) {
        localVarQueryParameter["max"] = max;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get more notifications based on a certain one
     * @param {string} id id of last notification in the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiNotificationsMoreGet: async (
      id: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists("fyiNotificationsMoreGet", "id", id);
      const localVarPath = `/fyi/notifications/more`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter["id"] = id;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get a list of notifications
     * @param {string} notificationId mark a notification read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiNotificationsNotificationIdPut: async (
      notificationId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'notificationId' is not null or undefined
      assertParamExists(
        "fyiNotificationsNotificationIdPut",
        "notificationId",
        notificationId
      );
      const localVarPath = `/fyi/notifications/{notificationId}`.replace(
        `{${"notificationId"}}`,
        encodeURIComponent(String(notificationId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "PUT",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Return the current choices of subscriptions, we can toggle the option
     * @summary Get a list of subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiSettingsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/fyi/settings`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Configure which typecode you would like to enable/disable.
     * @summary Enable/Disable certain subscription
     * @param {string} typecode fyi code
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiSettingsTypecodePost: async (
      typecode: string,
      body: InlineObject,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'typecode' is not null or undefined
      assertParamExists("fyiSettingsTypecodePost", "typecode", typecode);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("fyiSettingsTypecodePost", "body", body);
      const localVarPath = `/fyi/settings/{typecode}`.replace(
        `{${"typecode"}}`,
        encodeURIComponent(String(typecode))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns the total number of unread fyis
     * @summary Get unread number of fyis. The HTTP method POST is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiUnreadnumberGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/fyi/unreadnumber`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * FYIApi - functional programming interface
 * @export
 */
export const FYIApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = FYIApiAxiosParamCreator(configuration);
  return {
    /**
     *
     * @summary Delete a device
     * @param {string} deviceId device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiDeliveryoptionsDeviceIdDelete(
      deviceId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiDeliveryoptionsDeviceIdDelete(
          deviceId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Enable/Disable device option
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiDeliveryoptionsDevicePost(
      body: InlineObject1,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiDeliveryoptionsDevicePost(
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Enable/Disable email option
     * @param {string} enabled true/false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiDeliveryoptionsEmailPut(
      enabled: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiDeliveryoptionsEmailPut(
          enabled,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * options for sending fyis to email and other devices
     * @summary Get delivery options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiDeliveryoptionsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2006>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiDeliveryoptionsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get disclaimer for a certain kind of fyi
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiDisclaimerTypecodeGet(
      typecode: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2004>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiDisclaimerTypecodeGet(
          typecode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Mark disclaimer read
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiDisclaimerTypecodePut(
      typecode: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2005>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiDisclaimerTypecodePut(
          typecode,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a list of notifications
     * @param {string} max max number of fyis in response
     * @param {string} [exclude] if set, don\&#39;t set include
     * @param {string} [include] if set, don\&#39;t set exclude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiNotificationsGet(
      max: string,
      exclude?: string,
      include?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiNotificationsGet(
          max,
          exclude,
          include,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get more notifications based on a certain one
     * @param {string} id id of last notification in the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiNotificationsMoreGet(
      id: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiNotificationsMoreGet(id, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Get a list of notifications
     * @param {string} notificationId mark a notification read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiNotificationsNotificationIdPut(
      notificationId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiNotificationsNotificationIdPut(
          notificationId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Return the current choices of subscriptions, we can toggle the option
     * @summary Get a list of subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiSettingsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse2003>>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fyiSettingsGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Configure which typecode you would like to enable/disable.
     * @summary Enable/Disable certain subscription
     * @param {string} typecode fyi code
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiSettingsTypecodePost(
      typecode: string,
      body: InlineObject,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiSettingsTypecodePost(
          typecode,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns the total number of unread fyis
     * @summary Get unread number of fyis. The HTTP method POST is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fyiUnreadnumberGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse2002>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.fyiUnreadnumberGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * FYIApi - factory interface
 * @export
 */
export const FYIApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = FYIApiFp(configuration);
  return {
    /**
     *
     * @summary Delete a device
     * @param {string} deviceId device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsDeviceIdDelete(
      deviceId: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .fyiDeliveryoptionsDeviceIdDelete(deviceId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Enable/Disable device option
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsDevicePost(
      body: InlineObject1,
      options?: any
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .fyiDeliveryoptionsDevicePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Enable/Disable email option
     * @param {string} enabled true/false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsEmailPut(
      enabled: string,
      options?: any
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .fyiDeliveryoptionsEmailPut(enabled, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * options for sending fyis to email and other devices
     * @summary Get delivery options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDeliveryoptionsGet(options?: any): AxiosPromise<InlineResponse2006> {
      return localVarFp
        .fyiDeliveryoptionsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get disclaimer for a certain kind of fyi
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDisclaimerTypecodeGet(
      typecode: string,
      options?: any
    ): AxiosPromise<InlineResponse2004> {
      return localVarFp
        .fyiDisclaimerTypecodeGet(typecode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Mark disclaimer read
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiDisclaimerTypecodePut(
      typecode: string,
      options?: any
    ): AxiosPromise<InlineResponse2005> {
      return localVarFp
        .fyiDisclaimerTypecodePut(typecode, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a list of notifications
     * @param {string} max max number of fyis in response
     * @param {string} [exclude] if set, don\&#39;t set include
     * @param {string} [include] if set, don\&#39;t set exclude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiNotificationsGet(
      max: string,
      exclude?: string,
      include?: string,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .fyiNotificationsGet(max, exclude, include, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get more notifications based on a certain one
     * @param {string} id id of last notification in the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiNotificationsMoreGet(
      id: string,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .fyiNotificationsMoreGet(id, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get a list of notifications
     * @param {string} notificationId mark a notification read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiNotificationsNotificationIdPut(
      notificationId: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .fyiNotificationsNotificationIdPut(notificationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Return the current choices of subscriptions, we can toggle the option
     * @summary Get a list of subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiSettingsGet(options?: any): AxiosPromise<Array<InlineResponse2003>> {
      return localVarFp
        .fyiSettingsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Configure which typecode you would like to enable/disable.
     * @summary Enable/Disable certain subscription
     * @param {string} typecode fyi code
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiSettingsTypecodePost(
      typecode: string,
      body: InlineObject,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .fyiSettingsTypecodePost(typecode, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns the total number of unread fyis
     * @summary Get unread number of fyis. The HTTP method POST is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fyiUnreadnumberGet(options?: any): AxiosPromise<InlineResponse2002> {
      return localVarFp
        .fyiUnreadnumberGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * FYIApi - object-oriented interface
 * @export
 * @class FYIApi
 * @extends {BaseAPI}
 */
export class FYIApi extends BaseAPI {
  /**
   *
   * @summary Delete a device
   * @param {string} deviceId device ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiDeliveryoptionsDeviceIdDelete(deviceId: string, options?: any) {
    return FYIApiFp(this.configuration)
      .fyiDeliveryoptionsDeviceIdDelete(deviceId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Enable/Disable device option
   * @param {InlineObject1} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiDeliveryoptionsDevicePost(body: InlineObject1, options?: any) {
    return FYIApiFp(this.configuration)
      .fyiDeliveryoptionsDevicePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Enable/Disable email option
   * @param {string} enabled true/false
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiDeliveryoptionsEmailPut(enabled: string, options?: any) {
    return FYIApiFp(this.configuration)
      .fyiDeliveryoptionsEmailPut(enabled, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * options for sending fyis to email and other devices
   * @summary Get delivery options
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiDeliveryoptionsGet(options?: any) {
    return FYIApiFp(this.configuration)
      .fyiDeliveryoptionsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get disclaimer for a certain kind of fyi
   * @param {string} typecode fyi code, for example --M8, EA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiDisclaimerTypecodeGet(typecode: string, options?: any) {
    return FYIApiFp(this.configuration)
      .fyiDisclaimerTypecodeGet(typecode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Mark disclaimer read
   * @param {string} typecode fyi code, for example --M8, EA
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiDisclaimerTypecodePut(typecode: string, options?: any) {
    return FYIApiFp(this.configuration)
      .fyiDisclaimerTypecodePut(typecode, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a list of notifications
   * @param {string} max max number of fyis in response
   * @param {string} [exclude] if set, don\&#39;t set include
   * @param {string} [include] if set, don\&#39;t set exclude
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiNotificationsGet(
    max: string,
    exclude?: string,
    include?: string,
    options?: any
  ) {
    return FYIApiFp(this.configuration)
      .fyiNotificationsGet(max, exclude, include, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get more notifications based on a certain one
   * @param {string} id id of last notification in the list
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiNotificationsMoreGet(id: string, options?: any) {
    return FYIApiFp(this.configuration)
      .fyiNotificationsMoreGet(id, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get a list of notifications
   * @param {string} notificationId mark a notification read
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiNotificationsNotificationIdPut(
    notificationId: string,
    options?: any
  ) {
    return FYIApiFp(this.configuration)
      .fyiNotificationsNotificationIdPut(notificationId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Return the current choices of subscriptions, we can toggle the option
   * @summary Get a list of subscriptions
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiSettingsGet(options?: any) {
    return FYIApiFp(this.configuration)
      .fyiSettingsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Configure which typecode you would like to enable/disable.
   * @summary Enable/Disable certain subscription
   * @param {string} typecode fyi code
   * @param {InlineObject} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiSettingsTypecodePost(
    typecode: string,
    body: InlineObject,
    options?: any
  ) {
    return FYIApiFp(this.configuration)
      .fyiSettingsTypecodePost(typecode, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns the total number of unread fyis
   * @summary Get unread number of fyis. The HTTP method POST is also supported.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof FYIApi
   */
  public fyiUnreadnumberGet(options?: any) {
    return FYIApiFp(this.configuration)
      .fyiUnreadnumberGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * IBCustApi - axios parameter creator
 * @export
 */
export const IBCustApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns Applicant Id with all owner related entities
     * @summary IBCust Entity Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcustEntityInfoGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/ibcust/entity/info`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * IBCustApi - functional programming interface
 * @export
 */
export const IBCustApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = IBCustApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns Applicant Id with all owner related entities
     * @summary IBCust Entity Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ibcustEntityInfoGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20039>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.ibcustEntityInfoGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * IBCustApi - factory interface
 * @export
 */
export const IBCustApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = IBCustApiFp(configuration);
  return {
    /**
     * Returns Applicant Id with all owner related entities
     * @summary IBCust Entity Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ibcustEntityInfoGet(
      options?: any
    ): AxiosPromise<Array<InlineResponse20039>> {
      return localVarFp
        .ibcustEntityInfoGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * IBCustApi - object-oriented interface
 * @export
 * @class IBCustApi
 * @extends {BaseAPI}
 */
export class IBCustApi extends BaseAPI {
  /**
   * Returns Applicant Id with all owner related entities
   * @summary IBCust Entity Info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof IBCustApi
   */
  public ibcustEntityInfoGet(options?: any) {
    return IBCustApiFp(this.configuration)
      .ibcustEntityInfoGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * MarketDataApi - axios parameter creator
 * @export
 */
export const MarketDataApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
     * @summary Market Data Cancel (Single)
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataConidUnsubscribeGet: async (
      conid: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverMarketdataConidUnsubscribeGet", "conid", conid);
      const localVarPath = `/iserver/marketdata/{conid}/unsubscribe`.replace(
        `{${"conid"}}`,
        encodeURIComponent(String(conid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
     * @summary Market Data History
     * @param {string} conid contract id
     * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
     * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
     * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
     * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataHistoryGet: async (
      conid: string,
      period: string,
      exchange?: string,
      bar?: string,
      outsideRth?: boolean,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("iserverMarketdataHistoryGet", "conid", conid);
      // verify required parameter 'period' is not null or undefined
      assertParamExists("iserverMarketdataHistoryGet", "period", period);
      const localVarPath = `/iserver/marketdata/history`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (conid !== undefined) {
        localVarQueryParameter["conid"] = conid;
      }

      if (exchange !== undefined) {
        localVarQueryParameter["exchange"] = exchange;
      }

      if (period !== undefined) {
        localVarQueryParameter["period"] = period;
      }

      if (bar !== undefined) {
        localVarQueryParameter["bar"] = bar;
      }

      if (outsideRth !== undefined) {
        localVarQueryParameter["outsideRth"] = outsideRth;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Market Data
     * @param {string} conids list of conids separated by comma
     * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
     * @param {string} [fields] list of fields separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataSnapshotGet: async (
      conids: string,
      since?: number,
      fields?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conids' is not null or undefined
      assertParamExists("iserverMarketdataSnapshotGet", "conids", conids);
      const localVarPath = `/iserver/marketdata/snapshot`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (conids !== undefined) {
        localVarQueryParameter["conids"] = conids;
      }

      if (since !== undefined) {
        localVarQueryParameter["since"] = since;
      }

      if (fields !== undefined) {
        localVarQueryParameter["fields"] = fields;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
     * @summary Market Data Cancel (All)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataUnsubscribeallGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/marketdata/unsubscribeall`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * MarketDataApi - functional programming interface
 * @export
 */
export const MarketDataApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    MarketDataApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
     * @summary Market Data Cancel (Single)
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverMarketdataConidUnsubscribeGet(
      conid: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20023>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverMarketdataConidUnsubscribeGet(
          conid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
     * @summary Market Data History
     * @param {string} conid contract id
     * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
     * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
     * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
     * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverMarketdataHistoryGet(
      conid: string,
      period: string,
      exchange?: string,
      bar?: string,
      outsideRth?: boolean,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<HistoryData>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverMarketdataHistoryGet(
          conid,
          period,
          exchange,
          bar,
          outsideRth,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Market Data
     * @param {string} conids list of conids separated by comma
     * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
     * @param {string} [fields] list of fields separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverMarketdataSnapshotGet(
      conids: string,
      since?: number,
      fields?: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20022>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverMarketdataSnapshotGet(
          conids,
          since,
          fields,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
     * @summary Market Data Cancel (All)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverMarketdataUnsubscribeallGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20024>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverMarketdataUnsubscribeallGet(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * MarketDataApi - factory interface
 * @export
 */
export const MarketDataApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = MarketDataApiFp(configuration);
  return {
    /**
     * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
     * @summary Market Data Cancel (Single)
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataConidUnsubscribeGet(
      conid: string,
      options?: any
    ): AxiosPromise<InlineResponse20023> {
      return localVarFp
        .iserverMarketdataConidUnsubscribeGet(conid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
     * @summary Market Data History
     * @param {string} conid contract id
     * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
     * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
     * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
     * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataHistoryGet(
      conid: string,
      period: string,
      exchange?: string,
      bar?: string,
      outsideRth?: boolean,
      options?: any
    ): AxiosPromise<HistoryData> {
      return localVarFp
        .iserverMarketdataHistoryGet(
          conid,
          period,
          exchange,
          bar,
          outsideRth,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Market Data
     * @param {string} conids list of conids separated by comma
     * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
     * @param {string} [fields] list of fields separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataSnapshotGet(
      conids: string,
      since?: number,
      fields?: string,
      options?: any
    ): AxiosPromise<Array<InlineResponse20022>> {
      return localVarFp
        .iserverMarketdataSnapshotGet(conids, since, fields, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
     * @summary Market Data Cancel (All)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverMarketdataUnsubscribeallGet(
      options?: any
    ): AxiosPromise<InlineResponse20024> {
      return localVarFp
        .iserverMarketdataUnsubscribeallGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * MarketDataApi - object-oriented interface
 * @export
 * @class MarketDataApi
 * @extends {BaseAPI}
 */
export class MarketDataApi extends BaseAPI {
  /**
   * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
   * @summary Market Data Cancel (Single)
   * @param {string} conid contract id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataApi
   */
  public iserverMarketdataConidUnsubscribeGet(conid: string, options?: any) {
    return MarketDataApiFp(this.configuration)
      .iserverMarketdataConidUnsubscribeGet(conid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
   * @summary Market Data History
   * @param {string} conid contract id
   * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
   * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
   * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
   * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataApi
   */
  public iserverMarketdataHistoryGet(
    conid: string,
    period: string,
    exchange?: string,
    bar?: string,
    outsideRth?: boolean,
    options?: any
  ) {
    return MarketDataApiFp(this.configuration)
      .iserverMarketdataHistoryGet(
        conid,
        period,
        exchange,
        bar,
        outsideRth,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
   * @summary Market Data
   * @param {string} conids list of conids separated by comma
   * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
   * @param {string} [fields] list of fields separated by comma
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataApi
   */
  public iserverMarketdataSnapshotGet(
    conids: string,
    since?: number,
    fields?: string,
    options?: any
  ) {
    return MarketDataApiFp(this.configuration)
      .iserverMarketdataSnapshotGet(conids, since, fields, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
   * @summary Market Data Cancel (All)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof MarketDataApi
   */
  public iserverMarketdataUnsubscribeallGet(options?: any) {
    return MarketDataApiFp(this.configuration)
      .iserverMarketdataUnsubscribeallGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
     * @summary Cancel Order
     * @param {string} accountId account id, or fa group if deleting a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderOrderIdDelete: async (
      accountId: string,
      orderId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderOrderIdDelete",
        "accountId",
        accountId
      );
      // verify required parameter 'orderId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderOrderIdDelete",
        "orderId",
        orderId
      );
      const localVarPath = `/iserver/account/{accountId}/order/{orderId}`
        .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
        .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "DELETE",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
     * @summary Modify Order
     * @param {string} accountId account id, or fa group if modifying a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {ModifyOrder} body modify-order request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderOrderIdPost: async (
      accountId: string,
      orderId: string,
      body: ModifyOrder,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderOrderIdPost",
        "accountId",
        accountId
      );
      // verify required parameter 'orderId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderOrderIdPost",
        "orderId",
        orderId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderOrderIdPost",
        "body",
        body
      );
      const localVarPath = `/iserver/account/{accountId}/order/{orderId}`
        .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
        .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
     * @summary Place Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderPost: async (
      accountId: string,
      body: OrderRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderPost",
        "accountId",
        accountId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverAccountAccountIdOrderPost", "body", body);
      const localVarPath = `/iserver/account/{accountId}/order`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
     * @summary Preview Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderWhatifPost: async (
      accountId: string,
      body: OrderRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrderWhatifPost",
        "accountId",
        accountId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverAccountAccountIdOrderWhatifPost", "body", body);
      const localVarPath = `/iserver/account/{accountId}/order/whatif`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
     * @summary Place Orders
     * @param {string} accountId account id
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrdersPost: async (
      accountId: string,
      body: InlineObject5,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrdersPost",
        "accountId",
        accountId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverAccountAccountIdOrdersPost", "body", body);
      const localVarPath = `/iserver/account/{accountId}/orders`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
     * @summary Preview Orders
     * @param {string} accountId account id
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrdersWhatifPost: async (
      accountId: string,
      body: InlineObject7,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrdersWhatifPost",
        "accountId",
        accountId
      );
      // verify required parameter 'body' is not null or undefined
      assertParamExists(
        "iserverAccountAccountIdOrdersWhatifPost",
        "body",
        body
      );
      const localVarPath = `/iserver/account/{accountId}/orders/whatif`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Order Status
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountOrderStatusOrderIdGet: async (
      orderId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'orderId' is not null or undefined
      assertParamExists(
        "iserverAccountOrderStatusOrderIdGet",
        "orderId",
        orderId
      );
      const localVarPath = `/iserver/account/order/status/{orderId}`.replace(
        `{${"orderId"}}`,
        encodeURIComponent(String(orderId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
     * @summary Place Orders for FA
     * @param {string} faGroup financial advisor group
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountOrdersFaGroupPost: async (
      faGroup: string,
      body: OrderRequest,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'faGroup' is not null or undefined
      assertParamExists("iserverAccountOrdersFaGroupPost", "faGroup", faGroup);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverAccountOrdersFaGroupPost", "body", body);
      const localVarPath = `/iserver/account/orders/{faGroup}`.replace(
        `{${"faGroup"}}`,
        encodeURIComponent(String(faGroup))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Live Orders
     * @param {InlineObject4} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountOrdersGet: async (
      body?: InlineObject4,
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/account/orders`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Reply to questions when placing orders and submit orders
     * @summary Place Order Reply
     * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverReplyReplyidPost: async (
      replyid: string,
      body: InlineObject6,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'replyid' is not null or undefined
      assertParamExists("iserverReplyReplyidPost", "replyid", replyid);
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverReplyReplyidPost", "body", body);
      const localVarPath = `/iserver/reply/{replyid}`.replace(
        `{${"replyid"}}`,
        encodeURIComponent(String(replyid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration);
  return {
    /**
     * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
     * @summary Cancel Order
     * @param {string} accountId account id, or fa group if deleting a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdOrderOrderIdDelete(
      accountId: string,
      orderId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20021>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdOrderOrderIdDelete(
          accountId,
          orderId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
     * @summary Modify Order
     * @param {string} accountId account id, or fa group if modifying a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {ModifyOrder} body modify-order request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdOrderOrderIdPost(
      accountId: string,
      orderId: string,
      body: ModifyOrder,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20020>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdOrderOrderIdPost(
          accountId,
          orderId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
     * @summary Place Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdOrderPost(
      accountId: string,
      body: OrderRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20017>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdOrderPost(
          accountId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
     * @summary Preview Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdOrderWhatifPost(
      accountId: string,
      body: OrderRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20019>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdOrderWhatifPost(
          accountId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
     * @summary Place Orders
     * @param {string} accountId account id
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdOrdersPost(
      accountId: string,
      body: InlineObject5,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20017>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdOrdersPost(
          accountId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
     * @summary Preview Orders
     * @param {string} accountId account id
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountAccountIdOrdersWhatifPost(
      accountId: string,
      body: InlineObject7,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20019>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountAccountIdOrdersWhatifPost(
          accountId,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Order Status
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountOrderStatusOrderIdGet(
      orderId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountOrderStatusOrderIdGet(
          orderId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
     * @summary Place Orders for FA
     * @param {string} faGroup financial advisor group
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountOrdersFaGroupPost(
      faGroup: string,
      body: OrderRequest,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20017>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountOrdersFaGroupPost(
          faGroup,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Live Orders
     * @param {InlineObject4} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountOrdersGet(
      body?: InlineObject4,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20016>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountOrdersGet(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Reply to questions when placing orders and submit orders
     * @summary Place Order Reply
     * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverReplyReplyidPost(
      replyid: string,
      body: InlineObject6,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20018>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverReplyReplyidPost(
          replyid,
          body,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = OrderApiFp(configuration);
  return {
    /**
     * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
     * @summary Cancel Order
     * @param {string} accountId account id, or fa group if deleting a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderOrderIdDelete(
      accountId: string,
      orderId: string,
      options?: any
    ): AxiosPromise<InlineResponse20021> {
      return localVarFp
        .iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
     * @summary Modify Order
     * @param {string} accountId account id, or fa group if modifying a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {ModifyOrder} body modify-order request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderOrderIdPost(
      accountId: string,
      orderId: string,
      body: ModifyOrder,
      options?: any
    ): AxiosPromise<Array<InlineResponse20020>> {
      return localVarFp
        .iserverAccountAccountIdOrderOrderIdPost(
          accountId,
          orderId,
          body,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
     * @summary Place Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderPost(
      accountId: string,
      body: OrderRequest,
      options?: any
    ): AxiosPromise<Array<InlineResponse20017>> {
      return localVarFp
        .iserverAccountAccountIdOrderPost(accountId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
     * @summary Preview Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrderWhatifPost(
      accountId: string,
      body: OrderRequest,
      options?: any
    ): AxiosPromise<InlineResponse20019> {
      return localVarFp
        .iserverAccountAccountIdOrderWhatifPost(accountId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
     * @summary Place Orders
     * @param {string} accountId account id
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrdersPost(
      accountId: string,
      body: InlineObject5,
      options?: any
    ): AxiosPromise<Array<InlineResponse20017>> {
      return localVarFp
        .iserverAccountAccountIdOrdersPost(accountId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
     * @summary Preview Orders
     * @param {string} accountId account id
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountAccountIdOrdersWhatifPost(
      accountId: string,
      body: InlineObject7,
      options?: any
    ): AxiosPromise<InlineResponse20019> {
      return localVarFp
        .iserverAccountAccountIdOrdersWhatifPost(accountId, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Order Status
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountOrderStatusOrderIdGet(
      orderId: string,
      options?: any
    ): AxiosPromise<OrderStatus> {
      return localVarFp
        .iserverAccountOrderStatusOrderIdGet(orderId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
     * @summary Place Orders for FA
     * @param {string} faGroup financial advisor group
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountOrdersFaGroupPost(
      faGroup: string,
      body: OrderRequest,
      options?: any
    ): AxiosPromise<Array<InlineResponse20017>> {
      return localVarFp
        .iserverAccountOrdersFaGroupPost(faGroup, body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Live Orders
     * @param {InlineObject4} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountOrdersGet(
      body?: InlineObject4,
      options?: any
    ): AxiosPromise<InlineResponse20016> {
      return localVarFp
        .iserverAccountOrdersGet(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Reply to questions when placing orders and submit orders
     * @summary Place Order Reply
     * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverReplyReplyidPost(
      replyid: string,
      body: InlineObject6,
      options?: any
    ): AxiosPromise<Array<InlineResponse20018>> {
      return localVarFp
        .iserverReplyReplyidPost(replyid, body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
  /**
   * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
   * @summary Cancel Order
   * @param {string} accountId account id, or fa group if deleting a group order
   * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountAccountIdOrderOrderIdDelete(
    accountId: string,
    orderId: string,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
   * @summary Modify Order
   * @param {string} accountId account id, or fa group if modifying a group order
   * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
   * @param {ModifyOrder} body modify-order request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountAccountIdOrderOrderIdPost(
    accountId: string,
    orderId: string,
    body: ModifyOrder,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountAccountIdOrderOrderIdPost(
        accountId,
        orderId,
        body,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
   * @summary Place Order (Deprecated)
   * @param {string} accountId account id
   * @param {OrderRequest} body order request info
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountAccountIdOrderPost(
    accountId: string,
    body: OrderRequest,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountAccountIdOrderPost(accountId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
   * @summary Preview Order (Deprecated)
   * @param {string} accountId account id
   * @param {OrderRequest} body order info
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountAccountIdOrderWhatifPost(
    accountId: string,
    body: OrderRequest,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountAccountIdOrderWhatifPost(accountId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
   * @summary Place Orders
   * @param {string} accountId account id
   * @param {InlineObject5} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountAccountIdOrdersPost(
    accountId: string,
    body: InlineObject5,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountAccountIdOrdersPost(accountId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
   * @summary Preview Orders
   * @param {string} accountId account id
   * @param {InlineObject7} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountAccountIdOrdersWhatifPost(
    accountId: string,
    body: InlineObject7,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountAccountIdOrdersWhatifPost(accountId, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Order Status
   * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountOrderStatusOrderIdGet(orderId: string, options?: any) {
    return OrderApiFp(this.configuration)
      .iserverAccountOrderStatusOrderIdGet(orderId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
   * @summary Place Orders for FA
   * @param {string} faGroup financial advisor group
   * @param {OrderRequest} body order request info
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountOrdersFaGroupPost(
    faGroup: string,
    body: OrderRequest,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverAccountOrdersFaGroupPost(faGroup, body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
   * @summary Live Orders
   * @param {InlineObject4} [body]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverAccountOrdersGet(body?: InlineObject4, options?: any) {
    return OrderApiFp(this.configuration)
      .iserverAccountOrdersGet(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Reply to questions when placing orders and submit orders
   * @summary Place Order Reply
   * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
   * @param {InlineObject6} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof OrderApi
   */
  public iserverReplyReplyidPost(
    replyid: string,
    body: InlineObject6,
    options?: any
  ) {
    return OrderApiFp(this.configuration)
      .iserverReplyReplyidPost(replyid, body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PnLApi - axios parameter creator
 * @export
 */
export const PnLApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountPnlPartitionedGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/account/pnl/partitioned`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PnLApi - functional programming interface
 * @export
 */
export const PnLApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = PnLApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountPnlPartitionedGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20031>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountPnlPartitionedGet(
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PnLApi - factory interface
 * @export
 */
export const PnLApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PnLApiFp(configuration);
  return {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountPnlPartitionedGet(
      options?: any
    ): AxiosPromise<InlineResponse20031> {
      return localVarFp
        .iserverAccountPnlPartitionedGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PnLApi - object-oriented interface
 * @export
 * @class PnLApi
 * @extends {BaseAPI}
 */
export class PnLApi extends BaseAPI {
  /**
   * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
   * @summary PnL for the selected account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PnLApi
   */
  public iserverAccountPnlPartitionedGet(options?: any) {
    return PnLApiFp(this.configuration)
      .iserverAccountPnlPartitionedGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PortfolioApi - axios parameter creator
 * @export
 */
export const PortfolioApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Allocation
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdAllocationGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "portfolioAccountIdAllocationGet",
        "accountId",
        accountId
      );
      const localVarPath = `/portfolio/{accountId}/allocation`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdLedgerGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("portfolioAccountIdLedgerGet", "accountId", accountId);
      const localVarPath = `/portfolio/{accountId}/ledger`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdMetaGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("portfolioAccountIdMetaGet", "accountId", accountId);
      const localVarPath = `/portfolio/{accountId}/meta`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Position by Conid
     * @param {string} accountId account id
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdPositionConidGet: async (
      accountId: string,
      conid: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "portfolioAccountIdPositionConidGet",
        "accountId",
        accountId
      );
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("portfolioAccountIdPositionConidGet", "conid", conid);
      const localVarPath = `/portfolio/{accountId}/position/{conid}`
        .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
        .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Invalidates the backend cache of the Portfolio
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdPositionsInvalidatePost: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "portfolioAccountIdPositionsInvalidatePost",
        "accountId",
        accountId
      );
      const localVarPath =
        `/portfolio/{accountId}/positions/invalidate`.replace(
          `{${"accountId"}}`,
          encodeURIComponent(String(accountId))
        );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Portfolio Positions
     * @param {string} accountId account id
     * @param {string} pageId page id
     * @param {string} [model] optional
     * @param {string} [sort] declare the table to be sorted by which column
     * @param {string} [direction] in which order, a means ascending - d means descending
     * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdPositionsPageIdGet: async (
      accountId: string,
      pageId: string,
      model?: string,
      sort?: string,
      direction?: string,
      period?: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists(
        "portfolioAccountIdPositionsPageIdGet",
        "accountId",
        accountId
      );
      // verify required parameter 'pageId' is not null or undefined
      assertParamExists(
        "portfolioAccountIdPositionsPageIdGet",
        "pageId",
        pageId
      );
      const localVarPath = `/portfolio/{accountId}/positions/{pageId}`
        .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
        .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (model !== undefined) {
        localVarQueryParameter["model"] = model;
      }

      if (sort !== undefined) {
        localVarQueryParameter["sort"] = sort;
      }

      if (direction !== undefined) {
        localVarQueryParameter["direction"] = direction;
      }

      if (period !== undefined) {
        localVarQueryParameter["period"] = period;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdSummaryGet: async (
      accountId: string,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'accountId' is not null or undefined
      assertParamExists("portfolioAccountIdSummaryGet", "accountId", accountId);
      const localVarPath = `/portfolio/{accountId}/summary`.replace(
        `{${"accountId"}}`,
        encodeURIComponent(String(accountId))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountsGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/portfolio/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Alloction (All Accounts)
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAllocationPost: async (
      body: InlineObject10,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("portfolioAllocationPost", "body", body);
      const localVarPath = `/portfolio/allocation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Positions by Conid
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioPositionsConidGet: async (
      conid: number,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'conid' is not null or undefined
      assertParamExists("portfolioPositionsConidGet", "conid", conid);
      const localVarPath = `/portfolio/positions/{conid}`.replace(
        `{${"conid"}}`,
        encodeURIComponent(String(conid))
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioSubaccountsGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/portfolio/subaccounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PortfolioApi - functional programming interface
 * @export
 */
export const PortfolioApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PortfolioApiAxiosParamCreator(configuration);
  return {
    /**
     * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Allocation
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdAllocationGet(
      accountId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdAllocationGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdLedgerGet(
      accountId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20036>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdLedgerGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdMetaGet(
      accountId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdMetaGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Position by Conid
     * @param {string} accountId account id
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdPositionConidGet(
      accountId: string,
      conid: number,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdPositionConidGet(
          accountId,
          conid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary Invalidates the backend cache of the Portfolio
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdPositionsInvalidatePost(
      accountId: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdPositionsInvalidatePost(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Portfolio Positions
     * @param {string} accountId account id
     * @param {string} pageId page id
     * @param {string} [model] optional
     * @param {string} [sort] declare the table to be sorted by which column
     * @param {string} [direction] in which order, a means ascending - d means descending
     * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdPositionsPageIdGet(
      accountId: string,
      pageId: string,
      model?: string,
      sort?: string,
      direction?: string,
      period?: string,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdPositionsPageIdGet(
          accountId,
          pageId,
          model,
          sort,
          direction,
          period,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountIdSummaryGet(
      accountId: string,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20035>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountIdSummaryGet(
          accountId,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAccountsGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Account>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAccountsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Alloction (All Accounts)
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioAllocationPost(
      body: InlineObject10,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioAllocationPost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Positions by Conid
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioPositionsConidGet(
      conid: number,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20037>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioPositionsConidGet(
          conid,
          options
        );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async portfolioSubaccountsGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.portfolioSubaccountsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PortfolioApi - factory interface
 * @export
 */
export const PortfolioApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PortfolioApiFp(configuration);
  return {
    /**
     * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Allocation
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdAllocationGet(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .portfolioAccountIdAllocationGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdLedgerGet(
      accountId: string,
      options?: any
    ): AxiosPromise<InlineResponse20036> {
      return localVarFp
        .portfolioAccountIdLedgerGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdMetaGet(
      accountId: string,
      options?: any
    ): AxiosPromise<Array<Account>> {
      return localVarFp
        .portfolioAccountIdMetaGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Position by Conid
     * @param {string} accountId account id
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdPositionConidGet(
      accountId: string,
      conid: number,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .portfolioAccountIdPositionConidGet(accountId, conid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Invalidates the backend cache of the Portfolio
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdPositionsInvalidatePost(
      accountId: string,
      options?: any
    ): AxiosPromise<object> {
      return localVarFp
        .portfolioAccountIdPositionsInvalidatePost(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Portfolio Positions
     * @param {string} accountId account id
     * @param {string} pageId page id
     * @param {string} [model] optional
     * @param {string} [sort] declare the table to be sorted by which column
     * @param {string} [direction] in which order, a means ascending - d means descending
     * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdPositionsPageIdGet(
      accountId: string,
      pageId: string,
      model?: string,
      sort?: string,
      direction?: string,
      period?: string,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .portfolioAccountIdPositionsPageIdGet(
          accountId,
          pageId,
          model,
          sort,
          direction,
          period,
          options
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountIdSummaryGet(
      accountId: string,
      options?: any
    ): AxiosPromise<InlineResponse20035> {
      return localVarFp
        .portfolioAccountIdSummaryGet(accountId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAccountsGet(options?: any): AxiosPromise<Array<Account>> {
      return localVarFp
        .portfolioAccountsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Alloction (All Accounts)
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioAllocationPost(
      body: InlineObject10,
      options?: any
    ): AxiosPromise<Array<object>> {
      return localVarFp
        .portfolioAllocationPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Positions by Conid
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioPositionsConidGet(
      conid: number,
      options?: any
    ): AxiosPromise<InlineResponse20037> {
      return localVarFp
        .portfolioPositionsConidGet(conid, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    portfolioSubaccountsGet(options?: any): AxiosPromise<Account> {
      return localVarFp
        .portfolioSubaccountsGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
export class PortfolioApi extends BaseAPI {
  /**
   * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Account Allocation
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdAllocationGet(accountId: string, options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdAllocationGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
   * @summary Account Ledger
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdLedgerGet(accountId: string, options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdLedgerGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Account Information
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdMetaGet(accountId: string, options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdMetaGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Position by Conid
   * @param {string} accountId account id
   * @param {number} conid contract id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdPositionConidGet(
    accountId: string,
    conid: number,
    options?: any
  ) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdPositionConidGet(accountId, conid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Invalidates the backend cache of the Portfolio
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdPositionsInvalidatePost(
    accountId: string,
    options?: any
  ) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdPositionsInvalidatePost(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Portfolio Positions
   * @param {string} accountId account id
   * @param {string} pageId page id
   * @param {string} [model] optional
   * @param {string} [sort] declare the table to be sorted by which column
   * @param {string} [direction] in which order, a means ascending - d means descending
   * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdPositionsPageIdGet(
    accountId: string,
    pageId: string,
    model?: string,
    sort?: string,
    direction?: string,
    period?: string,
    options?: any
  ) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdPositionsPageIdGet(
        accountId,
        pageId,
        model,
        sort,
        direction,
        period,
        options
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Account Summary
   * @param {string} accountId account id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountIdSummaryGet(accountId: string, options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountIdSummaryGet(accountId, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
   * @summary Portfolio Accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAccountsGet(options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioAccountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Account Alloction (All Accounts)
   * @param {InlineObject10} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioAllocationPost(body: InlineObject10, options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioAllocationPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
   * @summary Positions by Conid
   * @param {number} conid contract id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioPositionsConidGet(conid: number, options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioPositionsConidGet(conid, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
   * @summary List of Sub-Accounts
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioApi
   */
  public portfolioSubaccountsGet(options?: any) {
    return PortfolioApiFp(this.configuration)
      .portfolioSubaccountsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * PortfolioAnalystApi - axios parameter creator
 * @export
 */
export const PortfolioAnalystApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Performance
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paPerformancePost: async (
      body: InlineObject11,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("paPerformancePost", "body", body);
      const localVarPath = `/pa/performance`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Balance\'s Summary
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paSummaryPost: async (
      body: InlineObject12,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("paSummaryPost", "body", body);
      const localVarPath = `/pa/summary`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
     * @summary Position\'s Transaction History
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paTransactionsPost: async (
      body: InlineObject13,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("paTransactionsPost", "body", body);
      const localVarPath = `/pa/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * PortfolioAnalystApi - functional programming interface
 * @export
 */
export const PortfolioAnalystApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    PortfolioAnalystApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Performance
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paPerformancePost(
      body: InlineObject11,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Performance>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paPerformancePost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Balance\'s Summary
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paSummaryPost(
      body: InlineObject12,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Summary>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.paSummaryPost(
        body,
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
     * @summary Position\'s Transaction History
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async paTransactionsPost(
      body: InlineObject13,
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transactions>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.paTransactionsPost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * PortfolioAnalystApi - factory interface
 * @export
 */
export const PortfolioAnalystApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = PortfolioAnalystApiFp(configuration);
  return {
    /**
     * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Performance
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paPerformancePost(
      body: InlineObject11,
      options?: any
    ): AxiosPromise<Performance> {
      return localVarFp
        .paPerformancePost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Balance\'s Summary
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paSummaryPost(body: InlineObject12, options?: any): AxiosPromise<Summary> {
      return localVarFp
        .paSummaryPost(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
     * @summary Position\'s Transaction History
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    paTransactionsPost(
      body: InlineObject13,
      options?: any
    ): AxiosPromise<Transactions> {
      return localVarFp
        .paTransactionsPost(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * PortfolioAnalystApi - object-oriented interface
 * @export
 * @class PortfolioAnalystApi
 * @extends {BaseAPI}
 */
export class PortfolioAnalystApi extends BaseAPI {
  /**
   * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
   * @summary Account Performance
   * @param {InlineObject11} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioAnalystApi
   */
  public paPerformancePost(body: InlineObject11, options?: any) {
    return PortfolioAnalystApiFp(this.configuration)
      .paPerformancePost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
   * @summary Account Balance\'s Summary
   * @param {InlineObject12} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioAnalystApi
   */
  public paSummaryPost(body: InlineObject12, options?: any) {
    return PortfolioAnalystApiFp(this.configuration)
      .paSummaryPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
   * @summary Position\'s Transaction History
   * @param {InlineObject13} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PortfolioAnalystApi
   */
  public paTransactionsPost(body: InlineObject13, options?: any) {
    return PortfolioAnalystApiFp(this.configuration)
      .paTransactionsPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * ScannerApi - axios parameter creator
 * @export
 */
export const ScannerApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns an object contains four lists contain all parameters for scanners
     * @summary Scanner Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverScannerParamsGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/scanner/params`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary run scanner to get a list of contracts
     * @param {ScannerParams} body scanner-params request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverScannerRunPost: async (
      body: ScannerParams,
      options: any = {}
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists("iserverScannerRunPost", "body", body);
      const localVarPath = `/iserver/scanner/run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      localVarHeaderParameter["Content-Type"] = "application/json";

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = serializeDataIfNeeded(
        body,
        localVarRequestOptions,
        configuration
      );

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * ScannerApi - functional programming interface
 * @export
 */
export const ScannerApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = ScannerApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns an object contains four lists contain all parameters for scanners
     * @summary Scanner Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverScannerParamsGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20029>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverScannerParamsGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     *
     * @summary run scanner to get a list of contracts
     * @param {ScannerParams} body scanner-params request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverScannerRunPost(
      body: ScannerParams,
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<Array<InlineResponse20030>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverScannerRunPost(body, options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * ScannerApi - factory interface
 * @export
 */
export const ScannerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = ScannerApiFp(configuration);
  return {
    /**
     * Returns an object contains four lists contain all parameters for scanners
     * @summary Scanner Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverScannerParamsGet(options?: any): AxiosPromise<InlineResponse20029> {
      return localVarFp
        .iserverScannerParamsGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary run scanner to get a list of contracts
     * @param {ScannerParams} body scanner-params request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverScannerRunPost(
      body: ScannerParams,
      options?: any
    ): AxiosPromise<Array<InlineResponse20030>> {
      return localVarFp
        .iserverScannerRunPost(body, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * ScannerApi - object-oriented interface
 * @export
 * @class ScannerApi
 * @extends {BaseAPI}
 */
export class ScannerApi extends BaseAPI {
  /**
   * Returns an object contains four lists contain all parameters for scanners
   * @summary Scanner Parameters
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public iserverScannerParamsGet(options?: any) {
    return ScannerApiFp(this.configuration)
      .iserverScannerParamsGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary run scanner to get a list of contracts
   * @param {ScannerParams} body scanner-params request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ScannerApi
   */
  public iserverScannerRunPost(body: ScannerParams, options?: any) {
    return ScannerApiFp(this.configuration)
      .iserverScannerRunPost(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * SessionApi - axios parameter creator
 * @export
 */
export const SessionApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
     * @summary Authentication Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAuthStatusPost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/iserver/auth/status`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
     * @summary Tries to re-authenticate to Brokerage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverReauthenticatePost: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/reauthenticate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Logs the user out of the gateway session. Any further activity requires re-authentication.
     * @summary Ends the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/logout`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Validates the current session for the SSO user
     * @summary Validate SSO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ssoValidateGet: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/sso/validate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
     * @summary Ping the server to keep the session open
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticklePost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/tickle`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * SessionApi - functional programming interface
 * @export
 */
export const SessionApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = SessionApiAxiosParamCreator(configuration);
  return {
    /**
     * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
     * @summary Authentication Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAuthStatusPost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAuthStatusPost(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
     * @summary Tries to re-authenticate to Brokerage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverReauthenticatePost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthStatus>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverReauthenticatePost(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Logs the user out of the gateway session. Any further activity requires re-authentication.
     * @summary Ends the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logoutPost(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse200>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logoutPost(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * Validates the current session for the SSO user
     * @summary Validate SSO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ssoValidateGet(
      options?: any
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string
      ) => AxiosPromise<InlineResponse20038>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ssoValidateGet(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
    /**
     * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
     * @summary Ping the server to keep the session open
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ticklePost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ticklePost(
        options
      );
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * SessionApi - factory interface
 * @export
 */
export const SessionApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = SessionApiFp(configuration);
  return {
    /**
     * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
     * @summary Authentication Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAuthStatusPost(options?: any): AxiosPromise<AuthStatus> {
      return localVarFp
        .iserverAuthStatusPost(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
     * @summary Tries to re-authenticate to Brokerage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverReauthenticatePost(options?: any): AxiosPromise<AuthStatus> {
      return localVarFp
        .iserverReauthenticatePost(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Logs the user out of the gateway session. Any further activity requires re-authentication.
     * @summary Ends the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logoutPost(options?: any): AxiosPromise<InlineResponse200> {
      return localVarFp
        .logoutPost(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Validates the current session for the SSO user
     * @summary Validate SSO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ssoValidateGet(options?: any): AxiosPromise<InlineResponse20038> {
      return localVarFp
        .ssoValidateGet(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
     * @summary Ping the server to keep the session open
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ticklePost(options?: any): AxiosPromise<void> {
      return localVarFp
        .ticklePost(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
export class SessionApi extends BaseAPI {
  /**
   * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
   * @summary Authentication Status
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  public iserverAuthStatusPost(options?: any) {
    return SessionApiFp(this.configuration)
      .iserverAuthStatusPost(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
   * @summary Tries to re-authenticate to Brokerage
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  public iserverReauthenticatePost(options?: any) {
    return SessionApiFp(this.configuration)
      .iserverReauthenticatePost(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Logs the user out of the gateway session. Any further activity requires re-authentication.
   * @summary Ends the current session
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  public logoutPost(options?: any) {
    return SessionApiFp(this.configuration)
      .logoutPost(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Validates the current session for the SSO user
   * @summary Validate SSO
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  public ssoValidateGet(options?: any) {
    return SessionApiFp(this.configuration)
      .ssoValidateGet(options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
   * @summary Ping the server to keep the session open
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SessionApi
   */
  public ticklePost(options?: any) {
    return SessionApiFp(this.configuration)
      .ticklePost(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * StreamingApi - axios parameter creator
 * @export
 */
export const StreamingApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Websocket Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    wsPost: async (options: any = {}): Promise<RequestArgs> => {
      const localVarPath = `/ws`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "POST",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * StreamingApi - functional programming interface
 * @export
 */
export const StreamingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator =
    StreamingApiAxiosParamCreator(configuration);
  return {
    /**
     * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Websocket Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async wsPost(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>
    > {
      const localVarAxiosArgs = await localVarAxiosParamCreator.wsPost(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * StreamingApi - factory interface
 * @export
 */
export const StreamingApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = StreamingApiFp(configuration);
  return {
    /**
     * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Websocket Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    wsPost(options?: any): AxiosPromise<void> {
      return localVarFp
        .wsPost(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * StreamingApi - object-oriented interface
 * @export
 * @class StreamingApi
 * @extends {BaseAPI}
 */
export class StreamingApi extends BaseAPI {
  /**
   * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
   * @summary Websocket Endpoint
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof StreamingApi
   */
  public wsPost(options?: any) {
    return StreamingApiFp(this.configuration)
      .wsPost(options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * TradesApi - axios parameter creator
 * @export
 */
export const TradesApiAxiosParamCreator = function (
  configuration?: Configuration
) {
  return {
    /**
     * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
     * @summary List of Trades for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountTradesGet: async (
      options: any = {}
    ): Promise<RequestArgs> => {
      const localVarPath = `/iserver/account/trades`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = {
        method: "GET",
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
      let headersFromBaseOptions =
        baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * TradesApi - functional programming interface
 * @export
 */
export const TradesApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = TradesApiAxiosParamCreator(configuration);
  return {
    /**
     * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
     * @summary List of Trades for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async iserverAccountTradesGet(
      options?: any
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>
    > {
      const localVarAxiosArgs =
        await localVarAxiosParamCreator.iserverAccountTradesGet(options);
      return createRequestFunction(
        localVarAxiosArgs,
        globalAxios,
        BASE_PATH,
        configuration
      );
    },
  };
};

/**
 * TradesApi - factory interface
 * @export
 */
export const TradesApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance
) {
  const localVarFp = TradesApiFp(configuration);
  return {
    /**
     * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
     * @summary List of Trades for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    iserverAccountTradesGet(options?: any): AxiosPromise<Array<Trade>> {
      return localVarFp
        .iserverAccountTradesGet(options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
export class TradesApi extends BaseAPI {
  /**
   * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
   * @summary List of Trades for the selected account
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof TradesApi
   */
  public iserverAccountTradesGet(options?: any) {
    return TradesApiFp(this.configuration)
      .iserverAccountTradesGet(options)
      .then((request) => request(this.axios, this.basePath));
  }
}
