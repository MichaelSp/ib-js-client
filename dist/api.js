"use strict";
// @ts-ignore
/* eslint-disable */
/**
 * Client Portal Web API
 * Client Poral Web API
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OrderApi = exports.OrderApiFactory = exports.OrderApiFp = exports.OrderApiAxiosParamCreator = exports.MarketDataApi = exports.MarketDataApiFactory = exports.MarketDataApiFp = exports.MarketDataApiAxiosParamCreator = exports.IBCustApi = exports.IBCustApiFactory = exports.IBCustApiFp = exports.IBCustApiAxiosParamCreator = exports.FYIApi = exports.FYIApiFactory = exports.FYIApiFp = exports.FYIApiAxiosParamCreator = exports.ContractApi = exports.ContractApiFactory = exports.ContractApiFp = exports.ContractApiAxiosParamCreator = exports.CCPBetaApi = exports.CCPBetaApiFactory = exports.CCPBetaApiFp = exports.CCPBetaApiAxiosParamCreator = exports.AlertApi = exports.AlertApiFactory = exports.AlertApiFp = exports.AlertApiAxiosParamCreator = exports.AccountApi = exports.AccountApiFactory = exports.AccountApiFp = exports.AccountApiAxiosParamCreator = exports.TradeSideEnum = exports.OrderStatusExitStrategyToolAvailabilityEnum = exports.OrderStatusSideEnum = exports.OrderDataTifEnum = exports.OrderDataSecTypeEnum = exports.OrderDataSideEnum = exports.OrderDataOrderStatusEnum = exports.OrderDataOrderTypeEnum = exports.OrderDataExecTypeEnum = exports.IserverContractConidAlgosParametersEnabledConditionsEnum = exports.IserverContractConidAlgosParametersValueClassNameEnum = exports.InlineResponse20016OrdersSideEnum = exports.InlineObject4FiltersEnum = exports.InlineObject11FreqEnum = exports.AccountClearingStatusEnum = exports.AccountTypeEnum = exports.AccountCurrencyEnum = exports.AccountDisplayNameEnum = void 0;
exports.TradesApi = exports.TradesApiFactory = exports.TradesApiFp = exports.TradesApiAxiosParamCreator = exports.StreamingApi = exports.StreamingApiFactory = exports.StreamingApiFp = exports.StreamingApiAxiosParamCreator = exports.SessionApi = exports.SessionApiFactory = exports.SessionApiFp = exports.SessionApiAxiosParamCreator = exports.ScannerApi = exports.ScannerApiFactory = exports.ScannerApiFp = exports.ScannerApiAxiosParamCreator = exports.PortfolioAnalystApi = exports.PortfolioAnalystApiFactory = exports.PortfolioAnalystApiFp = exports.PortfolioAnalystApiAxiosParamCreator = exports.PortfolioApi = exports.PortfolioApiFactory = exports.PortfolioApiFp = exports.PortfolioApiAxiosParamCreator = exports.PnLApi = exports.PnLApiFactory = exports.PnLApiFp = exports.PnLApiAxiosParamCreator = void 0;
const axios_1 = require("axios");
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
/**
 * @export
 * @enum {string}
 */
var AccountDisplayNameEnum;
(function (AccountDisplayNameEnum) {
    AccountDisplayNameEnum["AccountTitle"] = "accountTitle";
    AccountDisplayNameEnum["AccountVan"] = "accountVan";
    AccountDisplayNameEnum["AccountId"] = "accountId";
})(AccountDisplayNameEnum = exports.AccountDisplayNameEnum || (exports.AccountDisplayNameEnum = {}));
/**
 * @export
 * @enum {string}
 */
var AccountCurrencyEnum;
(function (AccountCurrencyEnum) {
    AccountCurrencyEnum["Aud"] = "AUD";
    AccountCurrencyEnum["Gbp"] = "GBP";
    AccountCurrencyEnum["Cad"] = "CAD";
    AccountCurrencyEnum["Cnh"] = "CNH";
    AccountCurrencyEnum["Czk"] = "CZK";
    AccountCurrencyEnum["Dkk"] = "DKK";
    AccountCurrencyEnum["Eur"] = "EUR";
    AccountCurrencyEnum["Hkd"] = "HKD";
    AccountCurrencyEnum["Huf"] = "HUF";
    AccountCurrencyEnum["Inr"] = "INR";
    AccountCurrencyEnum["Ils"] = "ILS";
    AccountCurrencyEnum["Jpy"] = "JPY";
    AccountCurrencyEnum["Mxn"] = "MXN";
    AccountCurrencyEnum["Nok"] = "NOK";
    AccountCurrencyEnum["Nzd"] = "NZD";
    AccountCurrencyEnum["Pln"] = "PLN";
    AccountCurrencyEnum["Rub"] = "RUB";
    AccountCurrencyEnum["Sgd"] = "SGD";
    AccountCurrencyEnum["Sek"] = "SEK";
    AccountCurrencyEnum["Chf"] = "CHF";
    AccountCurrencyEnum["Usd"] = "USD";
})(AccountCurrencyEnum = exports.AccountCurrencyEnum || (exports.AccountCurrencyEnum = {}));
/**
 * @export
 * @enum {string}
 */
var AccountTypeEnum;
(function (AccountTypeEnum) {
    AccountTypeEnum["Individual"] = "INDIVIDUAL";
    AccountTypeEnum["Joint"] = "JOINT";
    AccountTypeEnum["Org"] = "ORG";
    AccountTypeEnum["Trust"] = "TRUST";
    AccountTypeEnum["Demo"] = "DEMO";
})(AccountTypeEnum = exports.AccountTypeEnum || (exports.AccountTypeEnum = {}));
/**
 * @export
 * @enum {string}
 */
var AccountClearingStatusEnum;
(function (AccountClearingStatusEnum) {
    AccountClearingStatusEnum["O"] = "O";
    AccountClearingStatusEnum["P"] = "P";
    AccountClearingStatusEnum["N"] = "N";
    AccountClearingStatusEnum["A"] = "A";
    AccountClearingStatusEnum["R"] = "R";
    AccountClearingStatusEnum["C"] = "C";
})(AccountClearingStatusEnum = exports.AccountClearingStatusEnum || (exports.AccountClearingStatusEnum = {}));
/**
 * @export
 * @enum {string}
 */
var InlineObject11FreqEnum;
(function (InlineObject11FreqEnum) {
    InlineObject11FreqEnum["D"] = "D";
    InlineObject11FreqEnum["M"] = "M";
    InlineObject11FreqEnum["Q"] = "Q";
})(InlineObject11FreqEnum = exports.InlineObject11FreqEnum || (exports.InlineObject11FreqEnum = {}));
/**
 * @export
 * @enum {string}
 */
var InlineObject4FiltersEnum;
(function (InlineObject4FiltersEnum) {
    InlineObject4FiltersEnum["Inactive"] = "inactive";
    InlineObject4FiltersEnum["PendingSubmit"] = "pending_submit";
    InlineObject4FiltersEnum["PreSubmitted"] = "pre_submitted";
    InlineObject4FiltersEnum["Submitted"] = "submitted";
    InlineObject4FiltersEnum["Filled"] = "filled";
    InlineObject4FiltersEnum["PendingCancel"] = "pending_cancel";
    InlineObject4FiltersEnum["Cancelled"] = "cancelled";
    InlineObject4FiltersEnum["WarnState"] = "warn_state";
    InlineObject4FiltersEnum["SortByTime"] = "sort_by_time";
})(InlineObject4FiltersEnum = exports.InlineObject4FiltersEnum || (exports.InlineObject4FiltersEnum = {}));
/**
 * @export
 * @enum {string}
 */
var InlineResponse20016OrdersSideEnum;
(function (InlineResponse20016OrdersSideEnum) {
    InlineResponse20016OrdersSideEnum["Buy"] = "BUY";
    InlineResponse20016OrdersSideEnum["Sell"] = "SELL";
    InlineResponse20016OrdersSideEnum["Assn"] = "ASSN";
    InlineResponse20016OrdersSideEnum["Exer"] = "EXER";
})(InlineResponse20016OrdersSideEnum = exports.InlineResponse20016OrdersSideEnum || (exports.InlineResponse20016OrdersSideEnum = {}));
/**
 * @export
 * @enum {string}
 */
var IserverContractConidAlgosParametersValueClassNameEnum;
(function (IserverContractConidAlgosParametersValueClassNameEnum) {
    IserverContractConidAlgosParametersValueClassNameEnum["Double"] = "double";
    IserverContractConidAlgosParametersValueClassNameEnum["String"] = "string";
    IserverContractConidAlgosParametersValueClassNameEnum["Time"] = "time";
    IserverContractConidAlgosParametersValueClassNameEnum["Boolean"] = "boolean";
})(IserverContractConidAlgosParametersValueClassNameEnum = exports.IserverContractConidAlgosParametersValueClassNameEnum || (exports.IserverContractConidAlgosParametersValueClassNameEnum = {}));
/**
 * @export
 * @enum {string}
 */
var IserverContractConidAlgosParametersEnabledConditionsEnum;
(function (IserverContractConidAlgosParametersEnabledConditionsEnum) {
    IserverContractConidAlgosParametersEnabledConditionsEnum["MkTspeedUpno"] = "MKT:speedUp:=:no";
    IserverContractConidAlgosParametersEnabledConditionsEnum["LmTstrategyTypeempty"] = "LMT:strategyType:<>:empty";
    IserverContractConidAlgosParametersEnabledConditionsEnum["MkTstrategyTypeMarketable"] = "MKT:strategyType:=:Marketable";
})(IserverContractConidAlgosParametersEnabledConditionsEnum = exports.IserverContractConidAlgosParametersEnabledConditionsEnum || (exports.IserverContractConidAlgosParametersEnabledConditionsEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderDataExecTypeEnum;
(function (OrderDataExecTypeEnum) {
    OrderDataExecTypeEnum["_1Invalid"] = "-1 \"Invalid\"";
    OrderDataExecTypeEnum["_0New"] = "0 \"New\"";
    OrderDataExecTypeEnum["_1PartiallyFilled"] = "1 \"Partially Filled\"";
    OrderDataExecTypeEnum["_2Filled"] = "2 \"Filled\"";
    OrderDataExecTypeEnum["_3DoneForTheDay"] = "3 \"Done for the Day\"";
    OrderDataExecTypeEnum["_4Canceled"] = "4 \"Canceled\"";
    OrderDataExecTypeEnum["_5Replaced"] = "5 \"Replaced\"";
    OrderDataExecTypeEnum["_6PendingCancel"] = "6 \"Pending Cancel\"";
    OrderDataExecTypeEnum["_7Stopped"] = "7 \"Stopped\"";
    OrderDataExecTypeEnum["_8Rejected"] = "8 \"Rejected\"";
    OrderDataExecTypeEnum["_9Suspended"] = "9 \"Suspended\"";
    OrderDataExecTypeEnum["APendingNew"] = "A \"Pending New\"";
    OrderDataExecTypeEnum["BCalculated"] = "B \"Calculated\"";
    OrderDataExecTypeEnum["CExpired"] = "C \"Expired\"";
    OrderDataExecTypeEnum["DRestated"] = "D \"Restated\"";
    OrderDataExecTypeEnum["EPendingReplace"] = "E \"Pending Replace\"";
    OrderDataExecTypeEnum["FTrade"] = "F \"Trade\"";
    OrderDataExecTypeEnum["GTradeCorrect"] = "G \"Trade Correct\"";
    OrderDataExecTypeEnum["HTradeCancel"] = "H \"Trade Cancel\"";
    OrderDataExecTypeEnum["IOrderStatus"] = "I \"Order Status\"";
})(OrderDataExecTypeEnum = exports.OrderDataExecTypeEnum || (exports.OrderDataExecTypeEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderDataOrderTypeEnum;
(function (OrderDataOrderTypeEnum) {
    OrderDataOrderTypeEnum["_1Market"] = "1 \"Market\"";
    OrderDataOrderTypeEnum["_2Limit"] = "2 \"Limit\"";
    OrderDataOrderTypeEnum["_3Stop"] = "3 \"Stop\"";
    OrderDataOrderTypeEnum["_4StopLimit"] = "4 \"Stop Limit\"";
    OrderDataOrderTypeEnum["_5MarketOnClose"] = "5 \"Market on Close\"";
    OrderDataOrderTypeEnum["_6WithOrWithout"] = "6 \"With or Without\"";
    OrderDataOrderTypeEnum["_7LimitOrBetter"] = "7 \"Limit or Better\"";
    OrderDataOrderTypeEnum["_8LimitWithOrWithout"] = "8 \"Limit With or Without\"";
    OrderDataOrderTypeEnum["_9OnBasis"] = "9 \"On Basis\"";
    OrderDataOrderTypeEnum["AOnClose"] = "A \"On Close\"";
    OrderDataOrderTypeEnum["BLimitOnClose"] = "B \"Limit On Close\"";
    OrderDataOrderTypeEnum["CForexMarket"] = "C \"Forex Market\"";
    OrderDataOrderTypeEnum["DPreviouslyQuoted"] = "D \"Previously Quoted\"";
    OrderDataOrderTypeEnum["EPreviouslyIndicated"] = "E \"Previously Indicated\"";
    OrderDataOrderTypeEnum["FForexLimit"] = "F \"Forex Limit\"";
    OrderDataOrderTypeEnum["GForexSwap"] = "G \"Forex Swap\"";
    OrderDataOrderTypeEnum["HForexPreviouslyQuoted"] = "H \"Forex Previously Quoted\"";
    OrderDataOrderTypeEnum["IFunari"] = "I \"Funari\"";
    OrderDataOrderTypeEnum["KMarketToLimit"] = "K \"Market To Limit\"";
    OrderDataOrderTypeEnum["PPegged"] = "P \"Pegged\"";
})(OrderDataOrderTypeEnum = exports.OrderDataOrderTypeEnum || (exports.OrderDataOrderTypeEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderDataOrderStatusEnum;
(function (OrderDataOrderStatusEnum) {
    OrderDataOrderStatusEnum["_1InvalidOrderStatus"] = "-1 \"Invalid Order Status\"";
    OrderDataOrderStatusEnum["_0New"] = "0 \"New\"";
    OrderDataOrderStatusEnum["_1PartiallyFilled"] = "1 \"Partially Filled\"";
    OrderDataOrderStatusEnum["_2Filled"] = "2 \"Filled\"";
    OrderDataOrderStatusEnum["_3DoneForTheDay"] = "3 \"Done for the Day\"";
    OrderDataOrderStatusEnum["_4Canceled"] = "4 \"Canceled\"";
    OrderDataOrderStatusEnum["_5Replaced"] = "5 \"Replaced\"";
    OrderDataOrderStatusEnum["_6PendingCancel"] = "6 \"Pending Cancel\"";
    OrderDataOrderStatusEnum["_7Stopped"] = "7 \"Stopped\"";
    OrderDataOrderStatusEnum["_8Rejected"] = "8 \"Rejected\"";
    OrderDataOrderStatusEnum["_9Suspended"] = "9 \"Suspended\"";
    OrderDataOrderStatusEnum["APendingNew"] = "A \"Pending New\"";
    OrderDataOrderStatusEnum["BCalculated"] = "B \"Calculated\"";
    OrderDataOrderStatusEnum["CExpired"] = "C \"Expired\"";
    OrderDataOrderStatusEnum["DRestated"] = "D \"Restated\"";
    OrderDataOrderStatusEnum["EPendingReplace"] = "E \"Pending Replace\"";
})(OrderDataOrderStatusEnum = exports.OrderDataOrderStatusEnum || (exports.OrderDataOrderStatusEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderDataSideEnum;
(function (OrderDataSideEnum) {
    OrderDataSideEnum["_1Buy"] = "1 \"Buy\"";
    OrderDataSideEnum["_2Sell"] = "2 \"Sell\"";
    OrderDataSideEnum["_3BuyMinus"] = "3 \"Buy Minus\"";
    OrderDataSideEnum["_4SellPlus"] = "4 \"Sell Plus\"";
    OrderDataSideEnum["_5SellShort"] = "5 \"Sell Short\"";
    OrderDataSideEnum["_6SellShortExempt"] = "6 \"Sell Short Exempt\"";
})(OrderDataSideEnum = exports.OrderDataSideEnum || (exports.OrderDataSideEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderDataSecTypeEnum;
(function (OrderDataSecTypeEnum) {
    OrderDataSecTypeEnum["CsStock"] = "CS \"Stock\"";
    OrderDataSecTypeEnum["CashForex"] = "CASH \"Forex\"";
    OrderDataSecTypeEnum["CfdContractForDifference"] = "CFD \"Contract for Difference\"";
    OrderDataSecTypeEnum["FutFuture"] = "FUT \"Future\"";
    OrderDataSecTypeEnum["OptOption"] = "OPT \"Option\"";
})(OrderDataSecTypeEnum = exports.OrderDataSecTypeEnum || (exports.OrderDataSecTypeEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderDataTifEnum;
(function (OrderDataTifEnum) {
    OrderDataTifEnum["_0Day"] = "0 \"Day\"";
    OrderDataTifEnum["_1Gtc"] = "1 \"GTC\"";
    OrderDataTifEnum["_2AtTheOpening"] = "2 \"At the Opening\"";
})(OrderDataTifEnum = exports.OrderDataTifEnum || (exports.OrderDataTifEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderStatusSideEnum;
(function (OrderStatusSideEnum) {
    OrderStatusSideEnum["B"] = "B";
    OrderStatusSideEnum["S"] = "S";
    OrderStatusSideEnum["X"] = "X";
})(OrderStatusSideEnum = exports.OrderStatusSideEnum || (exports.OrderStatusSideEnum = {}));
/**
 * @export
 * @enum {string}
 */
var OrderStatusExitStrategyToolAvailabilityEnum;
(function (OrderStatusExitStrategyToolAvailabilityEnum) {
    OrderStatusExitStrategyToolAvailabilityEnum["_1"] = "1";
    OrderStatusExitStrategyToolAvailabilityEnum["_0"] = "0";
})(OrderStatusExitStrategyToolAvailabilityEnum = exports.OrderStatusExitStrategyToolAvailabilityEnum || (exports.OrderStatusExitStrategyToolAvailabilityEnum = {}));
/**
 * @export
 * @enum {string}
 */
var TradeSideEnum;
(function (TradeSideEnum) {
    TradeSideEnum["B"] = "B";
    TradeSideEnum["S"] = "S";
    TradeSideEnum["X"] = "X";
})(TradeSideEnum = exports.TradeSideEnum || (exports.TradeSideEnum = {}));
/**
 * AccountApi - axios parameter creator
 * @export
 */
const AccountApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/account/pnl/partitioned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
         * @summary Switch Account
         * @param {SetAccount} body account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountPost", "body", body);
            const localVarPath = `/iserver/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdLedgerGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/ledger`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdMetaGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/meta`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdSummaryGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/summary`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/portfolio/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/portfolio/subaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AccountApiAxiosParamCreator = AccountApiAxiosParamCreator;
/**
 * AccountApi - functional programming interface
 * @export
 */
const AccountApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AccountApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountPnlPartitionedGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
         * @summary Switch Account
         * @param {SetAccount} body account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdLedgerGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdMetaGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdSummaryGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioSubaccountsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AccountApiFp = AccountApiFp;
/**
 * AccountApi - factory interface
 * @export
 */
const AccountApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AccountApiFp)(configuration);
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet(options) {
            return localVarFp
                .iserverAccountPnlPartitionedGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
         * @summary Switch Account
         * @param {SetAccount} body account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPost(body, options) {
            return localVarFp
                .iserverAccountPost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountsGet(options) {
            return localVarFp
                .iserverAccountsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdLedgerGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdMetaGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdSummaryGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet(options) {
            return localVarFp
                .portfolioAccountsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet(options) {
            return localVarFp
                .portfolioSubaccountsGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.AccountApiFactory = AccountApiFactory;
/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
class AccountApi extends base_1.BaseAPI {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    iserverAccountPnlPartitionedGet(options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .iserverAccountPnlPartitionedGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * If an user has multiple accounts, and user wants to get orders, trades, etc. of an account other than currently selected account, then user can update the currently selected account using this API and then can fetch required information for the newly updated account.
     * @summary Switch Account
     * @param {SetAccount} body account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    iserverAccountPost(body, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .iserverAccountPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of accounts the user has trading access to, their respective aliases and the currently selected account. Note this endpoint must be called before modifying an order or querying open orders.
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    iserverAccountsGet(options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .iserverAccountsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    portfolioAccountIdLedgerGet(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .portfolioAccountIdLedgerGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    portfolioAccountIdMetaGet(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .portfolioAccountIdMetaGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    portfolioAccountIdSummaryGet(accountId, options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .portfolioAccountIdSummaryGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    portfolioAccountsGet(options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .portfolioAccountsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    portfolioSubaccountsGet(options) {
        return (0, exports.AccountApiFp)(this.configuration)
            .portfolioSubaccountsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.AccountApi = AccountApi;
/**
 * AlertApi - axios parameter creator
 * @export
 */
const AlertApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Please note, if alertId is 0, it will activate/deactivate all alerts
         * @summary Activate or deactivate an alert
         * @param {string} accountId account id
         * @param {InlineObject3} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertActivatePost: (accountId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertActivatePost", "accountId", accountId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertActivatePost", "body", body);
            const localVarPath = `/iserver/account/:accountId/alert/activate`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Please be careful, if alertId is 0, it will delete all alerts
         * @summary Delete an alert
         * @param {string} accountId account id
         * @param {string} alertId alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertAlertIdDelete: (accountId, alertId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertAlertIdDelete", "accountId", accountId);
            // verify required parameter 'alertId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertAlertIdDelete", "alertId", alertId);
            const localVarPath = `/iserver/account/:accountId/alert/:alertId`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"alertId"}}`, encodeURIComponent(String(alertId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
         * @summary Create or modify alert
         * @param {string} accountId account id
         * @param {AlertRequest} body alert info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertPost: (accountId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertPost", "accountId", accountId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertPost", "body", body);
            const localVarPath = `/iserver/account/{accountId}/alert`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The response will contain both active and inactive alerts, but it won\'t have MTA alert
         * @summary Get a list of available alerts
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertsGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdAlertsGet", "accountId", accountId);
            const localVarPath = `/iserver/account/:accountId/alerts`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
         * @summary Get details of an alert
         * @param {string} id alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAlertIdGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAlertIdGet", "id", id);
            const localVarPath = `/iserver/account/alert/:id`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
         * @summary Get MTA alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountMtaGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/account/mta`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.AlertApiAxiosParamCreator = AlertApiAxiosParamCreator;
/**
 * AlertApi - functional programming interface
 * @export
 */
const AlertApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.AlertApiAxiosParamCreator)(configuration);
    return {
        /**
         * Please note, if alertId is 0, it will activate/deactivate all alerts
         * @summary Activate or deactivate an alert
         * @param {string} accountId account id
         * @param {InlineObject3} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertActivatePost(accountId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdAlertActivatePost(accountId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Please be careful, if alertId is 0, it will delete all alerts
         * @summary Delete an alert
         * @param {string} accountId account id
         * @param {string} alertId alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
         * @summary Create or modify alert
         * @param {string} accountId account id
         * @param {AlertRequest} body alert info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertPost(accountId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdAlertPost(accountId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * The response will contain both active and inactive alerts, but it won\'t have MTA alert
         * @summary Get a list of available alerts
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertsGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdAlertsGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
         * @summary Get details of an alert
         * @param {string} id alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAlertIdGet(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAlertIdGet(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
         * @summary Get MTA alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountMtaGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountMtaGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.AlertApiFp = AlertApiFp;
/**
 * AlertApi - factory interface
 * @export
 */
const AlertApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.AlertApiFp)(configuration);
    return {
        /**
         * Please note, if alertId is 0, it will activate/deactivate all alerts
         * @summary Activate or deactivate an alert
         * @param {string} accountId account id
         * @param {InlineObject3} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertActivatePost(accountId, body, options) {
            return localVarFp
                .iserverAccountAccountIdAlertActivatePost(accountId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Please be careful, if alertId is 0, it will delete all alerts
         * @summary Delete an alert
         * @param {string} accountId account id
         * @param {string} alertId alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options) {
            return localVarFp
                .iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
         * @summary Create or modify alert
         * @param {string} accountId account id
         * @param {AlertRequest} body alert info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertPost(accountId, body, options) {
            return localVarFp
                .iserverAccountAccountIdAlertPost(accountId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The response will contain both active and inactive alerts, but it won\'t have MTA alert
         * @summary Get a list of available alerts
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdAlertsGet(accountId, options) {
            return localVarFp
                .iserverAccountAccountIdAlertsGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
         * @summary Get details of an alert
         * @param {string} id alert id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAlertIdGet(id, options) {
            return localVarFp
                .iserverAccountAlertIdGet(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
         * @summary Get MTA alert
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountMtaGet(options) {
            return localVarFp
                .iserverAccountMtaGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.AlertApiFactory = AlertApiFactory;
/**
 * AlertApi - object-oriented interface
 * @export
 * @class AlertApi
 * @extends {BaseAPI}
 */
class AlertApi extends base_1.BaseAPI {
    /**
     * Please note, if alertId is 0, it will activate/deactivate all alerts
     * @summary Activate or deactivate an alert
     * @param {string} accountId account id
     * @param {InlineObject3} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    iserverAccountAccountIdAlertActivatePost(accountId, body, options) {
        return (0, exports.AlertApiFp)(this.configuration)
            .iserverAccountAccountIdAlertActivatePost(accountId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Please be careful, if alertId is 0, it will delete all alerts
     * @summary Delete an alert
     * @param {string} accountId account id
     * @param {string} alertId alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options) {
        return (0, exports.AlertApiFp)(this.configuration)
            .iserverAccountAccountIdAlertAlertIdDelete(accountId, alertId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Please note here, DO NOT pass orderId when creating a new alert, toolId is only required for MTA alert
     * @summary Create or modify alert
     * @param {string} accountId account id
     * @param {AlertRequest} body alert info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    iserverAccountAccountIdAlertPost(accountId, body, options) {
        return (0, exports.AlertApiFp)(this.configuration)
            .iserverAccountAccountIdAlertPost(accountId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The response will contain both active and inactive alerts, but it won\'t have MTA alert
     * @summary Get a list of available alerts
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    iserverAccountAccountIdAlertsGet(accountId, options) {
        return (0, exports.AlertApiFp)(this.configuration)
            .iserverAccountAccountIdAlertsGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Use the endpoint /iserver/account/:accountId/alerts to receive the alert id. The order_id in the response is the alert id.
     * @summary Get details of an alert
     * @param {string} id alert id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    iserverAccountAlertIdGet(id, options) {
        return (0, exports.AlertApiFp)(this.configuration)
            .iserverAccountAlertIdGet(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Each login user only has one mobile trading assistant (MTA) alert with it\'s own unique tool id. The tool id cannot be changed. When modified a new order Id is generated. MTA alerts can not be created or deleted. If you call delete /iserver/account/:accountId/alert/:alertId, it will reset MTA to default. See [here](https://www.interactivebrokers.com/en/software/mobileiphonemobile/mobileiphone.htm#monitor/trading-assistant.htm) for more information on MTA alerts.
     * @summary Get MTA alert
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AlertApi
     */
    iserverAccountMtaGet(options) {
        return (0, exports.AlertApiFp)(this.configuration)
            .iserverAccountMtaGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.AlertApi = AlertApi;
/**
 * CCPBetaApi - axios parameter creator
 * @export
 */
const CCPBetaApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Provides the list of tradeable accounts
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAccountGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ccp/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
         * @summary Start CCP Session
         * @param {boolean} [compete] Allow competing CCP session to run
         * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
         * @param {string} [mac] Local MAC Address
         * @param {string} [machineId] Local machine ID
         * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthInitPost: (compete, locale, mac, machineId, username, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ccp/auth/init`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new URLSearchParams();
            if (compete !== undefined) {
                localVarFormParams.set("compete", compete);
            }
            if (locale !== undefined) {
                localVarFormParams.set("locale", locale);
            }
            if (mac !== undefined) {
                localVarFormParams.set("mac", mac);
            }
            if (machineId !== undefined) {
                localVarFormParams.set("machineId", machineId);
            }
            if (username !== undefined) {
                localVarFormParams.set("username", username);
            }
            localVarHeaderParameter["Content-Type"] =
                "application/x-www-form-urlencoded";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = localVarFormParams.toString();
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Session Token Authentication
         * @summary Complete CCP Session
         * @param {InlineObject2} [auth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthResponsePost: (auth, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ccp/auth/response`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(auth, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
         * @summary Delete Order
         * @param {string} acct Account Number
         * @param {number} id Order Identifier of original submit order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderDelete: (acct, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acct' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderDelete", "acct", acct);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderDelete", "id", id);
            const localVarPath = `/ccp/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (acct !== undefined) {
                localVarQueryParameter["acct"] = acct;
            }
            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Submits an Order.
         * @summary Submit Order
         * @param {string} acct User Account
         * @param {number} conid Contract identifier from IBKR\&#39;s database.
         * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
         * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
         * @param {number} qty Order Quantity
         * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
         * @param {'sell' | 'buy'} [side] Side
         * @param {number} [price] Order Price; required if order type is limit
         * @param {'IOC' | 'GTC'} [tif] Time in Force
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPost: (acct, conid, ccy, exchange, qty, type, side, price, tif, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acct' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPost", "acct", acct);
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPost", "conid", conid);
            // verify required parameter 'ccy' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPost", "ccy", ccy);
            // verify required parameter 'exchange' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPost", "exchange", exchange);
            // verify required parameter 'qty' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPost", "qty", qty);
            const localVarPath = `/ccp/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (acct !== undefined) {
                localVarQueryParameter["acct"] = acct;
            }
            if (conid !== undefined) {
                localVarQueryParameter["conid"] = conid;
            }
            if (ccy !== undefined) {
                localVarQueryParameter["ccy"] = ccy;
            }
            if (exchange !== undefined) {
                localVarQueryParameter["exchange"] = exchange;
            }
            if (qty !== undefined) {
                localVarQueryParameter["qty"] = qty;
            }
            if (type !== undefined) {
                localVarQueryParameter["type"] = type;
            }
            if (side !== undefined) {
                localVarQueryParameter["side"] = side;
            }
            if (price !== undefined) {
                localVarQueryParameter["price"] = price;
            }
            if (tif !== undefined) {
                localVarQueryParameter["tif"] = tif;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
         * @summary Update Order
         * @param {string} acct User Account
         * @param {number} id Order ID to be modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPut: (acct, id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acct' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPut", "acct", acct);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrderPut", "id", id);
            const localVarPath = `/ccp/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (acct !== undefined) {
                localVarQueryParameter["acct"] = acct;
            }
            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get status for all orders
         * @summary Order Status
         * @param {string} acct User Account
         * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrdersGet: (acct, cancelled, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'acct' is not null or undefined
            (0, common_1.assertParamExists)("ccpOrdersGet", "acct", acct);
            const localVarPath = `/ccp/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (acct !== undefined) {
                localVarQueryParameter["acct"] = acct;
            }
            if (cancelled !== undefined) {
                localVarQueryParameter["cancelled"] = cancelled;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * List of positions
         * @summary Positions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpPositionsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ccp/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
         * @summary CCP Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpStatusGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ccp/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get a list of Trades, by default, the list is from today midnight to Date.now().
         * @summary Trades
         * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
         * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpTradesGet: (from, to, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ccp/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (from !== undefined) {
                localVarQueryParameter["from"] = from;
            }
            if (to !== undefined) {
                localVarQueryParameter["to"] = to;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.CCPBetaApiAxiosParamCreator = CCPBetaApiAxiosParamCreator;
/**
 * CCPBetaApi - functional programming interface
 * @export
 */
const CCPBetaApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CCPBetaApiAxiosParamCreator)(configuration);
    return {
        /**
         * Provides the list of tradeable accounts
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAccountGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpAccountGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
         * @summary Start CCP Session
         * @param {boolean} [compete] Allow competing CCP session to run
         * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
         * @param {string} [mac] Local MAC Address
         * @param {string} [machineId] Local machine ID
         * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthInitPost(compete, locale, mac, machineId, username, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpAuthInitPost(compete, locale, mac, machineId, username, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Session Token Authentication
         * @summary Complete CCP Session
         * @param {InlineObject2} [auth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthResponsePost(auth, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpAuthResponsePost(auth, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
         * @summary Delete Order
         * @param {string} acct Account Number
         * @param {number} id Order Identifier of original submit order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderDelete(acct, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpOrderDelete(acct, id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Submits an Order.
         * @summary Submit Order
         * @param {string} acct User Account
         * @param {number} conid Contract identifier from IBKR\&#39;s database.
         * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
         * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
         * @param {number} qty Order Quantity
         * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
         * @param {'sell' | 'buy'} [side] Side
         * @param {number} [price] Order Price; required if order type is limit
         * @param {'IOC' | 'GTC'} [tif] Time in Force
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
         * @summary Update Order
         * @param {string} acct User Account
         * @param {number} id Order ID to be modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPut(acct, id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpOrderPut(acct, id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get status for all orders
         * @summary Order Status
         * @param {string} acct User Account
         * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrdersGet(acct, cancelled, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpOrdersGet(acct, cancelled, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * List of positions
         * @summary Positions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpPositionsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpPositionsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
         * @summary CCP Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpStatusGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpStatusGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get a list of Trades, by default, the list is from today midnight to Date.now().
         * @summary Trades
         * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
         * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpTradesGet(from, to, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ccpTradesGet(from, to, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.CCPBetaApiFp = CCPBetaApiFp;
/**
 * CCPBetaApi - factory interface
 * @export
 */
const CCPBetaApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CCPBetaApiFp)(configuration);
    return {
        /**
         * Provides the list of tradeable accounts
         * @summary Brokerage Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAccountGet(options) {
            return localVarFp
                .ccpAccountGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
         * @summary Start CCP Session
         * @param {boolean} [compete] Allow competing CCP session to run
         * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
         * @param {string} [mac] Local MAC Address
         * @param {string} [machineId] Local machine ID
         * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthInitPost(compete, locale, mac, machineId, username, options) {
            return localVarFp
                .ccpAuthInitPost(compete, locale, mac, machineId, username, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Session Token Authentication
         * @summary Complete CCP Session
         * @param {InlineObject2} [auth]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpAuthResponsePost(auth, options) {
            return localVarFp
                .ccpAuthResponsePost(auth, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
         * @summary Delete Order
         * @param {string} acct Account Number
         * @param {number} id Order Identifier of original submit order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderDelete(acct, id, options) {
            return localVarFp
                .ccpOrderDelete(acct, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Submits an Order.
         * @summary Submit Order
         * @param {string} acct User Account
         * @param {number} conid Contract identifier from IBKR\&#39;s database.
         * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
         * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
         * @param {number} qty Order Quantity
         * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
         * @param {'sell' | 'buy'} [side] Side
         * @param {number} [price] Order Price; required if order type is limit
         * @param {'IOC' | 'GTC'} [tif] Time in Force
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options) {
            return localVarFp
                .ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
         * @summary Update Order
         * @param {string} acct User Account
         * @param {number} id Order ID to be modified
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrderPut(acct, id, options) {
            return localVarFp
                .ccpOrderPut(acct, id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get status for all orders
         * @summary Order Status
         * @param {string} acct User Account
         * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpOrdersGet(acct, cancelled, options) {
            return localVarFp
                .ccpOrdersGet(acct, cancelled, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * List of positions
         * @summary Positions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpPositionsGet(options) {
            return localVarFp
                .ccpPositionsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
         * @summary CCP Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpStatusGet(options) {
            return localVarFp
                .ccpStatusGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get a list of Trades, by default, the list is from today midnight to Date.now().
         * @summary Trades
         * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
         * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ccpTradesGet(from, to, options) {
            return localVarFp
                .ccpTradesGet(from, to, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.CCPBetaApiFactory = CCPBetaApiFactory;
/**
 * CCPBetaApi - object-oriented interface
 * @export
 * @class CCPBetaApi
 * @extends {BaseAPI}
 */
class CCPBetaApi extends base_1.BaseAPI {
    /**
     * Provides the list of tradeable accounts
     * @summary Brokerage Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpAccountGet(options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpAccountGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Initiate a brokerage session to CCP. Only one brokerage session type can run at a time. If an existing brokerage session to iServer is running then call the endpoint /logout first. Note at this time only order management is possible from CCP session, market data and scanner endpoints can\'t be used since they are only available from iServer session. Work is in progress to provide new CCP endpoints for market data and scanners.
     * @summary Start CCP Session
     * @param {boolean} [compete] Allow competing CCP session to run
     * @param {string} [locale] Concatenate value for language and region, set to \\\&quot;en_US\\\&quot;
     * @param {string} [mac] Local MAC Address
     * @param {string} [machineId] Local machine ID
     * @param {string} [username] Login user, set to dash \\\&quot;-\\\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpAuthInitPost(compete, locale, mac, machineId, username, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpAuthInitPost(compete, locale, mac, machineId, username, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Session Token Authentication
     * @summary Complete CCP Session
     * @param {InlineObject2} [auth]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpAuthResponsePost(auth, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpAuthResponsePost(auth, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Sends an Order cancellation request. The status of the order can be queried through /ccp/order. Passing arguments as GET is also supported (requires passing action=delete) (GET is meant for development only)
     * @summary Delete Order
     * @param {string} acct Account Number
     * @param {number} id Order Identifier of original submit order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpOrderDelete(acct, id, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpOrderDelete(acct, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Submits an Order.
     * @summary Submit Order
     * @param {string} acct User Account
     * @param {number} conid Contract identifier from IBKR\&#39;s database.
     * @param {'USD' | 'GBP' | 'EUR'} ccy Contract Currency
     * @param {'NYSE' | 'CBOE' | 'NYMEX'} exchange Exchange
     * @param {number} qty Order Quantity
     * @param {'limit' | 'market'} [type] Order Price; required if order type is limit
     * @param {'sell' | 'buy'} [side] Side
     * @param {number} [price] Order Price; required if order type is limit
     * @param {'IOC' | 'GTC'} [tif] Time in Force
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpOrderPost(acct, conid, ccy, exchange, qty, type, side, price, tif, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an Order. Updating an order requires the same arguments as placing an order besides the conid. Note: The status of the order can be queried through GET /ccp/order.
     * @summary Update Order
     * @param {string} acct User Account
     * @param {number} id Order ID to be modified
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpOrderPut(acct, id, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpOrderPut(acct, id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get status for all orders
     * @summary Order Status
     * @param {string} acct User Account
     * @param {boolean} [cancelled] Return only Rejected or Cancelled orders since today midnight
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpOrdersGet(acct, cancelled, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpOrdersGet(acct, cancelled, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * List of positions
     * @summary Positions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpPositionsGet(options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpPositionsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Provide the current CCP session status. When using the Gateway this endpoint will also initiate a brokerage session to CCP by sending /auth/init and response.
     * @summary CCP Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpStatusGet(options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpStatusGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get a list of Trades, by default, the list is from today midnight to Date.now().
     * @summary Trades
     * @param {string} [from] From Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..)
     * @param {string} [to] To Date (YYYYMMDD-HH:mm:ss) or offset (-1,-2,-3..). To value should be bigger than from value.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CCPBetaApi
     */
    ccpTradesGet(from, to, options) {
        return (0, exports.CCPBetaApiFp)(this.configuration)
            .ccpTradesGet(from, to, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.CCPBetaApi = CCPBetaApi;
/**
 * ContractApi - axios parameter creator
 * @export
 */
const ContractApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
         * @summary IB Algo Params
         * @param {string} conid IBKR contract identifier
         * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
         * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
         * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidAlgosGet: (conid, algos, addDescription, addParams, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverContractConidAlgosGet", "conid", conid);
            const localVarPath = `/iserver/contract/{conid}/algos`.replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (algos !== undefined) {
                localVarQueryParameter["algos"] = algos;
            }
            if (addDescription !== undefined) {
                localVarQueryParameter["addDescription"] = addDescription;
            }
            if (addParams !== undefined) {
                localVarQueryParameter["addParams"] = addParams;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns trading related rules and info for contract
         * @summary Info and Rules
         * @param {string} conid IBKR contract identifier
         * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoAndRulesGet: (conid, isBuy, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverContractConidInfoAndRulesGet", "conid", conid);
            // verify required parameter 'isBuy' is not null or undefined
            (0, common_1.assertParamExists)("iserverContractConidInfoAndRulesGet", "isBuy", isBuy);
            const localVarPath = `/iserver/contract/{conid}/info-and-rules`.replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (isBuy !== undefined) {
                localVarQueryParameter["isBuy"] = isBuy;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
         * @summary Contract Details
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoGet: (conid, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverContractConidInfoGet", "conid", conid);
            const localVarPath = `/iserver/contract/{conid}/info`.replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
         * @summary Secdef Info
         * @param {string} conid underlying contract id
         * @param {string} sectype FUT/OPT/WAR/CASH/CFD
         * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
         * @param {string} [exchange] optional, default is SMART
         * @param {string} [strike] optional, only required for OPT/WAR
         * @param {string} [right] C for call, P for put
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefInfoGet: (conid, sectype, month, exchange, strike, right, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverSecdefInfoGet", "conid", conid);
            // verify required parameter 'sectype' is not null or undefined
            (0, common_1.assertParamExists)("iserverSecdefInfoGet", "sectype", sectype);
            const localVarPath = `/iserver/secdef/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (conid !== undefined) {
                localVarQueryParameter["conid"] = conid;
            }
            if (sectype !== undefined) {
                localVarQueryParameter["sectype"] = sectype;
            }
            if (month !== undefined) {
                localVarQueryParameter["month"] = month;
            }
            if (exchange !== undefined) {
                localVarQueryParameter["exchange"] = exchange;
            }
            if (strike !== undefined) {
                localVarQueryParameter["strike"] = strike;
            }
            if (right !== undefined) {
                localVarQueryParameter["right"] = right;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
         * @summary Search by Symbol or Name
         * @param {InlineObject8} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefSearchPost: (symbol, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'symbol' is not null or undefined
            (0, common_1.assertParamExists)("iserverSecdefSearchPost", "symbol", symbol);
            const localVarPath = `/iserver/secdef/search`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(symbol, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
         * @summary Search Strikes
         * @param {string} conid contract id of the underlying contract
         * @param {string} sectype OPT/WAR
         * @param {string} month contract month
         * @param {string} [exchange] optional, default is SMART
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefStrikesGet: (conid, sectype, month, exchange, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverSecdefStrikesGet", "conid", conid);
            // verify required parameter 'sectype' is not null or undefined
            (0, common_1.assertParamExists)("iserverSecdefStrikesGet", "sectype", sectype);
            // verify required parameter 'month' is not null or undefined
            (0, common_1.assertParamExists)("iserverSecdefStrikesGet", "month", month);
            const localVarPath = `/iserver/secdef/strikes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (conid !== undefined) {
                localVarQueryParameter["conid"] = conid;
            }
            if (sectype !== undefined) {
                localVarQueryParameter["sectype"] = sectype;
            }
            if (month !== undefined) {
                localVarQueryParameter["month"] = month;
            }
            if (exchange !== undefined) {
                localVarQueryParameter["exchange"] = exchange;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of non-expired future contracts for given symbol(s)
         * @summary Security Futures by Symbol
         * @param {string} symbols list of case-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvFuturesGet: (symbols, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'symbols' is not null or undefined
            (0, common_1.assertParamExists)("trsrvFuturesGet", "symbols", symbols);
            const localVarPath = `/trsrv/futures`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (symbols !== undefined) {
                localVarQueryParameter["symbols"] = symbols;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of security definitions for the given conids
         * @summary Secdef by Conid
         * @param {InlineObject9} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefPost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("trsrvSecdefPost", "body", body);
            const localVarPath = `/trsrv/secdef`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the trading schedule up to a month for the requested contract
         * @summary Get trading schedule for symbol
         * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
         * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
         * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
         * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefScheduleGet: (assetClass, symbol, exchange, exchangeFilter, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'assetClass' is not null or undefined
            (0, common_1.assertParamExists)("trsrvSecdefScheduleGet", "assetClass", assetClass);
            // verify required parameter 'symbol' is not null or undefined
            (0, common_1.assertParamExists)("trsrvSecdefScheduleGet", "symbol", symbol);
            const localVarPath = `/trsrv/secdef/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (assetClass !== undefined) {
                localVarQueryParameter["assetClass"] = assetClass;
            }
            if (symbol !== undefined) {
                localVarQueryParameter["symbol"] = symbol;
            }
            if (exchange !== undefined) {
                localVarQueryParameter["exchange"] = exchange;
            }
            if (exchangeFilter !== undefined) {
                localVarQueryParameter["exchangeFilter"] = exchangeFilter;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object contains all stock contracts for given symbol(s)
         * @summary Security Stocks by Symbol
         * @param {string} symbols list of upper-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvStocksGet: (symbols, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'symbols' is not null or undefined
            (0, common_1.assertParamExists)("trsrvStocksGet", "symbols", symbols);
            const localVarPath = `/trsrv/stocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (symbols !== undefined) {
                localVarQueryParameter["symbols"] = symbols;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ContractApiAxiosParamCreator = ContractApiAxiosParamCreator;
/**
 * ContractApi - functional programming interface
 * @export
 */
const ContractApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ContractApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
         * @summary IB Algo Params
         * @param {string} conid IBKR contract identifier
         * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
         * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
         * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns trading related rules and info for contract
         * @summary Info and Rules
         * @param {string} conid IBKR contract identifier
         * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoAndRulesGet(conid, isBuy, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverContractConidInfoAndRulesGet(conid, isBuy, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
         * @summary Contract Details
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoGet(conid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverContractConidInfoGet(conid, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
         * @summary Secdef Info
         * @param {string} conid underlying contract id
         * @param {string} sectype FUT/OPT/WAR/CASH/CFD
         * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
         * @param {string} [exchange] optional, default is SMART
         * @param {string} [strike] optional, only required for OPT/WAR
         * @param {string} [right] C for call, P for put
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
         * @summary Search by Symbol or Name
         * @param {InlineObject8} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefSearchPost(symbol, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverSecdefSearchPost(symbol, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
         * @summary Search Strikes
         * @param {string} conid contract id of the underlying contract
         * @param {string} sectype OPT/WAR
         * @param {string} month contract month
         * @param {string} [exchange] optional, default is SMART
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefStrikesGet(conid, sectype, month, exchange, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverSecdefStrikesGet(conid, sectype, month, exchange, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of non-expired future contracts for given symbol(s)
         * @summary Security Futures by Symbol
         * @param {string} symbols list of case-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvFuturesGet(symbols, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.trsrvFuturesGet(symbols, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of security definitions for the given conids
         * @summary Secdef by Conid
         * @param {InlineObject9} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefPost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.trsrvSecdefPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the trading schedule up to a month for the requested contract
         * @summary Get trading schedule for symbol
         * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
         * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
         * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
         * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns an object contains all stock contracts for given symbol(s)
         * @summary Security Stocks by Symbol
         * @param {string} symbols list of upper-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvStocksGet(symbols, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.trsrvStocksGet(symbols, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ContractApiFp = ContractApiFp;
/**
 * ContractApi - factory interface
 * @export
 */
const ContractApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ContractApiFp)(configuration);
    return {
        /**
         * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
         * @summary IB Algo Params
         * @param {string} conid IBKR contract identifier
         * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
         * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
         * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options) {
            return localVarFp
                .iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns trading related rules and info for contract
         * @summary Info and Rules
         * @param {string} conid IBKR contract identifier
         * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoAndRulesGet(conid, isBuy, options) {
            return localVarFp
                .iserverContractConidInfoAndRulesGet(conid, isBuy, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
         * @summary Contract Details
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverContractConidInfoGet(conid, options) {
            return localVarFp
                .iserverContractConidInfoGet(conid, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
         * @summary Secdef Info
         * @param {string} conid underlying contract id
         * @param {string} sectype FUT/OPT/WAR/CASH/CFD
         * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
         * @param {string} [exchange] optional, default is SMART
         * @param {string} [strike] optional, only required for OPT/WAR
         * @param {string} [right] C for call, P for put
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options) {
            return localVarFp
                .iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
         * @summary Search by Symbol or Name
         * @param {InlineObject8} symbol
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefSearchPost(symbol, options) {
            return localVarFp
                .iserverSecdefSearchPost(symbol, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
         * @summary Search Strikes
         * @param {string} conid contract id of the underlying contract
         * @param {string} sectype OPT/WAR
         * @param {string} month contract month
         * @param {string} [exchange] optional, default is SMART
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverSecdefStrikesGet(conid, sectype, month, exchange, options) {
            return localVarFp
                .iserverSecdefStrikesGet(conid, sectype, month, exchange, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of non-expired future contracts for given symbol(s)
         * @summary Security Futures by Symbol
         * @param {string} symbols list of case-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvFuturesGet(symbols, options) {
            return localVarFp
                .trsrvFuturesGet(symbols, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of security definitions for the given conids
         * @summary Secdef by Conid
         * @param {InlineObject9} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefPost(body, options) {
            return localVarFp
                .trsrvSecdefPost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns the trading schedule up to a month for the requested contract
         * @summary Get trading schedule for symbol
         * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
         * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
         * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
         * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options) {
            return localVarFp
                .trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an object contains all stock contracts for given symbol(s)
         * @summary Security Stocks by Symbol
         * @param {string} symbols list of upper-sensitive symbols separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trsrvStocksGet(symbols, options) {
            return localVarFp
                .trsrvStocksGet(symbols, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.ContractApiFactory = ContractApiFactory;
/**
 * ContractApi - object-oriented interface
 * @export
 * @class ContractApi
 * @extends {BaseAPI}
 */
class ContractApi extends base_1.BaseAPI {
    /**
     * Returns supported IB Algos for contract. Must be called a second time to query the list of available parameters.
     * @summary IB Algo Params
     * @param {string} conid IBKR contract identifier
     * @param {string} [algos] List of algo ids delimited by \&quot;;\&quot; to filter by. Max of 8 algos ids can be specified.
     * @param {string} [addDescription] Whether or not to add algo descriptions to response. Set to 1 for yes, 0 for no.
     * @param {string} [addParams] Whether or not to show algo parameters.  Set to 1 for yes, 0 for no.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .iserverContractConidAlgosGet(conid, algos, addDescription, addParams, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns trading related rules and info for contract
     * @summary Info and Rules
     * @param {string} conid IBKR contract identifier
     * @param {boolean} isBuy Side of the market rules apply too. Set to true for Buy Orders, set to false for Sell Orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    iserverContractConidInfoAndRulesGet(conid, isBuy, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .iserverContractConidInfoAndRulesGet(conid, isBuy, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Using the Contract Identifier get contract info. You can use this to prefill your order before you submit an order
     * @summary Contract Details
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    iserverContractConidInfoGet(conid, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .iserverContractConidInfoGet(conid, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Provides Contract Details of Futures, Options, Warrants, Cash and CFDs based on conid. To get the strike price for Options/Warrants use \"/iserver/secdef/strikes\" endpoint. Must call /secdef/search for the underlying contract first.
     * @summary Secdef Info
     * @param {string} conid underlying contract id
     * @param {string} sectype FUT/OPT/WAR/CASH/CFD
     * @param {string} [month] contract month, only required for FUT/OPT/WAR in the format MMMYY, example JAN00
     * @param {string} [exchange] optional, default is SMART
     * @param {string} [strike] optional, only required for OPT/WAR
     * @param {string} [right] C for call, P for put
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .iserverSecdefInfoGet(conid, sectype, month, exchange, strike, right, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Search by underlying symbol or company name. Relays back what derivative contract(s) it has. This endpoint must be called before using /secdef/info. If company name is specified will only receive limited response: conid, companyName, companyHeader and symbol.
     * @summary Search by Symbol or Name
     * @param {InlineObject8} symbol
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    iserverSecdefSearchPost(symbol, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .iserverSecdefSearchPost(symbol, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Query strikes for Options/Warrants. For the conid of the underlying contract, available contract months and exchanges use \"/iserver/secdef/search\"
     * @summary Search Strikes
     * @param {string} conid contract id of the underlying contract
     * @param {string} sectype OPT/WAR
     * @param {string} month contract month
     * @param {string} [exchange] optional, default is SMART
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    iserverSecdefStrikesGet(conid, sectype, month, exchange, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .iserverSecdefStrikesGet(conid, sectype, month, exchange, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of non-expired future contracts for given symbol(s)
     * @summary Security Futures by Symbol
     * @param {string} symbols list of case-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    trsrvFuturesGet(symbols, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .trsrvFuturesGet(symbols, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of security definitions for the given conids
     * @summary Secdef by Conid
     * @param {InlineObject9} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    trsrvSecdefPost(body, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .trsrvSecdefPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the trading schedule up to a month for the requested contract
     * @summary Get trading schedule for symbol
     * @param {string} assetClass specify the asset class of the contract. Available values-- Stock: STK, Option: OPT, Future: FUT, Contract For Difference: CFD, Warrant: WAR, Forex: SWP, Mutual Fund: FND, Bond: BND, Inter-Commodity Spreads: ICS
     * @param {string} symbol Underlying Symbol for specified contract, for example \&#39;AAPL\&#39; for US Stock - Apple Inc.
     * @param {string} [exchange] Native exchange for contract, for example \&#39;NASDAQ\&#39; for US Stock - Apple Inc.
     * @param {string} [exchangeFilter] Response only returns trading schedule for specified exchange
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .trsrvSecdefScheduleGet(assetClass, symbol, exchange, exchangeFilter, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object contains all stock contracts for given symbol(s)
     * @summary Security Stocks by Symbol
     * @param {string} symbols list of upper-sensitive symbols separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContractApi
     */
    trsrvStocksGet(symbols, options) {
        return (0, exports.ContractApiFp)(this.configuration)
            .trsrvStocksGet(symbols, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.ContractApi = ContractApi;
/**
 * FYIApi - axios parameter creator
 * @export
 */
const FYIApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Delete a device
         * @param {string} deviceId device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDeviceIdDelete: (deviceId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'deviceId' is not null or undefined
            (0, common_1.assertParamExists)("fyiDeliveryoptionsDeviceIdDelete", "deviceId", deviceId);
            const localVarPath = `/fyi/deliveryoptions/{deviceId}`.replace(`{${"deviceId"}}`, encodeURIComponent(String(deviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Enable/Disable device option
         * @param {InlineObject1} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDevicePost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("fyiDeliveryoptionsDevicePost", "body", body);
            const localVarPath = `/fyi/deliveryoptions/device`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Enable/Disable email option
         * @param {string} enabled true/false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsEmailPut: (enabled, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'enabled' is not null or undefined
            (0, common_1.assertParamExists)("fyiDeliveryoptionsEmailPut", "enabled", enabled);
            const localVarPath = `/fyi/deliveryoptions/email`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (enabled !== undefined) {
                localVarQueryParameter["enabled"] = enabled;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * options for sending fyis to email and other devices
         * @summary Get delivery options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fyi/deliveryoptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get disclaimer for a certain kind of fyi
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodeGet: (typecode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'typecode' is not null or undefined
            (0, common_1.assertParamExists)("fyiDisclaimerTypecodeGet", "typecode", typecode);
            const localVarPath = `/fyi/disclaimer/{typecode}`.replace(`{${"typecode"}}`, encodeURIComponent(String(typecode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Mark disclaimer read
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodePut: (typecode, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'typecode' is not null or undefined
            (0, common_1.assertParamExists)("fyiDisclaimerTypecodePut", "typecode", typecode);
            const localVarPath = `/fyi/disclaimer/{typecode}`.replace(`{${"typecode"}}`, encodeURIComponent(String(typecode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of notifications
         * @param {string} max max number of fyis in response
         * @param {string} [exclude] if set, don\&#39;t set include
         * @param {string} [include] if set, don\&#39;t set exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsGet: (max, exclude, include, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'max' is not null or undefined
            (0, common_1.assertParamExists)("fyiNotificationsGet", "max", max);
            const localVarPath = `/fyi/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (exclude !== undefined) {
                localVarQueryParameter["exclude"] = exclude;
            }
            if (include !== undefined) {
                localVarQueryParameter["include"] = include;
            }
            if (max !== undefined) {
                localVarQueryParameter["max"] = max;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get more notifications based on a certain one
         * @param {string} id id of last notification in the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsMoreGet: (id, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)("fyiNotificationsMoreGet", "id", id);
            const localVarPath = `/fyi/notifications/more`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter["id"] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Get a list of notifications
         * @param {string} notificationId mark a notification read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsNotificationIdPut: (notificationId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'notificationId' is not null or undefined
            (0, common_1.assertParamExists)("fyiNotificationsNotificationIdPut", "notificationId", notificationId);
            const localVarPath = `/fyi/notifications/{notificationId}`.replace(`{${"notificationId"}}`, encodeURIComponent(String(notificationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "PUT" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Return the current choices of subscriptions, we can toggle the option
         * @summary Get a list of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fyi/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Configure which typecode you would like to enable/disable.
         * @summary Enable/Disable certain subscription
         * @param {string} typecode fyi code
         * @param {InlineObject} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsTypecodePost: (typecode, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'typecode' is not null or undefined
            (0, common_1.assertParamExists)("fyiSettingsTypecodePost", "typecode", typecode);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("fyiSettingsTypecodePost", "body", body);
            const localVarPath = `/fyi/settings/{typecode}`.replace(`{${"typecode"}}`, encodeURIComponent(String(typecode)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns the total number of unread fyis
         * @summary Get unread number of fyis. The HTTP method POST is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiUnreadnumberGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/fyi/unreadnumber`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.FYIApiAxiosParamCreator = FYIApiAxiosParamCreator;
/**
 * FYIApi - functional programming interface
 * @export
 */
const FYIApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.FYIApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Delete a device
         * @param {string} deviceId device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDeviceIdDelete(deviceId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiDeliveryoptionsDeviceIdDelete(deviceId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Enable/Disable device option
         * @param {InlineObject1} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDevicePost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiDeliveryoptionsDevicePost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Enable/Disable email option
         * @param {string} enabled true/false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsEmailPut(enabled, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiDeliveryoptionsEmailPut(enabled, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * options for sending fyis to email and other devices
         * @summary Get delivery options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiDeliveryoptionsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get disclaimer for a certain kind of fyi
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodeGet(typecode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiDisclaimerTypecodeGet(typecode, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Mark disclaimer read
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodePut(typecode, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiDisclaimerTypecodePut(typecode, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a list of notifications
         * @param {string} max max number of fyis in response
         * @param {string} [exclude] if set, don\&#39;t set include
         * @param {string} [include] if set, don\&#39;t set exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsGet(max, exclude, include, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiNotificationsGet(max, exclude, include, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get more notifications based on a certain one
         * @param {string} id id of last notification in the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsMoreGet(id, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiNotificationsMoreGet(id, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Get a list of notifications
         * @param {string} notificationId mark a notification read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsNotificationIdPut(notificationId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiNotificationsNotificationIdPut(notificationId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Return the current choices of subscriptions, we can toggle the option
         * @summary Get a list of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiSettingsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Configure which typecode you would like to enable/disable.
         * @summary Enable/Disable certain subscription
         * @param {string} typecode fyi code
         * @param {InlineObject} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsTypecodePost(typecode, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiSettingsTypecodePost(typecode, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns the total number of unread fyis
         * @summary Get unread number of fyis. The HTTP method POST is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiUnreadnumberGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.fyiUnreadnumberGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.FYIApiFp = FYIApiFp;
/**
 * FYIApi - factory interface
 * @export
 */
const FYIApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.FYIApiFp)(configuration);
    return {
        /**
         *
         * @summary Delete a device
         * @param {string} deviceId device ID
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDeviceIdDelete(deviceId, options) {
            return localVarFp
                .fyiDeliveryoptionsDeviceIdDelete(deviceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Enable/Disable device option
         * @param {InlineObject1} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsDevicePost(body, options) {
            return localVarFp
                .fyiDeliveryoptionsDevicePost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Enable/Disable email option
         * @param {string} enabled true/false
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsEmailPut(enabled, options) {
            return localVarFp
                .fyiDeliveryoptionsEmailPut(enabled, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * options for sending fyis to email and other devices
         * @summary Get delivery options
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDeliveryoptionsGet(options) {
            return localVarFp
                .fyiDeliveryoptionsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get disclaimer for a certain kind of fyi
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodeGet(typecode, options) {
            return localVarFp
                .fyiDisclaimerTypecodeGet(typecode, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Mark disclaimer read
         * @param {string} typecode fyi code, for example --M8, EA
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiDisclaimerTypecodePut(typecode, options) {
            return localVarFp
                .fyiDisclaimerTypecodePut(typecode, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of notifications
         * @param {string} max max number of fyis in response
         * @param {string} [exclude] if set, don\&#39;t set include
         * @param {string} [include] if set, don\&#39;t set exclude
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsGet(max, exclude, include, options) {
            return localVarFp
                .fyiNotificationsGet(max, exclude, include, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get more notifications based on a certain one
         * @param {string} id id of last notification in the list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsMoreGet(id, options) {
            return localVarFp
                .fyiNotificationsMoreGet(id, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get a list of notifications
         * @param {string} notificationId mark a notification read
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiNotificationsNotificationIdPut(notificationId, options) {
            return localVarFp
                .fyiNotificationsNotificationIdPut(notificationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Return the current choices of subscriptions, we can toggle the option
         * @summary Get a list of subscriptions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsGet(options) {
            return localVarFp
                .fyiSettingsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Configure which typecode you would like to enable/disable.
         * @summary Enable/Disable certain subscription
         * @param {string} typecode fyi code
         * @param {InlineObject} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiSettingsTypecodePost(typecode, body, options) {
            return localVarFp
                .fyiSettingsTypecodePost(typecode, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns the total number of unread fyis
         * @summary Get unread number of fyis. The HTTP method POST is also supported.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fyiUnreadnumberGet(options) {
            return localVarFp
                .fyiUnreadnumberGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.FYIApiFactory = FYIApiFactory;
/**
 * FYIApi - object-oriented interface
 * @export
 * @class FYIApi
 * @extends {BaseAPI}
 */
class FYIApi extends base_1.BaseAPI {
    /**
     *
     * @summary Delete a device
     * @param {string} deviceId device ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiDeliveryoptionsDeviceIdDelete(deviceId, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiDeliveryoptionsDeviceIdDelete(deviceId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Enable/Disable device option
     * @param {InlineObject1} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiDeliveryoptionsDevicePost(body, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiDeliveryoptionsDevicePost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Enable/Disable email option
     * @param {string} enabled true/false
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiDeliveryoptionsEmailPut(enabled, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiDeliveryoptionsEmailPut(enabled, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * options for sending fyis to email and other devices
     * @summary Get delivery options
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiDeliveryoptionsGet(options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiDeliveryoptionsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get disclaimer for a certain kind of fyi
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiDisclaimerTypecodeGet(typecode, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiDisclaimerTypecodeGet(typecode, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Mark disclaimer read
     * @param {string} typecode fyi code, for example --M8, EA
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiDisclaimerTypecodePut(typecode, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiDisclaimerTypecodePut(typecode, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of notifications
     * @param {string} max max number of fyis in response
     * @param {string} [exclude] if set, don\&#39;t set include
     * @param {string} [include] if set, don\&#39;t set exclude
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiNotificationsGet(max, exclude, include, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiNotificationsGet(max, exclude, include, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get more notifications based on a certain one
     * @param {string} id id of last notification in the list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiNotificationsMoreGet(id, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiNotificationsMoreGet(id, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get a list of notifications
     * @param {string} notificationId mark a notification read
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiNotificationsNotificationIdPut(notificationId, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiNotificationsNotificationIdPut(notificationId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Return the current choices of subscriptions, we can toggle the option
     * @summary Get a list of subscriptions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiSettingsGet(options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiSettingsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Configure which typecode you would like to enable/disable.
     * @summary Enable/Disable certain subscription
     * @param {string} typecode fyi code
     * @param {InlineObject} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiSettingsTypecodePost(typecode, body, options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiSettingsTypecodePost(typecode, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the total number of unread fyis
     * @summary Get unread number of fyis. The HTTP method POST is also supported.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FYIApi
     */
    fyiUnreadnumberGet(options) {
        return (0, exports.FYIApiFp)(this.configuration)
            .fyiUnreadnumberGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.FYIApi = FYIApi;
/**
 * IBCustApi - axios parameter creator
 * @export
 */
const IBCustApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns Applicant Id with all owner related entities
         * @summary IBCust Entity Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ibcustEntityInfoGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ibcust/entity/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.IBCustApiAxiosParamCreator = IBCustApiAxiosParamCreator;
/**
 * IBCustApi - functional programming interface
 * @export
 */
const IBCustApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.IBCustApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns Applicant Id with all owner related entities
         * @summary IBCust Entity Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ibcustEntityInfoGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ibcustEntityInfoGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.IBCustApiFp = IBCustApiFp;
/**
 * IBCustApi - factory interface
 * @export
 */
const IBCustApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.IBCustApiFp)(configuration);
    return {
        /**
         * Returns Applicant Id with all owner related entities
         * @summary IBCust Entity Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ibcustEntityInfoGet(options) {
            return localVarFp
                .ibcustEntityInfoGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.IBCustApiFactory = IBCustApiFactory;
/**
 * IBCustApi - object-oriented interface
 * @export
 * @class IBCustApi
 * @extends {BaseAPI}
 */
class IBCustApi extends base_1.BaseAPI {
    /**
     * Returns Applicant Id with all owner related entities
     * @summary IBCust Entity Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IBCustApi
     */
    ibcustEntityInfoGet(options) {
        return (0, exports.IBCustApiFp)(this.configuration)
            .ibcustEntityInfoGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.IBCustApi = IBCustApi;
/**
 * MarketDataApi - axios parameter creator
 * @export
 */
const MarketDataApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
         * @summary Market Data Cancel (Single)
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataConidUnsubscribeGet: (conid, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverMarketdataConidUnsubscribeGet", "conid", conid);
            const localVarPath = `/iserver/marketdata/{conid}/unsubscribe`.replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
         * @summary Market Data History
         * @param {string} conid contract id
         * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
         * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
         * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
         * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataHistoryGet: (conid, period, exchange, bar, outsideRth, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("iserverMarketdataHistoryGet", "conid", conid);
            // verify required parameter 'period' is not null or undefined
            (0, common_1.assertParamExists)("iserverMarketdataHistoryGet", "period", period);
            const localVarPath = `/iserver/marketdata/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (conid !== undefined) {
                localVarQueryParameter["conid"] = conid;
            }
            if (exchange !== undefined) {
                localVarQueryParameter["exchange"] = exchange;
            }
            if (period !== undefined) {
                localVarQueryParameter["period"] = period;
            }
            if (bar !== undefined) {
                localVarQueryParameter["bar"] = bar;
            }
            if (outsideRth !== undefined) {
                localVarQueryParameter["outsideRth"] = outsideRth;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Market Data
         * @param {string} conids list of conids separated by comma
         * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataSnapshotGet: (conids, since, fields, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conids' is not null or undefined
            (0, common_1.assertParamExists)("iserverMarketdataSnapshotGet", "conids", conids);
            const localVarPath = `/iserver/marketdata/snapshot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (conids !== undefined) {
                localVarQueryParameter["conids"] = conids;
            }
            if (since !== undefined) {
                localVarQueryParameter["since"] = since;
            }
            if (fields !== undefined) {
                localVarQueryParameter["fields"] = fields;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
         * @summary Market Data Cancel (All)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataUnsubscribeallGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/marketdata/unsubscribeall`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.MarketDataApiAxiosParamCreator = MarketDataApiAxiosParamCreator;
/**
 * MarketDataApi - functional programming interface
 * @export
 */
const MarketDataApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.MarketDataApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
         * @summary Market Data Cancel (Single)
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataConidUnsubscribeGet(conid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverMarketdataConidUnsubscribeGet(conid, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
         * @summary Market Data History
         * @param {string} conid contract id
         * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
         * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
         * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
         * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Market Data
         * @param {string} conids list of conids separated by comma
         * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataSnapshotGet(conids, since, fields, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverMarketdataSnapshotGet(conids, since, fields, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
         * @summary Market Data Cancel (All)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataUnsubscribeallGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverMarketdataUnsubscribeallGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.MarketDataApiFp = MarketDataApiFp;
/**
 * MarketDataApi - factory interface
 * @export
 */
const MarketDataApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.MarketDataApiFp)(configuration);
    return {
        /**
         * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
         * @summary Market Data Cancel (Single)
         * @param {string} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataConidUnsubscribeGet(conid, options) {
            return localVarFp
                .iserverMarketdataConidUnsubscribeGet(conid, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
         * @summary Market Data History
         * @param {string} conid contract id
         * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
         * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
         * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
         * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options) {
            return localVarFp
                .iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Market Data
         * @param {string} conids list of conids separated by comma
         * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
         * @param {string} [fields] list of fields separated by comma
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataSnapshotGet(conids, since, fields, options) {
            return localVarFp
                .iserverMarketdataSnapshotGet(conids, since, fields, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
         * @summary Market Data Cancel (All)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverMarketdataUnsubscribeallGet(options) {
            return localVarFp
                .iserverMarketdataUnsubscribeallGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.MarketDataApiFactory = MarketDataApiFactory;
/**
 * MarketDataApi - object-oriented interface
 * @export
 * @class MarketDataApi
 * @extends {BaseAPI}
 */
class MarketDataApi extends base_1.BaseAPI {
    /**
     * Cancel market data for given conid. To cancel all market data request(s), see /iserver/marketdata/unsubscribeall.
     * @summary Market Data Cancel (Single)
     * @param {string} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    iserverMarketdataConidUnsubscribeGet(conid, options) {
        return (0, exports.MarketDataApiFp)(this.configuration)
            .iserverMarketdataConidUnsubscribeGet(conid, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get historical market Data for given conid, length of data is controlled by \'period\' and \'bar\'. Formatted as: min=minute, h=hour, d=day, w=week, m=month, y=year e.g. period =1y with bar =1w returns 52 data points (Max of 1000 data points supported). **Note**: There\'s a limit of 5 concurrent requests. Excessive requests will return a \'Too many requests\' status 429 response.
     * @summary Market Data History
     * @param {string} conid contract id
     * @param {string} period available time period-- {1-30}min, {1-8}h, {1-1000}d, {1-792}w, {1-182}m, {1-15}y
     * @param {string} [exchange] Exchange of the conid (e.g. ISLAND, NYSE, etc.). Default value is empty which corresponds to primary exchange of the conid.
     * @param {string} [bar] possible value-- 1min, 2min, 3min, 5min, 10min, 15min, 30min, 1h, 2h, 3h, 4h, 8h, 1d, 1w, 1m
     * @param {boolean} [outsideRth] For contracts that support it, will determine if historical data includes outside of regular trading hours.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options) {
        return (0, exports.MarketDataApiFp)(this.configuration)
            .iserverMarketdataHistoryGet(conid, period, exchange, bar, outsideRth, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Get Market Data for the given conid(s). The endpoint will return by default bid, ask, last, change, change pct, close, listing exchange. See response fields for a list of available fields that can be request via fields argument. The endpoint /iserver/accounts must be called prior to /iserver/marketdata/snapshot. For derivative contracts the endpoint /iserver/secdef/search must be called first. First /snapshot endpoint call for given conid will initiate the market data request.  To receive all available fields the /snapshot endpoint will need to be called several times. To receive streaming market data the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Market Data
     * @param {string} conids list of conids separated by comma
     * @param {number} [since] time period since which updates are required. uses epoch time with milliseconds.
     * @param {string} [fields] list of fields separated by comma
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    iserverMarketdataSnapshotGet(conids, since, fields, options) {
        return (0, exports.MarketDataApiFp)(this.configuration)
            .iserverMarketdataSnapshotGet(conids, since, fields, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Cancel all market data request(s). To cancel market data for given conid, see /iserver/marketdata/{conid}/unsubscribe.
     * @summary Market Data Cancel (All)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MarketDataApi
     */
    iserverMarketdataUnsubscribeallGet(options) {
        return (0, exports.MarketDataApiFp)(this.configuration)
            .iserverMarketdataUnsubscribeallGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.MarketDataApi = MarketDataApi;
/**
 * OrderApi - axios parameter creator
 * @export
 */
const OrderApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
         * @summary Cancel Order
         * @param {string} accountId account id, or fa group if deleting a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdDelete: (accountId, orderId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderOrderIdDelete", "accountId", accountId);
            // verify required parameter 'orderId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderOrderIdDelete", "orderId", orderId);
            const localVarPath = `/iserver/account/{accountId}/order/{orderId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "DELETE" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
         * @summary Modify Order
         * @param {string} accountId account id, or fa group if modifying a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {ModifyOrder} body modify-order request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdPost: (accountId, orderId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderOrderIdPost", "accountId", accountId);
            // verify required parameter 'orderId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderOrderIdPost", "orderId", orderId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderOrderIdPost", "body", body);
            const localVarPath = `/iserver/account/{accountId}/order/{orderId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
         * @summary Place Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderPost: (accountId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderPost", "accountId", accountId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderPost", "body", body);
            const localVarPath = `/iserver/account/{accountId}/order`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
         * @summary Preview Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderWhatifPost: (accountId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderWhatifPost", "accountId", accountId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrderWhatifPost", "body", body);
            const localVarPath = `/iserver/account/{accountId}/order/whatif`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
         * @summary Place Orders
         * @param {string} accountId account id
         * @param {InlineObject5} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersPost: (accountId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrdersPost", "accountId", accountId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrdersPost", "body", body);
            const localVarPath = `/iserver/account/{accountId}/orders`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
         * @summary Preview Orders
         * @param {string} accountId account id
         * @param {InlineObject7} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersWhatifPost: (accountId, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrdersWhatifPost", "accountId", accountId);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountAccountIdOrdersWhatifPost", "body", body);
            const localVarPath = `/iserver/account/{accountId}/orders/whatif`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Order Status
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrderStatusOrderIdGet: (orderId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'orderId' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountOrderStatusOrderIdGet", "orderId", orderId);
            const localVarPath = `/iserver/account/order/status/{orderId}`.replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
         * @summary Place Orders for FA
         * @param {string} faGroup financial advisor group
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersFaGroupPost: (faGroup, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'faGroup' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountOrdersFaGroupPost", "faGroup", faGroup);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverAccountOrdersFaGroupPost", "body", body);
            const localVarPath = `/iserver/account/orders/{faGroup}`.replace(`{${"faGroup"}}`, encodeURIComponent(String(faGroup)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Live Orders
         * @param {InlineObject4} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersGet: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/account/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Reply to questions when placing orders and submit orders
         * @summary Place Order Reply
         * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
         * @param {InlineObject6} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReplyReplyidPost: (replyid, body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'replyid' is not null or undefined
            (0, common_1.assertParamExists)("iserverReplyReplyidPost", "replyid", replyid);
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverReplyReplyidPost", "body", body);
            const localVarPath = `/iserver/reply/{replyid}`.replace(`{${"replyid"}}`, encodeURIComponent(String(replyid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.OrderApiAxiosParamCreator = OrderApiAxiosParamCreator;
/**
 * OrderApi - functional programming interface
 * @export
 */
const OrderApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.OrderApiAxiosParamCreator)(configuration);
    return {
        /**
         * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
         * @summary Cancel Order
         * @param {string} accountId account id, or fa group if deleting a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
         * @summary Modify Order
         * @param {string} accountId account id, or fa group if modifying a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {ModifyOrder} body modify-order request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
         * @summary Place Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderPost(accountId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdOrderPost(accountId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
         * @summary Preview Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderWhatifPost(accountId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdOrderWhatifPost(accountId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
         * @summary Place Orders
         * @param {string} accountId account id
         * @param {InlineObject5} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersPost(accountId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdOrdersPost(accountId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
         * @summary Preview Orders
         * @param {string} accountId account id
         * @param {InlineObject7} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersWhatifPost(accountId, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountAccountIdOrdersWhatifPost(accountId, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Order Status
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrderStatusOrderIdGet(orderId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountOrderStatusOrderIdGet(orderId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
         * @summary Place Orders for FA
         * @param {string} faGroup financial advisor group
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersFaGroupPost(faGroup, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountOrdersFaGroupPost(faGroup, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Live Orders
         * @param {InlineObject4} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersGet(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountOrdersGet(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Reply to questions when placing orders and submit orders
         * @summary Place Order Reply
         * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
         * @param {InlineObject6} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReplyReplyidPost(replyid, body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverReplyReplyidPost(replyid, body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.OrderApiFp = OrderApiFp;
/**
 * OrderApi - factory interface
 * @export
 */
const OrderApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.OrderApiFp)(configuration);
    return {
        /**
         * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
         * @summary Cancel Order
         * @param {string} accountId account id, or fa group if deleting a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options) {
            return localVarFp
                .iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
         * @summary Modify Order
         * @param {string} accountId account id, or fa group if modifying a group order
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {ModifyOrder} body modify-order request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options) {
            return localVarFp
                .iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
         * @summary Place Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderPost(accountId, body, options) {
            return localVarFp
                .iserverAccountAccountIdOrderPost(accountId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
         * @summary Preview Order (Deprecated)
         * @param {string} accountId account id
         * @param {OrderRequest} body order info
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrderWhatifPost(accountId, body, options) {
            return localVarFp
                .iserverAccountAccountIdOrderWhatifPost(accountId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
         * @summary Place Orders
         * @param {string} accountId account id
         * @param {InlineObject5} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersPost(accountId, body, options) {
            return localVarFp
                .iserverAccountAccountIdOrdersPost(accountId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
         * @summary Preview Orders
         * @param {string} accountId account id
         * @param {InlineObject7} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountAccountIdOrdersWhatifPost(accountId, body, options) {
            return localVarFp
                .iserverAccountAccountIdOrdersWhatifPost(accountId, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Order Status
         * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrderStatusOrderIdGet(orderId, options) {
            return localVarFp
                .iserverAccountOrderStatusOrderIdGet(orderId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
         * @summary Place Orders for FA
         * @param {string} faGroup financial advisor group
         * @param {OrderRequest} body order request info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersFaGroupPost(faGroup, body, options) {
            return localVarFp
                .iserverAccountOrdersFaGroupPost(faGroup, body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Live Orders
         * @param {InlineObject4} [body]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountOrdersGet(body, options) {
            return localVarFp
                .iserverAccountOrdersGet(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Reply to questions when placing orders and submit orders
         * @summary Place Order Reply
         * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
         * @param {InlineObject6} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReplyReplyidPost(replyid, body, options) {
            return localVarFp
                .iserverReplyReplyidPost(replyid, body, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.OrderApiFactory = OrderApiFactory;
/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
class OrderApi extends base_1.BaseAPI {
    /**
     * Cancels an open order. Must call /iserver/accounts endpoint prior to cancelling an order. Use /iservers/account/orders endpoint to review open-order(s) and get latest order status.
     * @summary Cancel Order
     * @param {string} accountId account id, or fa group if deleting a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountAccountIdOrderOrderIdDelete(accountId, orderId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Modifies an open order. Must call /iserver/accounts endpoint prior to modifying an order. Use /iservers/account/orders endpoint to review open-order(s).
     * @summary Modify Order
     * @param {string} accountId account id, or fa group if modifying a group order
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {ModifyOrder} body modify-order request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountAccountIdOrderOrderIdPost(accountId, orderId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders, just pass one order in the array, the order structure will be same. Please note here, sometimes this endpoint alone can\'t make sure you submit the order successfully, you could receive some questions in the response, you have to to answer them in order to submit the order successfully. You can use \"/iserver/reply/{replyid}\" endpoint to answer questions
     * @summary Place Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountAccountIdOrderPost(accountId, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountAccountIdOrderPost(accountId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * This end-point is going to be deprecated, you can use /iserver/account/{accountId}/orders/whatif, just pass one order in the array, the order structure will be same. This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response.
     * @summary Preview Order (Deprecated)
     * @param {string} accountId account id
     * @param {OrderRequest} body order info
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountAccountIdOrderWhatifPost(accountId, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountAccountIdOrderWhatifPost(accountId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * You can pass a list of orders here such as bracket and OCA orders. Notes for OCA(one cancel all orders) orders: 1. if one order in the group is filled/cancelled, all the others in the same group will be cancelled. 2. To create OCA orders, please set isSingleGroup to true in each order 3. All orders in the same group will have same oca_group_id, you can get oca_group_id from /iserver/account/order/status/{orderId} end-point after orders are placed successfully
     * @summary Place Orders
     * @param {string} accountId account id
     * @param {InlineObject5} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountAccountIdOrdersPost(accountId, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountAccountIdOrdersPost(accountId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * This endpoint allows you to preview order without actually submitting the order and you can get commission information in the response. Also supports bracket orders.
     * @summary Preview Orders
     * @param {string} accountId account id
     * @param {InlineObject7} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountAccountIdOrdersWhatifPost(accountId, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountAccountIdOrdersWhatifPost(accountId, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Order Status
     * @param {string} orderId Customer order id, use /iservers/account/orders endpoint to query orderId.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountOrderStatusOrderIdGet(orderId, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountOrderStatusOrderIdGet(orderId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Financial Advisors can use this endpoint to place an order for a specified group. To place an order for a specified account use the endpoint /iserver/account/{accountId}/order. More information about groups can be found in the [TWS Users\' Guide:](https://guides.interactivebrokers.com/twsguide/twsguide.htm#usersguidebook/financialadvisors/create_an_account_group_for_share_allocation.htm).
     * @summary Place Orders for FA
     * @param {string} faGroup financial advisor group
     * @param {OrderRequest} body order request info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountOrdersFaGroupPost(faGroup, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountOrdersFaGroupPost(faGroup, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * The endpoint is meant to be used in polling mode, e.g. requesting every x seconds. The response will contain two objects, one is notification, the other is orders. Orders is the list of live orders (cancelled, filled, submitted). Notifications contains information about execute orders as they happen, see status field. To receive streaming live orders the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Live Orders
     * @param {InlineObject4} [body]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverAccountOrdersGet(body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverAccountOrdersGet(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Reply to questions when placing orders and submit orders
     * @summary Place Order Reply
     * @param {string} replyid Please use the \&quot;id\&quot; from the response of \&quot;Place Order\&quot; endpoint
     * @param {InlineObject6} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    iserverReplyReplyidPost(replyid, body, options) {
        return (0, exports.OrderApiFp)(this.configuration)
            .iserverReplyReplyidPost(replyid, body, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.OrderApi = OrderApi;
/**
 * PnLApi - axios parameter creator
 * @export
 */
const PnLApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/account/pnl/partitioned`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PnLApiAxiosParamCreator = PnLApiAxiosParamCreator;
/**
 * PnLApi - functional programming interface
 * @export
 */
const PnLApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PnLApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountPnlPartitionedGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PnLApiFp = PnLApiFp;
/**
 * PnLApi - factory interface
 * @export
 */
const PnLApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PnLApiFp)(configuration);
    return {
        /**
         * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary PnL for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountPnlPartitionedGet(options) {
            return localVarFp
                .iserverAccountPnlPartitionedGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.PnLApiFactory = PnLApiFactory;
/**
 * PnLApi - object-oriented interface
 * @export
 * @class PnLApi
 * @extends {BaseAPI}
 */
class PnLApi extends base_1.BaseAPI {
    /**
     * Returns an object containing PnL for the selected account and its models (if any). To receive streaming PnL the endpoint /ws can be used. Refer to [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary PnL for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PnLApi
     */
    iserverAccountPnlPartitionedGet(options) {
        return (0, exports.PnLApiFp)(this.configuration)
            .iserverAccountPnlPartitionedGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PnLApi = PnLApi;
/**
 * PortfolioApi - axios parameter creator
 * @export
 */
const PortfolioApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Allocation
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdAllocationGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdAllocationGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/allocation`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdLedgerGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/ledger`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdMetaGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/meta`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Position by Conid
         * @param {string} accountId account id
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionConidGet: (accountId, conid, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdPositionConidGet", "accountId", accountId);
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdPositionConidGet", "conid", conid);
            const localVarPath = `/portfolio/{accountId}/position/{conid}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary Invalidates the backend cache of the Portfolio
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsInvalidatePost: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdPositionsInvalidatePost", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/positions/invalidate`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Portfolio Positions
         * @param {string} accountId account id
         * @param {string} pageId page id
         * @param {string} [model] optional
         * @param {string} [sort] declare the table to be sorted by which column
         * @param {string} [direction] in which order, a means ascending - d means descending
         * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsPageIdGet: (accountId, pageId, model, sort, direction, period, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdPositionsPageIdGet", "accountId", accountId);
            // verify required parameter 'pageId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdPositionsPageIdGet", "pageId", pageId);
            const localVarPath = `/portfolio/{accountId}/positions/{pageId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)))
                .replace(`{${"pageId"}}`, encodeURIComponent(String(pageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (model !== undefined) {
                localVarQueryParameter["model"] = model;
            }
            if (sort !== undefined) {
                localVarQueryParameter["sort"] = sort;
            }
            if (direction !== undefined) {
                localVarQueryParameter["direction"] = direction;
            }
            if (period !== undefined) {
                localVarQueryParameter["period"] = period;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet: (accountId, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'accountId' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAccountIdSummaryGet", "accountId", accountId);
            const localVarPath = `/portfolio/{accountId}/summary`.replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/portfolio/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Alloction (All Accounts)
         * @param {InlineObject10} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAllocationPost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("portfolioAllocationPost", "body", body);
            const localVarPath = `/portfolio/allocation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Positions by Conid
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioPositionsConidGet: (conid, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'conid' is not null or undefined
            (0, common_1.assertParamExists)("portfolioPositionsConidGet", "conid", conid);
            const localVarPath = `/portfolio/positions/{conid}`.replace(`{${"conid"}}`, encodeURIComponent(String(conid)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/portfolio/subaccounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PortfolioApiAxiosParamCreator = PortfolioApiAxiosParamCreator;
/**
 * PortfolioApi - functional programming interface
 * @export
 */
const PortfolioApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PortfolioApiAxiosParamCreator)(configuration);
    return {
        /**
         * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Allocation
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdAllocationGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdAllocationGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdLedgerGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdMetaGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Position by Conid
         * @param {string} accountId account id
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionConidGet(accountId, conid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdPositionConidGet(accountId, conid, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary Invalidates the backend cache of the Portfolio
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsInvalidatePost(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdPositionsInvalidatePost(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Portfolio Positions
         * @param {string} accountId account id
         * @param {string} pageId page id
         * @param {string} [model] optional
         * @param {string} [sort] declare the table to be sorted by which column
         * @param {string} [direction] in which order, a means ascending - d means descending
         * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet(accountId, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountIdSummaryGet(accountId, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAccountsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Alloction (All Accounts)
         * @param {InlineObject10} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAllocationPost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioAllocationPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Positions by Conid
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioPositionsConidGet(conid, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioPositionsConidGet(conid, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.portfolioSubaccountsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PortfolioApiFp = PortfolioApiFp;
/**
 * PortfolioApi - factory interface
 * @export
 */
const PortfolioApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PortfolioApiFp)(configuration);
    return {
        /**
         * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Allocation
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdAllocationGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdAllocationGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
         * @summary Account Ledger
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdLedgerGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdLedgerGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Information
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdMetaGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdMetaGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Position by Conid
         * @param {string} accountId account id
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionConidGet(accountId, conid, options) {
            return localVarFp
                .portfolioAccountIdPositionConidGet(accountId, conid, options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Invalidates the backend cache of the Portfolio
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsInvalidatePost(accountId, options) {
            return localVarFp
                .portfolioAccountIdPositionsInvalidatePost(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Portfolio Positions
         * @param {string} accountId account id
         * @param {string} pageId page id
         * @param {string} [model] optional
         * @param {string} [sort] declare the table to be sorted by which column
         * @param {string} [direction] in which order, a means ascending - d means descending
         * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options) {
            return localVarFp
                .portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Summary
         * @param {string} accountId account id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountIdSummaryGet(accountId, options) {
            return localVarFp
                .portfolioAccountIdSummaryGet(accountId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
         * @summary Portfolio Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAccountsGet(options) {
            return localVarFp
                .portfolioAccountsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Account Alloction (All Accounts)
         * @param {InlineObject10} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioAllocationPost(body, options) {
            return localVarFp
                .portfolioAllocationPost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
         * @summary Positions by Conid
         * @param {number} conid contract id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioPositionsConidGet(conid, options) {
            return localVarFp
                .portfolioPositionsConidGet(conid, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
         * @summary List of Sub-Accounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portfolioSubaccountsGet(options) {
            return localVarFp
                .portfolioSubaccountsGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.PortfolioApiFactory = PortfolioApiFactory;
/**
 * PortfolioApi - object-oriented interface
 * @export
 * @class PortfolioApi
 * @extends {BaseAPI}
 */
class PortfolioApi extends base_1.BaseAPI {
    /**
     * Information about the account\'s portfolio allocation by Asset Class, Industry and Category.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Allocation
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdAllocationGet(accountId, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdAllocationGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Information regarding settled cash, cash balances, etc. in the account\'s base currency and any other cash balances hold in other currencies.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint. The list of supported currencies is available at https://www.interactivebrokers.com/en/index.php?f=3185.
     * @summary Account Ledger
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdLedgerGet(accountId, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdLedgerGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Account information related to account Id /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Information
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdMetaGet(accountId, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdMetaGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of all positions matching the conid. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to.  /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Position by Conid
     * @param {string} accountId account id
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdPositionConidGet(accountId, conid, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdPositionConidGet(accountId, conid, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Invalidates the backend cache of the Portfolio
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdPositionsInvalidatePost(accountId, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdPositionsInvalidatePost(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a list of positions for the given account. The endpoint supports paging, page\'s default size is 30 positions. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Portfolio Positions
     * @param {string} accountId account id
     * @param {string} pageId page id
     * @param {string} [model] optional
     * @param {string} [sort] declare the table to be sorted by which column
     * @param {string} [direction] in which order, a means ascending - d means descending
     * @param {string} [period] period for pnl column, can be 1D, 7D, 1M...
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdPositionsPageIdGet(accountId, pageId, model, sort, direction, period, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns information about margin, cash balances and other information related to specified account. See also /portfolio/{accountId}/ledger. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Summary
     * @param {string} accountId account id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountIdSummaryGet(accountId, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountIdSummaryGet(accountId, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * In non-tiered account structures, returns a list of accounts for which the user can view position and account information. This endpoint must be called prior  to calling other /portfolio endpoints for those accounts. For querying a list of accounts  which the user can trade, see /iserver/accounts. For a list of subaccounts in tiered  account structures (e.g. financial advisor or ibroker accounts) see /portfolio/subaccounts.
     * @summary Portfolio Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAccountsGet(options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAccountsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Similar to /portfolio/{accountId}/allocation but returns a consolidated view of of all the accounts returned by /portfolio/accounts. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Account Alloction (All Accounts)
     * @param {InlineObject10} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioAllocationPost(body, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioAllocationPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an object of all positions matching the conid for all the selected accounts. For portfolio models the conid could be in more than one model, returning an array with the name of the model it belongs to. /portfolio/accounts or /portfolio/subaccounts must be called prior to this endpoint.
     * @summary Positions by Conid
     * @param {number} conid contract id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioPositionsConidGet(conid, options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioPositionsConidGet(conid, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Used in tiered account structures (such as financial advisor and ibroker accounts)  to return a list of sub-accounts for which the user can view position and  account-related information. This endpoint must be called prior to calling other  /portfolio endpoints for those subaccounts.  To query a list of accounts the user can trade, see /iserver/accounts.
     * @summary List of Sub-Accounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioApi
     */
    portfolioSubaccountsGet(options) {
        return (0, exports.PortfolioApiFp)(this.configuration)
            .portfolioSubaccountsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PortfolioApi = PortfolioApi;
/**
 * PortfolioAnalystApi - axios parameter creator
 * @export
 */
const PortfolioAnalystApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Performance
         * @param {InlineObject11} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paPerformancePost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("paPerformancePost", "body", body);
            const localVarPath = `/pa/performance`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Balance\'s Summary
         * @param {InlineObject12} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paSummaryPost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("paSummaryPost", "body", body);
            const localVarPath = `/pa/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
         * @summary Position\'s Transaction History
         * @param {InlineObject13} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paTransactionsPost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("paTransactionsPost", "body", body);
            const localVarPath = `/pa/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.PortfolioAnalystApiAxiosParamCreator = PortfolioAnalystApiAxiosParamCreator;
/**
 * PortfolioAnalystApi - functional programming interface
 * @export
 */
const PortfolioAnalystApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.PortfolioAnalystApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Performance
         * @param {InlineObject11} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paPerformancePost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.paPerformancePost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Balance\'s Summary
         * @param {InlineObject12} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paSummaryPost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.paSummaryPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
         * @summary Position\'s Transaction History
         * @param {InlineObject13} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paTransactionsPost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.paTransactionsPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.PortfolioAnalystApiFp = PortfolioAnalystApiFp;
/**
 * PortfolioAnalystApi - factory interface
 * @export
 */
const PortfolioAnalystApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.PortfolioAnalystApiFp)(configuration);
    return {
        /**
         * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Performance
         * @param {InlineObject11} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paPerformancePost(body, options) {
            return localVarFp
                .paPerformancePost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
         * @summary Account Balance\'s Summary
         * @param {InlineObject12} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paSummaryPost(body, options) {
            return localVarFp
                .paSummaryPost(body, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
         * @summary Position\'s Transaction History
         * @param {InlineObject13} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        paTransactionsPost(body, options) {
            return localVarFp
                .paTransactionsPost(body, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.PortfolioAnalystApiFactory = PortfolioAnalystApiFactory;
/**
 * PortfolioAnalystApi - object-oriented interface
 * @export
 * @class PortfolioAnalystApi
 * @extends {BaseAPI}
 */
class PortfolioAnalystApi extends base_1.BaseAPI {
    /**
     * Returns the performance (MTM) for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Performance
     * @param {InlineObject11} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioAnalystApi
     */
    paPerformancePost(body, options) {
        return (0, exports.PortfolioAnalystApiFp)(this.configuration)
            .paPerformancePost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns a summary of all account balances for the given accounts, if more than one account is passed, the result is consolidated.
     * @summary Account Balance\'s Summary
     * @param {InlineObject12} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioAnalystApi
     */
    paSummaryPost(body, options) {
        return (0, exports.PortfolioAnalystApiFp)(this.configuration)
            .paSummaryPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * transaction history for a given number of conids and accounts. Types of transactions include dividend payments, buy and sell transactions, transfers.
     * @summary Position\'s Transaction History
     * @param {InlineObject13} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortfolioAnalystApi
     */
    paTransactionsPost(body, options) {
        return (0, exports.PortfolioAnalystApiFp)(this.configuration)
            .paTransactionsPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.PortfolioAnalystApi = PortfolioAnalystApi;
/**
 * ScannerApi - axios parameter creator
 * @export
 */
const ScannerApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns an object contains four lists contain all parameters for scanners
         * @summary Scanner Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerParamsGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/scanner/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         *
         * @summary run scanner to get a list of contracts
         * @param {ScannerParams} body scanner-params request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerRunPost: (body, options = {}) => __awaiter(this, void 0, void 0, function* () {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)("iserverScannerRunPost", "body", body);
            const localVarPath = `/iserver/scanner/run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter["Content-Type"] = "application/json";
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.ScannerApiAxiosParamCreator = ScannerApiAxiosParamCreator;
/**
 * ScannerApi - functional programming interface
 * @export
 */
const ScannerApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.ScannerApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns an object contains four lists contain all parameters for scanners
         * @summary Scanner Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerParamsGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverScannerParamsGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         *
         * @summary run scanner to get a list of contracts
         * @param {ScannerParams} body scanner-params request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerRunPost(body, options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverScannerRunPost(body, options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.ScannerApiFp = ScannerApiFp;
/**
 * ScannerApi - factory interface
 * @export
 */
const ScannerApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.ScannerApiFp)(configuration);
    return {
        /**
         * Returns an object contains four lists contain all parameters for scanners
         * @summary Scanner Parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerParamsGet(options) {
            return localVarFp
                .iserverScannerParamsGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary run scanner to get a list of contracts
         * @param {ScannerParams} body scanner-params request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverScannerRunPost(body, options) {
            return localVarFp
                .iserverScannerRunPost(body, options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.ScannerApiFactory = ScannerApiFactory;
/**
 * ScannerApi - object-oriented interface
 * @export
 * @class ScannerApi
 * @extends {BaseAPI}
 */
class ScannerApi extends base_1.BaseAPI {
    /**
     * Returns an object contains four lists contain all parameters for scanners
     * @summary Scanner Parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    iserverScannerParamsGet(options) {
        return (0, exports.ScannerApiFp)(this.configuration)
            .iserverScannerParamsGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary run scanner to get a list of contracts
     * @param {ScannerParams} body scanner-params request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ScannerApi
     */
    iserverScannerRunPost(body, options) {
        return (0, exports.ScannerApiFp)(this.configuration)
            .iserverScannerRunPost(body, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.ScannerApi = ScannerApi;
/**
 * SessionApi - axios parameter creator
 * @export
 */
const SessionApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
         * @summary Authentication Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAuthStatusPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/auth/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
         * @summary Tries to re-authenticate to Brokerage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReauthenticatePost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/reauthenticate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Logs the user out of the gateway session. Any further activity requires re-authentication.
         * @summary Ends the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * Validates the current session for the SSO user
         * @summary Validate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoValidateGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/sso/validate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
        /**
         * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
         * @summary Ping the server to keep the session open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticklePost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/tickle`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.SessionApiAxiosParamCreator = SessionApiAxiosParamCreator;
/**
 * SessionApi - functional programming interface
 * @export
 */
const SessionApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.SessionApiAxiosParamCreator)(configuration);
    return {
        /**
         * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
         * @summary Authentication Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAuthStatusPost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAuthStatusPost(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
         * @summary Tries to re-authenticate to Brokerage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReauthenticatePost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverReauthenticatePost(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Logs the user out of the gateway session. Any further activity requires re-authentication.
         * @summary Ends the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.logoutPost(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * Validates the current session for the SSO user
         * @summary Validate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoValidateGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ssoValidateGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
        /**
         * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
         * @summary Ping the server to keep the session open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticklePost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.ticklePost(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.SessionApiFp = SessionApiFp;
/**
 * SessionApi - factory interface
 * @export
 */
const SessionApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.SessionApiFp)(configuration);
    return {
        /**
         * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
         * @summary Authentication Status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAuthStatusPost(options) {
            return localVarFp
                .iserverAuthStatusPost(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
         * @summary Tries to re-authenticate to Brokerage
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverReauthenticatePost(options) {
            return localVarFp
                .iserverReauthenticatePost(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Logs the user out of the gateway session. Any further activity requires re-authentication.
         * @summary Ends the current session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutPost(options) {
            return localVarFp
                .logoutPost(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Validates the current session for the SSO user
         * @summary Validate SSO
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ssoValidateGet(options) {
            return localVarFp
                .ssoValidateGet(options)
                .then((request) => request(axios, basePath));
        },
        /**
         * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
         * @summary Ping the server to keep the session open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ticklePost(options) {
            return localVarFp
                .ticklePost(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.SessionApiFactory = SessionApiFactory;
/**
 * SessionApi - object-oriented interface
 * @export
 * @class SessionApi
 * @extends {BaseAPI}
 */
class SessionApi extends base_1.BaseAPI {
    /**
     * Current Authentication status to the Brokerage system. Market Data and Trading is not possible if not authenticated, e.g. authenticated shows false
     * @summary Authentication Status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    iserverAuthStatusPost(options) {
        return (0, exports.SessionApiFp)(this.configuration)
            .iserverAuthStatusPost(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * When using the CP Gateway, this endpoint provides a way to reauthenticate to the Brokerage system as long as there is a valid SSO session, see /sso/validate.
     * @summary Tries to re-authenticate to Brokerage
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    iserverReauthenticatePost(options) {
        return (0, exports.SessionApiFp)(this.configuration)
            .iserverReauthenticatePost(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Logs the user out of the gateway session. Any further activity requires re-authentication.
     * @summary Ends the current session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    logoutPost(options) {
        return (0, exports.SessionApiFp)(this.configuration)
            .logoutPost(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * Validates the current session for the SSO user
     * @summary Validate SSO
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    ssoValidateGet(options) {
        return (0, exports.SessionApiFp)(this.configuration)
            .ssoValidateGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
    /**
     * If the gateway has not received any requests for several minutes an open session will automatically timeout. The tickle endpoint pings the server to prevent the session from ending.
     * @summary Ping the server to keep the session open
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SessionApi
     */
    ticklePost(options) {
        return (0, exports.SessionApiFp)(this.configuration)
            .ticklePost(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.SessionApi = SessionApi;
/**
 * StreamingApi - axios parameter creator
 * @export
 */
const StreamingApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Websocket Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsPost: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/ws`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "POST" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.StreamingApiAxiosParamCreator = StreamingApiAxiosParamCreator;
/**
 * StreamingApi - functional programming interface
 * @export
 */
const StreamingApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.StreamingApiAxiosParamCreator)(configuration);
    return {
        /**
         * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Websocket Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsPost(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.wsPost(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.StreamingApiFp = StreamingApiFp;
/**
 * StreamingApi - factory interface
 * @export
 */
const StreamingApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.StreamingApiFp)(configuration);
    return {
        /**
         * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
         * @summary Websocket Endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        wsPost(options) {
            return localVarFp
                .wsPost(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.StreamingApiFactory = StreamingApiFactory;
/**
 * StreamingApi - object-oriented interface
 * @export
 * @class StreamingApi
 * @extends {BaseAPI}
 */
class StreamingApi extends base_1.BaseAPI {
    /**
     * The streaming API is documented under [Streaming WebSocket Data](https://interactivebrokers.github.io/cpwebapi/RealtimeSubscription.html) for details.
     * @summary Websocket Endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamingApi
     */
    wsPost(options) {
        return (0, exports.StreamingApiFp)(this.configuration)
            .wsPost(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.StreamingApi = StreamingApi;
/**
 * TradesApi - axios parameter creator
 * @export
 */
const TradesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
         * @summary List of Trades for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountTradesGet: (options = {}) => __awaiter(this, void 0, void 0, function* () {
            const localVarPath = `/iserver/account/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = Object.assign(Object.assign({ method: "GET" }, baseOptions), options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = Object.assign(Object.assign(Object.assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        }),
    };
};
exports.TradesApiAxiosParamCreator = TradesApiAxiosParamCreator;
/**
 * TradesApi - functional programming interface
 * @export
 */
const TradesApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.TradesApiAxiosParamCreator)(configuration);
    return {
        /**
         * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
         * @summary List of Trades for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountTradesGet(options) {
            return __awaiter(this, void 0, void 0, function* () {
                const localVarAxiosArgs = yield localVarAxiosParamCreator.iserverAccountTradesGet(options);
                return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
            });
        },
    };
};
exports.TradesApiFp = TradesApiFp;
/**
 * TradesApi - factory interface
 * @export
 */
const TradesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.TradesApiFp)(configuration);
    return {
        /**
         * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
         * @summary List of Trades for the selected account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iserverAccountTradesGet(options) {
            return localVarFp
                .iserverAccountTradesGet(options)
                .then((request) => request(axios, basePath));
        },
    };
};
exports.TradesApiFactory = TradesApiFactory;
/**
 * TradesApi - object-oriented interface
 * @export
 * @class TradesApi
 * @extends {BaseAPI}
 */
class TradesApi extends base_1.BaseAPI {
    /**
     * Returns a list of trades for the currently selected account for current day and six previous days. It is advised to call this endpoint once per session.
     * @summary List of Trades for the selected account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradesApi
     */
    iserverAccountTradesGet(options) {
        return (0, exports.TradesApiFp)(this.configuration)
            .iserverAccountTradesGet(options)
            .then((request) => request(this.axios, this.basePath));
    }
}
exports.TradesApi = TradesApi;
